<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Web Development with Rust - Rust Universe: Fearless Systems Engineering</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="A comprehensive guide to learning the Rust programming language from fundamentals to mastery.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 1: Fundamentals</li><li class="chapter-item expanded "><a href="../chapters/01-about-this-book.html"><strong aria-hidden="true">1.</strong> About This Book</a></li><li class="chapter-item expanded "><a href="../chapters/02-introduction-to-rust.html"><strong aria-hidden="true">2.</strong> Introduction to Rust</a></li><li class="chapter-item expanded "><a href="../chapters/03-getting-started.html"><strong aria-hidden="true">3.</strong> Getting Started with the Rust Toolchain</a></li><li class="chapter-item expanded "><a href="../chapters/04-basic-syntax.html"><strong aria-hidden="true">4.</strong> Basic Syntax and Data Types</a></li><li class="chapter-item expanded "><a href="../chapters/05-control-flow.html"><strong aria-hidden="true">5.</strong> Control Flow in Rust</a></li><li class="chapter-item expanded "><a href="../chapters/06-functions.html"><strong aria-hidden="true">6.</strong> Functions and Procedures</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 2: Ownership - Rust's Secret Weapon</li><li class="chapter-item expanded "><a href="../chapters/07-understanding-ownership.html"><strong aria-hidden="true">7.</strong> Understanding Ownership</a></li><li class="chapter-item expanded "><a href="../chapters/08-borrowing-references.html"><strong aria-hidden="true">8.</strong> Borrowing and References</a></li><li class="chapter-item expanded "><a href="../chapters/09-strings-slices.html"><strong aria-hidden="true">9.</strong> Working with Strings and Slices</a></li><li class="chapter-item expanded "><a href="../chapters/10-advanced-ownership.html"><strong aria-hidden="true">10.</strong> Advanced Ownership Patterns</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 3: Organizing Code</li><li class="chapter-item expanded "><a href="../chapters/11-structs.html"><strong aria-hidden="true">11.</strong> Structs and Custom Types</a></li><li class="chapter-item expanded "><a href="../chapters/12-enums.html"><strong aria-hidden="true">12.</strong> Enums and Pattern Matching</a></li><li class="chapter-item expanded "><a href="../chapters/13-modules.html"><strong aria-hidden="true">13.</strong> Modules and Organizing Code</a></li><li class="chapter-item expanded "><a href="../chapters/14-collections.html"><strong aria-hidden="true">14.</strong> Collections and Data Structures</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 4: Generic Programming</li><li class="chapter-item expanded "><a href="../chapters/15-generics.html"><strong aria-hidden="true">15.</strong> Introduction to Generics</a></li><li class="chapter-item expanded "><a href="../chapters/16-traits.html"><strong aria-hidden="true">16.</strong> Traits and Polymorphism</a></li><li class="chapter-item expanded "><a href="../chapters/17-advanced-traits.html"><strong aria-hidden="true">17.</strong> Advanced Trait Patterns</a></li><li class="chapter-item expanded "><a href="../chapters/18-lifetimes.html"><strong aria-hidden="true">18.</strong> Understanding Lifetimes</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 5: Error Handling</li><li class="chapter-item expanded "><a href="../chapters/19-panic.html"><strong aria-hidden="true">19.</strong> Panic and Unrecoverable Errors</a></li><li class="chapter-item expanded "><a href="../chapters/20-result-option.html"><strong aria-hidden="true">20.</strong> Result, Option, and Recoverable Errors</a></li><li class="chapter-item expanded "><a href="../chapters/21-error-patterns.html"><strong aria-hidden="true">21.</strong> Error Handling Patterns and Libraries</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 6: Advanced Rust</li><li class="chapter-item expanded "><a href="../chapters/22-iterators.html"><strong aria-hidden="true">22.</strong> Iterators and Functional Programming</a></li><li class="chapter-item expanded "><a href="../chapters/23-closures.html"><strong aria-hidden="true">23.</strong> Closures in Depth</a></li><li class="chapter-item expanded "><a href="../chapters/24-concurrency.html"><strong aria-hidden="true">24.</strong> Concurrency Fundamentals</a></li><li class="chapter-item expanded "><a href="../chapters/25-async.html"><strong aria-hidden="true">25.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="../chapters/26-macros.html"><strong aria-hidden="true">26.</strong> Macros and Metaprogramming</a></li><li class="chapter-item expanded "><a href="../chapters/27-unsafe.html"><strong aria-hidden="true">27.</strong> Unsafe Rust</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 7: Practical Rust</li><li class="chapter-item expanded "><a href="../chapters/28-testing.html"><strong aria-hidden="true">28.</strong> Writing Tests in Rust</a></li><li class="chapter-item expanded "><a href="../chapters/29-cli.html"><strong aria-hidden="true">29.</strong> Command-Line Applications</a></li><li class="chapter-item expanded "><a href="../chapters/30-web.html" class="active"><strong aria-hidden="true">30.</strong> Web Development with Rust</a></li><li class="chapter-item expanded "><a href="../chapters/31-database.html"><strong aria-hidden="true">31.</strong> Database Interaction</a></li><li class="chapter-item expanded "><a href="../chapters/32-network.html"><strong aria-hidden="true">32.</strong> Network Programming</a></li><li class="chapter-item expanded "><a href="../chapters/33-systems.html"><strong aria-hidden="true">33.</strong> Systems Programming</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 8: The Rust Ecosystem</li><li class="chapter-item expanded "><a href="../chapters/34-cargo.html"><strong aria-hidden="true">34.</strong> Package Management with Cargo</a></li><li class="chapter-item expanded "><a href="../chapters/35-build-systems.html"><strong aria-hidden="true">35.</strong> Build Systems and Tooling</a></li><li class="chapter-item expanded "><a href="../chapters/36-performance.html"><strong aria-hidden="true">36.</strong> Performance Optimization</a></li><li class="chapter-item expanded "><a href="../chapters/37-interoperability.html"><strong aria-hidden="true">37.</strong> Interoperability with Other Languages</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 9: Modern Rust Applications</li><li class="chapter-item expanded "><a href="../chapters/38-database-building.html"><strong aria-hidden="true">38.</strong> Building a Database</a></li><li class="chapter-item expanded "><a href="../chapters/39-game-development.html"><strong aria-hidden="true">39.</strong> Game Development</a></li><li class="chapter-item expanded "><a href="../chapters/40-cloud-native.html"><strong aria-hidden="true">40.</strong> Cloud Native Rust</a></li><li class="chapter-item expanded "><a href="../chapters/41-distributed-systems.html"><strong aria-hidden="true">41.</strong> Distributed Systems</a></li><li class="chapter-item expanded "><a href="../chapters/42-machine-learning.html"><strong aria-hidden="true">42.</strong> Machine Learning and Data Science</a></li><li class="chapter-item expanded "><a href="../chapters/43-embedded.html"><strong aria-hidden="true">43.</strong> Embedded Systems and IoT</a></li><li class="chapter-item expanded "><a href="../chapters/44-production-ready.html"><strong aria-hidden="true">44.</strong> Production-Ready Rust</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 10: Capstone Projects</li><li class="chapter-item expanded "><a href="../chapters/45-search-engine.html"><strong aria-hidden="true">45.</strong> Building a Search Engine</a></li><li class="chapter-item expanded "><a href="../chapters/46-programming-language.html"><strong aria-hidden="true">46.</strong> Developing a Programming Language</a></li><li class="chapter-item expanded "><a href="../chapters/47-blockchain.html"><strong aria-hidden="true">47.</strong> Creating a Blockchain Application</a></li><li class="chapter-item expanded "><a href="../chapters/48-data-processing.html"><strong aria-hidden="true">48.</strong> Real-Time Data Processing System</a></li><li class="chapter-item expanded "><a href="../chapters/49-wasm-frontend.html"><strong aria-hidden="true">49.</strong> WebAssembly and Frontend Development</a></li><li class="chapter-item expanded "><a href="../chapters/50-advanced-memory.html"><strong aria-hidden="true">50.</strong> Advanced Memory Management</a></li><li class="chapter-item expanded "><a href="../chapters/51-edge-computing.html"><strong aria-hidden="true">51.</strong> Rust for Edge Computing</a></li><li class="chapter-item expanded "><a href="../chapters/52-security.html"><strong aria-hidden="true">52.</strong> Rust Security Patterns and Auditing</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="../appendices/a-idioms-patterns.html"><strong aria-hidden="true">53.</strong> Common Rust Idioms and Patterns</a></li><li class="chapter-item expanded "><a href="../appendices/b-rust-evolution.html"><strong aria-hidden="true">54.</strong> Rust's Evolution: Editions and Features</a></li><li class="chapter-item expanded "><a href="../appendices/c-language-comparison.html"><strong aria-hidden="true">55.</strong> Comparison with Other Languages</a></li><li class="chapter-item expanded "><a href="../appendices/d-recommended-libraries.html"><strong aria-hidden="true">56.</strong> Recommended Libraries and Crates</a></li><li class="chapter-item expanded "><a href="../appendices/e-memory-model.html"><strong aria-hidden="true">57.</strong> Rust's Memory Model In-Depth</a></li><li class="chapter-item expanded "><a href="../appendices/f-community-resources.html"><strong aria-hidden="true">58.</strong> Community Resources and Contribution Guide</a></li><li class="chapter-item expanded "><a href="../appendices/g-debugging.html"><strong aria-hidden="true">59.</strong> Debugging and Troubleshooting Guide</a></li><li class="chapter-item expanded "><a href="../appendices/h-optimization-cookbook.html"><strong aria-hidden="true">60.</strong> Performance Optimization Cookbook</a></li><li class="chapter-item expanded "><a href="../appendices/i-glossary.html"><strong aria-hidden="true">61.</strong> Comprehensive Glossary</a></li><li class="chapter-item expanded "><a href="../appendices/j-learning-paths.html"><strong aria-hidden="true">62.</strong> Learning Paths for Different Backgrounds</a></li><li class="chapter-item expanded "><a href="../appendices/k-interview-questions.html"><strong aria-hidden="true">63.</strong> Interview Questions and Answers</a></li><li class="chapter-item expanded "><a href="../appendices/l-resources.html"><strong aria-hidden="true">64.</strong> Recommended Reading and Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Universe: Fearless Systems Engineering</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/saeedalam/rust-universe" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/saeedalam/rust-universe/edit/main/src/chapters/30-web.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-30-web-development-with-rust"><a class="header" href="#chapter-30-web-development-with-rust">Chapter 30: Web Development with Rust</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Web development has traditionally been dominated by languages like JavaScript, Python, and Ruby, which prioritize developer productivity and ecosystem maturity over raw performance. However, as web applications grow in complexity and scale, the need for efficient, reliable, and secure systems has never been greater. Rust, with its focus on performance, memory safety, and concurrency without runtime overhead, offers a compelling alternative for modern web development.</p>
<p>In this chapter, we'll explore the rapidly evolving landscape of web development in Rust. We'll see how Rust's core strengths—zero-cost abstractions, memory safety without garbage collection, and fearless concurrency—translate into web applications that are not only fast and resource-efficient but also robust and secure.</p>
<p>The Rust web ecosystem has matured significantly in recent years. While it may not yet match the breadth of options available in more established web development languages, it offers a growing collection of high-quality libraries and frameworks that cover most web development needs. From high-performance HTTP servers and expressive API frameworks to reactive frontend libraries powered by WebAssembly, Rust provides tools for building full-stack web applications.</p>
<p>We'll start by examining the web development landscape in Rust, understanding where it excels and what challenges remain. Then, we'll dive into backend development with popular frameworks like Actix Web, Rocket, and Axum, exploring their different approaches to building web services. We'll cover RESTful API design, database integration with SQLx, authentication, middleware, and more.</p>
<p>For frontend development, we'll explore how Rust, compiled to WebAssembly, is opening new possibilities for building fast, reliable web interfaces with frameworks like Yew and Leptos. We'll also look at GraphQL implementation with async-graphql, WebSockets for real-time communication, and deployment strategies for Rust web applications.</p>
<p>Whether you're building a high-performance API, a real-time web application, or a full-stack system, this chapter will provide you with the knowledge to leverage Rust's strengths for web development. By the end, you'll understand how to build web applications that are not just fast and efficient, but also benefit from Rust's guarantees of safety and reliability.</p>
<h2 id="web-development-landscape-in-rust"><a class="header" href="#web-development-landscape-in-rust">Web Development Landscape in Rust</a></h2>
<p>The Rust web development ecosystem is diverse and rapidly evolving, with different tools and frameworks catering to various development styles and requirements. Before diving into specific frameworks, let's understand the overall landscape and where Rust fits into web development.</p>
<h3 id="rusts-strengths-for-web-development"><a class="header" href="#rusts-strengths-for-web-development">Rust's Strengths for Web Development</a></h3>
<p>Rust brings several unique advantages to web development:</p>
<ol>
<li>
<p><strong>Performance</strong>: Rust applications typically offer performance comparable to C and C++, with predictable resource usage and minimal overhead. This makes Rust ideal for high-throughput APIs and services where response time is critical.</p>
</li>
<li>
<p><strong>Memory Safety</strong>: Rust's ownership system eliminates entire classes of bugs like null pointer dereferencing, use-after-free, and data races—all without runtime overhead. For web applications handling sensitive data, this provides an additional layer of security.</p>
</li>
<li>
<p><strong>Concurrency</strong>: With its &quot;fearless concurrency&quot; model, Rust allows developers to build highly concurrent systems without the traditional pitfalls. This is particularly valuable for web servers handling thousands of simultaneous connections.</p>
</li>
<li>
<p><strong>Type Safety</strong>: Rust's strong type system catches many errors at compile time, reducing runtime surprises. This can be especially helpful when refactoring large codebases or evolving APIs.</p>
</li>
<li>
<p><strong>Cross-Platform</strong>: Rust code can run on various platforms, from cloud servers to WebAssembly in browsers, enabling code reuse between frontend and backend.</p>
</li>
</ol>
<h3 id="the-web-stack-in-rust"><a class="header" href="#the-web-stack-in-rust">The Web Stack in Rust</a></h3>
<p>The Rust web stack can be broadly divided into several layers:</p>
<h4 id="low-level-http-and-networking"><a class="header" href="#low-level-http-and-networking">Low-Level HTTP and Networking</a></h4>
<p>At the foundation, Rust offers libraries for handling HTTP and network protocols:</p>
<ul>
<li><strong>hyper</strong>: A fast, low-level HTTP implementation that powers many higher-level frameworks.</li>
<li><strong>tokio</strong>: An asynchronous runtime that provides the foundation for non-blocking I/O operations.</li>
<li><strong>mio</strong>: A low-level, cross-platform abstraction over OS network operations.</li>
</ul>
<h4 id="web-frameworks"><a class="header" href="#web-frameworks">Web Frameworks</a></h4>
<p>Built on top of these low-level components, several web frameworks offer different approaches to building web applications:</p>
<ul>
<li><strong>Actix Web</strong>: A high-performance, actor-based framework inspired by Erlang's actor model.</li>
<li><strong>Rocket</strong>: Focuses on developer experience with a focus on type safety and productivity.</li>
<li><strong>Axum</strong>: A modular framework built on top of tokio, with a focus on ergonomics and composability.</li>
<li><strong>warp</strong>: A lightweight, composable framework built around the concept of filters.</li>
<li><strong>tide</strong>: A minimal, middleware-focused framework for building async services.</li>
</ul>
<h4 id="database-connectivity"><a class="header" href="#database-connectivity">Database Connectivity</a></h4>
<p>For data persistence, Rust offers several options:</p>
<ul>
<li><strong>SQLx</strong>: A pure Rust SQL client with compile-time checked queries.</li>
<li><strong>Diesel</strong>: A powerful ORM and query builder for SQL databases.</li>
<li><strong>rust-postgres</strong>: A native PostgreSQL driver.</li>
<li><strong>mongodb</strong>: Official MongoDB driver for Rust.</li>
<li><strong>redis-rs</strong>: Redis client library.</li>
</ul>
<h4 id="frontend-development"><a class="header" href="#frontend-development">Frontend Development</a></h4>
<p>For client-side web development, Rust can compile to WebAssembly (Wasm):</p>
<ul>
<li><strong>Yew</strong>: A framework for creating multi-threaded frontend applications with WebAssembly.</li>
<li><strong>Leptos</strong>: A fine-grained reactive framework for building web interfaces.</li>
<li><strong>Dioxus</strong>: A portable, performant framework for building cross-platform user interfaces.</li>
<li><strong>Seed</strong>: A frontend framework for creating web applications with an Elm-like architecture.</li>
</ul>
<h4 id="api-development"><a class="header" href="#api-development">API Development</a></h4>
<p>For building APIs, Rust offers specialized tools:</p>
<ul>
<li><strong>async-graphql</strong>: A high-performance GraphQL server implementation.</li>
<li><strong>juniper</strong>: Another GraphQL server library for Rust.</li>
<li><strong>tonic</strong>: A gRPC implementation focused on high performance.</li>
</ul>
<h3 id="ecosystem-maturity-and-challenges"><a class="header" href="#ecosystem-maturity-and-challenges">Ecosystem Maturity and Challenges</a></h3>
<p>While the Rust web ecosystem is growing quickly, it's important to understand its current state and challenges:</p>
<h4 id="strengths"><a class="header" href="#strengths">Strengths</a></h4>
<ol>
<li><strong>Performance and Resource Efficiency</strong>: Rust web frameworks consistently rank among the fastest in industry benchmarks.</li>
<li><strong>Growing Community</strong>: The community is active and passionate, with regular releases and improvements.</li>
<li><strong>Strong Foundations</strong>: Core libraries like tokio and hyper are mature and battle-tested.</li>
<li><strong>Interoperability</strong>: Good integration with existing systems through FFI and WebAssembly.</li>
</ol>
<h4 id="challenges"><a class="header" href="#challenges">Challenges</a></h4>
<ol>
<li><strong>Learning Curve</strong>: Rust itself has a steeper learning curve than many web development languages.</li>
<li><strong>Ecosystem Breadth</strong>: While the core is solid, some specialized libraries may be less mature than equivalents in more established ecosystems.</li>
<li><strong>Compile Times</strong>: Rust's compile times can be longer than interpreted languages, affecting the development cycle.</li>
<li><strong>Hiring</strong>: Finding developers with Rust experience can be more challenging compared to more common web technologies.</li>
</ol>
<h3 id="when-to-choose-rust-for-web-development"><a class="header" href="#when-to-choose-rust-for-web-development">When to Choose Rust for Web Development</a></h3>
<p>Rust is particularly well-suited for certain types of web applications:</p>
<ol>
<li><strong>High-Performance Services</strong>: APIs and services where throughput and latency are critical.</li>
<li><strong>Resource-Constrained Environments</strong>: Applications that need to minimize memory usage or operate within strict resource limits.</li>
<li><strong>Security-Critical Applications</strong>: Systems handling sensitive data where memory safety bugs could be catastrophic.</li>
<li><strong>WebAssembly Applications</strong>: Web applications that need near-native performance in the browser.</li>
<li><strong>Long-Running Services</strong>: Systems that need to run for extended periods without memory leaks or degradation.</li>
</ol>
<p>Rust may not be the optimal choice for:</p>
<ul>
<li>Rapid prototyping where development speed is the primary concern</li>
<li>Small, simple web applications where the overhead of learning Rust may not be justified</li>
<li>Teams without the capacity to invest in learning a new language with a steep learning curve</li>
</ul>
<p>In the following sections, we'll explore each part of the Rust web stack in detail, starting with backend frameworks.</p>
<h2 id="backend-frameworks-overview"><a class="header" href="#backend-frameworks-overview">Backend Frameworks Overview</a></h2>
<p>Rust offers several mature backend frameworks, each with its own philosophy and approach to building web services. In this section, we'll explore the three most popular options: Actix Web, Rocket, and Axum.</p>
<h3 id="actix-web"><a class="header" href="#actix-web">Actix Web</a></h3>
<p>Actix Web is one of the most established and high-performance web frameworks in the Rust ecosystem. Originally built on the actor model (via the actix actor framework), it has evolved into a standalone web framework that consistently ranks among the fastest in various benchmarks.</p>
<h4 id="key-features"><a class="header" href="#key-features">Key Features</a></h4>
<ul>
<li><strong>Performance</strong>: Actix Web is designed for high performance and low overhead, making it suitable for high-traffic applications.</li>
<li><strong>Flexibility</strong>: Provides both high-level and low-level APIs to accommodate different development needs.</li>
<li><strong>Middleware System</strong>: Robust middleware system for cross-cutting concerns like logging, authentication, and compression.</li>
<li><strong>WebSocket Support</strong>: Built-in support for WebSocket connections.</li>
<li><strong>State Management</strong>: Easy-to-use application state sharing between handlers.</li>
</ul>
<h4 id="basic-example"><a class="header" href="#basic-example">Basic Example</a></h4>
<p>Here's a simple &quot;Hello, World!&quot; application with Actix Web:</p>
<pre><pre class="playground"><code class="language-rust">use actix_web::{web, App, HttpRequest, HttpServer, Responder};

async fn greet(req: HttpRequest) -&gt; impl Responder {
    let name = req.match_info().get(&quot;name&quot;).unwrap_or(&quot;World&quot;);
    format!(&quot;Hello, {}!&quot;, name)
}

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        App::new()
            .route(&quot;/&quot;, web::get().to(|| async { &quot;Hello, World!&quot; }))
            .route(&quot;/hello/{name}&quot;, web::get().to(greet))
    })
    .bind(&quot;127.0.0.1:8080&quot;)?
    .run()
    .await
}</code></pre></pre>
<h4 id="when-to-choose-actix-web"><a class="header" href="#when-to-choose-actix-web">When to Choose Actix Web</a></h4>
<p>Actix Web is well-suited for:</p>
<ul>
<li>Applications where performance is a primary concern</li>
<li>Large-scale services that need fine-grained control over their behavior</li>
<li>Teams with experience in Rust who value flexibility</li>
<li>Projects that need WebSocket support or real-time communication</li>
</ul>
<h3 id="rocket"><a class="header" href="#rocket">Rocket</a></h3>
<p>Rocket takes a different approach, prioritizing developer experience and type safety. It uses Rust's type system extensively to provide ergonomic APIs and catch errors at compile time rather than runtime.</p>
<h4 id="key-features-1"><a class="header" href="#key-features-1">Key Features</a></h4>
<ul>
<li><strong>Type Safety</strong>: Heavy use of Rust's type system to provide safety guarantees.</li>
<li><strong>Request Guards</strong>: Powerful abstraction for request validation and processing.</li>
<li><strong>Form Validation</strong>: Built-in form validation with custom error messages.</li>
<li><strong>Template Support</strong>: Integrated templating with multiple engines.</li>
<li><strong>Configuration</strong>: Environment-specific configuration with sensible defaults.</li>
</ul>
<h4 id="basic-example-1"><a class="header" href="#basic-example-1">Basic Example</a></h4>
<p>Here's a &quot;Hello, World!&quot; example with Rocket:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use] extern crate rocket;

#[get(&quot;/&quot;)]
fn index() -&gt; &amp;'static str {
    &quot;Hello, world!&quot;
}

#[get(&quot;/hello/&lt;name&gt;&quot;)]
fn hello(name: &amp;str) -&gt; String {
    format!(&quot;Hello, {}!&quot;, name)
}

#[launch]
fn rocket() -&gt; _ {
    rocket::build()
        .mount(&quot;/&quot;, routes![index, hello])
}
<span class="boring">}</span></code></pre></pre>
<h4 id="when-to-choose-rocket"><a class="header" href="#when-to-choose-rocket">When to Choose Rocket</a></h4>
<p>Rocket is particularly suitable for:</p>
<ul>
<li>Teams prioritizing developer experience and productivity</li>
<li>Applications where compile-time safety is highly valued</li>
<li>Projects where readability and maintainability are key concerns</li>
<li>Developers new to Rust who want a gentler learning curve for web development</li>
</ul>
<h3 id="axum"><a class="header" href="#axum">Axum</a></h3>
<p>Axum is a newer framework developed by the Tokio team, built on top of the tokio runtime and hyper HTTP implementation. It focuses on ergonomics, composability, and type safety.</p>
<h4 id="key-features-2"><a class="header" href="#key-features-2">Key Features</a></h4>
<ul>
<li><strong>Tower Integration</strong>: Built on top of the tower ecosystem for middleware composition.</li>
<li><strong>Handler Composition</strong>: Handlers can be composed using combinators.</li>
<li><strong>Type-Safe Routing</strong>: Routes are type-checked at compile time.</li>
<li><strong>Extractor System</strong>: Powerful extractors for processing request data.</li>
<li><strong>Minimal Dependencies</strong>: Lighter dependency footprint compared to some alternatives.</li>
</ul>
<h4 id="basic-example-2"><a class="header" href="#basic-example-2">Basic Example</a></h4>
<p>Here's a simple example using Axum:</p>
<pre><pre class="playground"><code class="language-rust">use axum::{
    routing::get,
    Router,
    extract::Path,
};

async fn hello_world() -&gt; &amp;'static str {
    &quot;Hello, World!&quot;
}

async fn hello_name(Path(name): Path&lt;String&gt;) -&gt; String {
    format!(&quot;Hello, {}!&quot;, name)
}

#[tokio::main]
async fn main() {
    let app = Router::new()
        .route(&quot;/&quot;, get(hello_world))
        .route(&quot;/hello/:name&quot;, get(hello_name));

    axum::Server::bind(&amp;&quot;0.0.0.0:3000&quot;.parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}</code></pre></pre>
<h4 id="when-to-choose-axum"><a class="header" href="#when-to-choose-axum">When to Choose Axum</a></h4>
<p>Axum is well-suited for:</p>
<ul>
<li>Projects already using tokio and hyper</li>
<li>Developers who appreciate functional programming patterns</li>
<li>Applications that need a lightweight, composable framework</li>
<li>Teams looking for a modern API design with minimal boilerplate</li>
</ul>
<h3 id="framework-comparison"><a class="header" href="#framework-comparison">Framework Comparison</a></h3>
<p>To help you choose the right framework for your project, here's a comparison of the three frameworks:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Actix Web</th><th>Rocket</th><th>Axum</th></tr></thead><tbody>
<tr><td>Performance</td><td>Excellent</td><td>Good</td><td>Very Good</td></tr>
<tr><td>Learning Curve</td><td>Moderate</td><td>Gentle</td><td>Moderate</td></tr>
<tr><td>API Style</td><td>Object-oriented</td><td>Attribute-based</td><td>Functional</td></tr>
<tr><td>Type Safety</td><td>Good</td><td>Excellent</td><td>Excellent</td></tr>
<tr><td>Maturity</td><td>High</td><td>High</td><td>Medium</td></tr>
<tr><td>Ecosystem</td><td>Large</td><td>Medium</td><td>Growing</td></tr>
<tr><td>Async Model</td><td>tokio</td><td>tokio (v0.5+)</td><td>tokio</td></tr>
<tr><td>Middleware</td><td>Rich</td><td>Limited</td><td>Composable</td></tr>
<tr><td>Community</td><td>Active</td><td>Active</td><td>Active</td></tr>
</tbody></table>
</div>
<p>The choice between these frameworks often comes down to your team's preferences, your project's requirements, and which programming style you find most natural. All three are capable options for building robust web services in Rust.</p>
<p>In the next section, we'll dive deeper into RESTful API design principles using these frameworks.</p>
<h2 id="restful-api-design"><a class="header" href="#restful-api-design">RESTful API Design</a></h2>
<p>Building well-designed RESTful APIs is a fundamental skill for backend web development. In this section, we'll explore how to design and implement RESTful APIs in Rust, focusing on best practices and patterns that leverage Rust's strengths.</p>
<h3 id="restful-principles-in-rust"><a class="header" href="#restful-principles-in-rust">RESTful Principles in Rust</a></h3>
<p>REST (Representational State Transfer) is an architectural style for designing networked applications. It relies on stateless, client-server communication, typically over HTTP, using standard operations like GET, POST, PUT, and DELETE.</p>
<p>Key principles of RESTful API design include:</p>
<ol>
<li><strong>Resource-Based</strong>: Structure your API around resources (nouns) rather than actions.</li>
<li><strong>Standard HTTP Methods</strong>: Use HTTP methods appropriately for different operations.</li>
<li><strong>Stateless</strong>: Each request contains all information needed to process it.</li>
<li><strong>Representation</strong>: Resources can have different representations (JSON, XML, etc.).</li>
<li><strong>HATEOAS (Hypertext As The Engine Of Application State)</strong>: Include links in responses to guide clients through the API.</li>
</ol>
<h3 id="designing-data-models-and-dtos"><a class="header" href="#designing-data-models-and-dtos">Designing Data Models and DTOs</a></h3>
<p>When building APIs in Rust, you'll typically define two types of structures:</p>
<ol>
<li><strong>Domain Models</strong>: Represent your core business entities and are used internally.</li>
<li><strong>Data Transfer Objects (DTOs)</strong>: Define the shape of data sent to and from your API.</li>
</ol>
<p>Here's an example of how you might define these in a Rust API:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Domain model
#[derive(Debug)]
struct User {
    id: Uuid,
    username: String,
    email: String,
    password_hash: String,
    created_at: DateTime&lt;Utc&gt;,
    updated_at: DateTime&lt;Utc&gt;,
}

// DTO for creating a new user
#[derive(Deserialize, Validate)]
struct CreateUserDto {
    #[validate(length(min = 3, max = 50))]
    username: String,

    #[validate(email)]
    email: String,

    #[validate(length(min = 8))]
    password: String,
}

// DTO for returning user data
#[derive(Serialize)]
struct UserResponseDto {
    id: String,
    username: String,
    email: String,
    created_at: String,
}

// Implementation to convert between model and DTO
impl From&lt;User&gt; for UserResponseDto {
    fn from(user: User) -&gt; Self {
        Self {
            id: user.id.to_string(),
            username: user.username,
            email: user.email,
            created_at: user.created_at.to_rfc3339(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This separation helps maintain a clear boundary between your internal representation and your API contract, making it easier to evolve your API without breaking changes to your internal code.</p>
<h3 id="implementing-crud-operations"><a class="header" href="#implementing-crud-operations">Implementing CRUD Operations</a></h3>
<p>Let's implement a basic CRUD (Create, Read, Update, Delete) API for a resource using Actix Web:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{web, HttpResponse, Responder};
use uuid::Uuid;

// Create a new user
async fn create_user(
    user_dto: web::Json&lt;CreateUserDto&gt;,
    data: web::Data&lt;AppState&gt;,
) -&gt; impl Responder {
    // Validate the DTO
    if let Err(errors) = user_dto.validate() {
        return HttpResponse::BadRequest().json(errors);
    }

    // Map DTO to domain model and save
    let new_user = User::new(
        user_dto.username.clone(),
        user_dto.email.clone(),
        &amp;user_dto.password,
    );

    match data.user_repository.save(&amp;new_user).await {
        Ok(_) =&gt; {
            let response = UserResponseDto::from(new_user);
            HttpResponse::Created().json(response)
        },
        Err(e) =&gt; HttpResponse::InternalServerError().body(e.to_string()),
    }
}

// Get a user by ID
async fn get_user(
    path: web::Path&lt;String&gt;,
    data: web::Data&lt;AppState&gt;,
) -&gt; impl Responder {
    let user_id = match Uuid::parse_str(&amp;path.into_inner()) {
        Ok(id) =&gt; id,
        Err(_) =&gt; return HttpResponse::BadRequest().body(&quot;Invalid user ID&quot;),
    };

    match data.user_repository.find_by_id(user_id).await {
        Ok(Some(user)) =&gt; {
            let response = UserResponseDto::from(user);
            HttpResponse::Ok().json(response)
        },
        Ok(None) =&gt; HttpResponse::NotFound().body(&quot;User not found&quot;),
        Err(e) =&gt; HttpResponse::InternalServerError().body(e.to_string()),
    }
}

// Update a user
async fn update_user(
    path: web::Path&lt;String&gt;,
    user_dto: web::Json&lt;UpdateUserDto&gt;,
    data: web::Data&lt;AppState&gt;,
) -&gt; impl Responder {
    // Implementation similar to create and get...
    HttpResponse::Ok().json(user_response)
}

// Delete a user
async fn delete_user(
    path: web::Path&lt;String&gt;,
    data: web::Data&lt;AppState&gt;,
) -&gt; impl Responder {
    // Implementation to delete the user...
    HttpResponse::NoContent().finish()
}

// Register routes
pub fn configure_routes(cfg: &amp;mut web::ServiceConfig) {
    cfg.service(
        web::scope(&quot;/api/users&quot;)
            .route(&quot;&quot;, web::post().to(create_user))
            .route(&quot;/{id}&quot;, web::get().to(get_user))
            .route(&quot;/{id}&quot;, web::put().to(update_user))
            .route(&quot;/{id}&quot;, web::delete().to(delete_user))
    );
}
<span class="boring">}</span></code></pre></pre>
<h3 id="request-validation"><a class="header" href="#request-validation">Request Validation</a></h3>
<p>Rust's type system provides a strong foundation for request validation. Libraries like <code>validator</code> can be used to add declarative validation to your DTOs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use validator::{Validate, ValidationErrors};

#[derive(Deserialize, Validate)]
struct CreateUserDto {
    #[validate(length(min = 3, message = &quot;Username must be at least 3 characters&quot;))]
    username: String,

    #[validate(email(message = &quot;Must provide a valid email address&quot;))]
    email: String,

    #[validate(length(min = 8, message = &quot;Password must be at least 8 characters&quot;))]
    password: String,
}
<span class="boring">}</span></code></pre></pre>
<p>For more complex validation logic, you can implement custom validators:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Validate for CreateUserDto {
    fn validate(&amp;self) -&gt; Result&lt;(), ValidationErrors&gt; {
        // Call the derive-generated validation
        let mut errors = match self.validate_fields() {
            Ok(_) =&gt; ValidationErrors::new(),
            Err(e) =&gt; e,
        };

        // Custom validation logic
        if self.username.contains(&amp;self.password) {
            errors.add(&quot;password&quot;, ValidationError::new(&quot;Password cannot contain username&quot;));
        }

        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p>Consistent error handling is crucial for a well-designed API. In Rust, you might create a custom error type that can be converted to appropriate HTTP responses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, thiserror::Error)]
enum ApiError {
    #[error(&quot;Resource not found&quot;)]
    NotFound,

    #[error(&quot;Validation error: {0}&quot;)]
    ValidationError(#[from] ValidationErrors),

    #[error(&quot;Database error: {0}&quot;)]
    DatabaseError(#[from] sqlx::Error),

    #[error(&quot;Unauthorized&quot;)]
    Unauthorized,

    #[error(&quot;Internal server error: {0}&quot;)]
    InternalError(String),
}

impl ResponseError for ApiError {
    fn status_code(&amp;self) -&gt; StatusCode {
        match self {
            ApiError::NotFound =&gt; StatusCode::NOT_FOUND,
            ApiError::ValidationError(_) =&gt; StatusCode::BAD_REQUEST,
            ApiError::DatabaseError(_) =&gt; StatusCode::INTERNAL_SERVER_ERROR,
            ApiError::Unauthorized =&gt; StatusCode::UNAUTHORIZED,
            ApiError::InternalError(_) =&gt; StatusCode::INTERNAL_SERVER_ERROR,
        }
    }

    fn error_response(&amp;self) -&gt; HttpResponse {
        let status = self.status_code();
        let error_message = self.to_string();

        HttpResponse::build(status)
            .json(json!({
                &quot;error&quot;: {
                    &quot;status&quot;: status.as_u16(),
                    &quot;message&quot;: error_message
                }
            }))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>With this approach, your handler functions can return <code>Result&lt;HttpResponse, ApiError&gt;</code>, and the framework will automatically convert errors to appropriate HTTP responses.</p>
<h3 id="content-negotiation"><a class="header" href="#content-negotiation">Content Negotiation</a></h3>
<p>RESTful APIs should support different representation formats based on client preferences. In Rust frameworks, you can handle content negotiation with middleware or response formatters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{http::header, HttpResponse, Responder};
use serde::Serialize;

enum ResponseFormat {
    Json,
    Xml,
}

impl ResponseFormat {
    fn from_accept_header(accept: Option&lt;&amp;header::HeaderValue&gt;) -&gt; Self {
        match accept {
            Some(value) if value.to_str().unwrap_or(&quot;&quot;).contains(&quot;application/xml&quot;) =&gt; Self::Xml,
            _ =&gt; Self::Json,
        }
    }
}

struct ApiResponse&lt;T: Serialize&gt; {
    data: T,
    format: ResponseFormat,
}

impl&lt;T: Serialize&gt; Responder for ApiResponse&lt;T&gt; {
    fn respond_to(self, req: &amp;HttpRequest) -&gt; HttpResponse {
        let format = ResponseFormat::from_accept_header(
            req.headers().get(header::ACCEPT)
        );

        match format {
            ResponseFormat::Json =&gt; HttpResponse::Ok()
                .content_type(&quot;application/json&quot;)
                .json(self.data),
            ResponseFormat::Xml =&gt; {
                // Convert to XML using a library like quick-xml
                let xml = quick_xml::se::to_string(&amp;self.data).unwrap_or_default();
                HttpResponse::Ok()
                    .content_type(&quot;application/xml&quot;)
                    .body(xml)
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="versioning-your-api"><a class="header" href="#versioning-your-api">Versioning Your API</a></h3>
<p>API versioning helps you evolve your API without breaking existing clients. There are several common approaches:</p>
<ol>
<li><strong>URL Versioning</strong>: Include the version in the URL path (<code>/api/v1/users</code>).</li>
<li><strong>Query Parameter Versioning</strong>: Use a query parameter (<code>/api/users?version=1</code>).</li>
<li><strong>Header Versioning</strong>: Use a custom HTTP header (<code>API-Version: 1</code>).</li>
<li><strong>Content Type Versioning</strong>: Include the version in the media type (<code>application/vnd.company.api.v1+json</code>).</li>
</ol>
<p>Here's an example of URL versioning with Actix Web:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Main app configuration
pub fn configure_app(cfg: &amp;mut web::ServiceConfig) {
    cfg.service(
        web::scope(&quot;/api&quot;)
            .service(web::scope(&quot;/v1&quot;).configure(v1::configure_routes))
            .service(web::scope(&quot;/v2&quot;).configure(v2::configure_routes))
    );
}

// Version 1 routes
mod v1 {
    pub fn configure_routes(cfg: &amp;mut web::ServiceConfig) {
        cfg.service(
            web::scope(&quot;/users&quot;)
                .route(&quot;&quot;, web::post().to(create_user_v1))
                .route(&quot;/{id}&quot;, web::get().to(get_user_v1))
                // ...
        );
    }
}

// Version 2 routes
mod v2 {
    pub fn configure_routes(cfg: &amp;mut web::ServiceConfig) {
        cfg.service(
            web::scope(&quot;/users&quot;)
                .route(&quot;&quot;, web::post().to(create_user_v2))
                .route(&quot;/{id}&quot;, web::get().to(get_user_v2))
                // ...
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="documentation-with-openapiswagger"><a class="header" href="#documentation-with-openapiswagger">Documentation with OpenAPI/Swagger</a></h3>
<p>Documenting your API is essential for developer adoption. The <code>utoipa</code> crate provides OpenAPI/Swagger integration for Rust web frameworks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use utoipa::{OpenApi, ToSchema};
use utoipa_swagger_ui::SwaggerUi;

#[derive(OpenApi)]
#[openapi(
    paths(
        create_user,
        get_user,
        update_user,
        delete_user
    ),
    components(
        schemas(CreateUserDto, UserResponseDto, ApiError)
    ),
    tags(
        (name = &quot;users&quot;, description = &quot;User management API&quot;)
    )
)]
struct ApiDoc;

#[utoipa::path(
    post,
    path = &quot;/api/users&quot;,
    request_body = CreateUserDto,
    responses(
        (status = 201, description = &quot;User created successfully&quot;, body = UserResponseDto),
        (status = 400, description = &quot;Validation error&quot;, body = ApiError),
        (status = 500, description = &quot;Internal server error&quot;, body = ApiError)
    ),
    tag = &quot;users&quot;
)]
async fn create_user(/* ... */) -&gt; impl Responder {
    // Implementation...
}

// Add Swagger UI to your app
HttpServer::new(|| {
    App::new()
        .service(
            SwaggerUi::new(&quot;/swagger-ui/{_:.*}&quot;)
                .url(&quot;/api-docs/openapi.json&quot;, ApiDoc::openapi())
        )
        .configure(configure_app)
})
<span class="boring">}</span></code></pre></pre>
<h3 id="best-practices-for-restful-apis-in-rust"><a class="header" href="#best-practices-for-restful-apis-in-rust">Best Practices for RESTful APIs in Rust</a></h3>
<ol>
<li><strong>Use the Type System</strong>: Leverage Rust's type system for validation and to prevent bugs.</li>
<li><strong>Apply the Repository Pattern</strong>: Separate your data access logic from your API handlers.</li>
<li><strong>Implement Proper Error Handling</strong>: Create a consistent error handling strategy.</li>
<li><strong>Use Middleware for Cross-Cutting Concerns</strong>: Apply middleware for logging, authentication, etc.</li>
<li><strong>Embrace Async/Await</strong>: Use Rust's async capabilities for non-blocking I/O operations.</li>
<li><strong>Test Your API</strong>: Write unit and integration tests for your endpoints.</li>
<li><strong>Document Your API</strong>: Provide clear documentation for your API consumers.</li>
<li><strong>Follow HTTP Semantics</strong>: Use appropriate status codes and methods.</li>
<li><strong>Apply Rate Limiting</strong>: Protect your API from abuse with rate limiting.</li>
<li><strong>Monitor Performance</strong>: Use metrics and logging to track API performance.</li>
</ol>
<p>In the next section, we'll explore how to integrate your Rust API with databases using SQLx.</p>
<h2 id="database-integration-with-sqlx"><a class="header" href="#database-integration-with-sqlx">Database Integration with SQLx</a></h2>
<p>A critical component of most web applications is the ability to store and retrieve data from a database. In Rust, SQLx has emerged as one of the most popular libraries for database interaction. SQLx is an async, pure Rust SQL crate featuring compile-time checked queries without a DSL.</p>
<h3 id="introduction-to-sqlx"><a class="header" href="#introduction-to-sqlx">Introduction to SQLx</a></h3>
<p>SQLx takes a unique approach to database interaction in Rust:</p>
<ul>
<li><strong>Compile-Time Checked Queries</strong>: SQLx can verify your SQL queries at compile time against your actual database schema.</li>
<li><strong>Async First</strong>: Built with async/await support from the ground up.</li>
<li><strong>Type-Safe</strong>: Results are mapped to Rust types, leveraging Rust's type system.</li>
<li><strong>Multiple Database Support</strong>: Works with PostgreSQL, MySQL, SQLite, and Microsoft SQL Server.</li>
<li><strong>No Runtime Reflection</strong>: Unlike traditional ORMs, SQLx doesn't rely on runtime reflection.</li>
</ul>
<p>Let's explore how to integrate SQLx into a Rust web application.</p>
<h3 id="setting-up-sqlx"><a class="header" href="#setting-up-sqlx">Setting Up SQLx</a></h3>
<p>First, add SQLx to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
sqlx = { version = &quot;0.7&quot;, features = [&quot;runtime-tokio-native-tls&quot;, &quot;postgres&quot;, &quot;uuid&quot;, &quot;time&quot;, &quot;json&quot;] }
</code></pre>
<p>The features you select depend on your specific needs:</p>
<ul>
<li><code>runtime-tokio-native-tls</code>: Uses Tokio for async runtime with native TLS.</li>
<li><code>postgres</code>: Support for PostgreSQL (alternatively, you can choose <code>mysql</code>, <code>sqlite</code>, or <code>mssql</code>).</li>
<li>Additional features for specific data types like <code>uuid</code>, <code>time</code>, and <code>json</code>.</li>
</ul>
<h3 id="creating-a-database-connection-pool"><a class="header" href="#creating-a-database-connection-pool">Creating a Database Connection Pool</a></h3>
<p>In a web application, it's important to use a connection pool to efficiently manage database connections:</p>
<pre><pre class="playground"><code class="language-rust">use sqlx::postgres::{PgPool, PgPoolOptions};
use std::time::Duration;

async fn create_pool(database_url: &amp;str) -&gt; Result&lt;PgPool, sqlx::Error&gt; {
    PgPoolOptions::new()
        .max_connections(5)
        .acquire_timeout(Duration::from_secs(3))
        .connect(database_url)
        .await
}

// In your application startup
#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    dotenv().ok();

    let database_url = std::env::var(&quot;DATABASE_URL&quot;)
        .expect(&quot;DATABASE_URL must be set&quot;);

    let pool = create_pool(&amp;database_url)
        .await
        .expect(&quot;Failed to create pool&quot;);

    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(pool.clone()))
            // Configure routes and other middleware
    })
    .bind(&quot;127.0.0.1:8080&quot;)?
    .run()
    .await
}</code></pre></pre>
<h3 id="defining-database-models"><a class="header" href="#defining-database-models">Defining Database Models</a></h3>
<p>With SQLx, you can map your database rows to Rust structs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sqlx::FromRow;
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, FromRow)]
struct User {
    id: Uuid,
    username: String,
    email: String,
    password_hash: String,
    created_at: DateTime&lt;Utc&gt;,
    updated_at: DateTime&lt;Utc&gt;,
}

#[derive(Debug, FromRow)]
struct Post {
    id: Uuid,
    title: String,
    content: String,
    user_id: Uuid,
    published: bool,
    created_at: DateTime&lt;Utc&gt;,
    updated_at: DateTime&lt;Utc&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>FromRow</code> trait enables automatic mapping from database rows to Rust structs.</p>
<h3 id="executing-queries"><a class="header" href="#executing-queries">Executing Queries</a></h3>
<p>SQLx provides several ways to execute queries:</p>
<h4 id="simple-queries"><a class="header" href="#simple-queries">Simple Queries</a></h4>
<p>For basic CRUD operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn find_user_by_id(pool: &amp;PgPool, id: Uuid) -&gt; Result&lt;Option&lt;User&gt;, sqlx::Error&gt; {
    sqlx::query_as::&lt;_, User&gt;(&quot;SELECT * FROM users WHERE id = $1&quot;)
        .bind(id)
        .fetch_optional(pool)
        .await
}

async fn create_user(
    pool: &amp;PgPool,
    username: &amp;str,
    email: &amp;str,
    password_hash: &amp;str,
) -&gt; Result&lt;User, sqlx::Error&gt; {
    let now = Utc::now();
    let id = Uuid::new_v4();

    sqlx::query_as::&lt;_, User&gt;(
        &quot;INSERT INTO users (id, username, email, password_hash, created_at, updated_at)
         VALUES ($1, $2, $3, $4, $5, $6)
         RETURNING *&quot;
    )
    .bind(id)
    .bind(username)
    .bind(email)
    .bind(password_hash)
    .bind(now)
    .bind(now)
    .fetch_one(pool)
    .await
}
<span class="boring">}</span></code></pre></pre>
<h4 id="compile-time-checked-queries"><a class="header" href="#compile-time-checked-queries">Compile-Time Checked Queries</a></h4>
<p>One of SQLx's standout features is compile-time query checking. Using the <code>query!</code> and <code>query_as!</code> macros, SQLx can verify your SQL against your actual database schema during compilation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn find_user_by_id(pool: &amp;PgPool, id: Uuid) -&gt; Result&lt;Option&lt;User&gt;, sqlx::Error&gt; {
    sqlx::query_as!(
        User,
        &quot;SELECT * FROM users WHERE id = $1&quot;,
        id
    )
    .fetch_optional(pool)
    .await
}
<span class="boring">}</span></code></pre></pre>
<p>For this to work, you need to set up the <code>DATABASE_URL</code> environment variable and enable the <code>offline</code> feature or run with the <code>sqlx-cli</code> prepare command.</p>
<h4 id="transactions"><a class="header" href="#transactions">Transactions</a></h4>
<p>For operations that require multiple queries to be executed atomically:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn create_post_with_tags(
    pool: &amp;PgPool,
    user_id: Uuid,
    title: &amp;str,
    content: &amp;str,
    tags: &amp;[String],
) -&gt; Result&lt;Post, sqlx::Error&gt; {
    let mut tx = pool.begin().await?;

    // Create the post
    let post = sqlx::query_as::&lt;_, Post&gt;(
        &quot;INSERT INTO posts (id, title, content, user_id, published, created_at, updated_at)
         VALUES ($1, $2, $3, $4, $5, $6, $7)
         RETURNING *&quot;
    )
    .bind(Uuid::new_v4())
    .bind(title)
    .bind(content)
    .bind(user_id)
    .bind(false) // not published initially
    .bind(Utc::now())
    .bind(Utc::now())
    .fetch_one(&amp;mut *tx)
    .await?;

    // Add tags
    for tag in tags {
        // First, ensure the tag exists
        let tag_id = sqlx::query_scalar::&lt;_, Uuid&gt;(
            &quot;INSERT INTO tags (name) VALUES ($1)
             ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
             RETURNING id&quot;
        )
        .bind(tag)
        .fetch_one(&amp;mut *tx)
        .await?;

        // Then, link the post to the tag
        sqlx::query(
            &quot;INSERT INTO post_tags (post_id, tag_id)
             VALUES ($1, $2)&quot;
        )
        .bind(post.id)
        .bind(tag_id)
        .execute(&amp;mut *tx)
        .await?;
    }

    // Commit the transaction
    tx.commit().await?;

    Ok(post)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="implementing-the-repository-pattern"><a class="header" href="#implementing-the-repository-pattern">Implementing the Repository Pattern</a></h3>
<p>The repository pattern provides a clean abstraction over your data access code. Here's how you might implement it with SQLx:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define the repository trait
#[async_trait]
trait UserRepository {
    async fn find_by_id(&amp;self, id: Uuid) -&gt; Result&lt;Option&lt;User&gt;, sqlx::Error&gt;;
    async fn find_by_email(&amp;self, email: &amp;str) -&gt; Result&lt;Option&lt;User&gt;, sqlx::Error&gt;;
    async fn create(&amp;self, user: NewUser) -&gt; Result&lt;User, sqlx::Error&gt;;
    async fn update(&amp;self, id: Uuid, user: UpdateUser) -&gt; Result&lt;Option&lt;User&gt;, sqlx::Error&gt;;
    async fn delete(&amp;self, id: Uuid) -&gt; Result&lt;bool, sqlx::Error&gt;;
}

// PostgreSQL implementation of the repository
struct PgUserRepository {
    pool: PgPool,
}

impl PgUserRepository {
    pub fn new(pool: PgPool) -&gt; Self {
        Self { pool }
    }
}

#[async_trait]
impl UserRepository for PgUserRepository {
    async fn find_by_id(&amp;self, id: Uuid) -&gt; Result&lt;Option&lt;User&gt;, sqlx::Error&gt; {
        sqlx::query_as!(
            User,
            &quot;SELECT * FROM users WHERE id = $1&quot;,
            id
        )
        .fetch_optional(&amp;self.pool)
        .await
    }

    async fn find_by_email(&amp;self, email: &amp;str) -&gt; Result&lt;Option&lt;User&gt;, sqlx::Error&gt; {
        sqlx::query_as!(
            User,
            &quot;SELECT * FROM users WHERE email = $1&quot;,
            email
        )
        .fetch_optional(&amp;self.pool)
        .await
    }

    async fn create(&amp;self, user: NewUser) -&gt; Result&lt;User, sqlx::Error&gt; {
        let now = Utc::now();
        let id = Uuid::new_v4();

        sqlx::query_as!(
            User,
            r#&quot;
            INSERT INTO users (id, username, email, password_hash, created_at, updated_at)
            VALUES ($1, $2, $3, $4, $5, $6)
            RETURNING *
            &quot;#,
            id,
            user.username,
            user.email,
            user.password_hash,
            now,
            now
        )
        .fetch_one(&amp;self.pool)
        .await
    }

    // Implement update and delete methods similarly
}
<span class="boring">}</span></code></pre></pre>
<p>Then use the repository in your API handlers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn get_user(
    path: web::Path&lt;String&gt;,
    repo: web::Data&lt;Arc&lt;dyn UserRepository&gt;&gt;,
) -&gt; impl Responder {
    let user_id = match Uuid::parse_str(&amp;path.into_inner()) {
        Ok(id) =&gt; id,
        Err(_) =&gt; return HttpResponse::BadRequest().body(&quot;Invalid user ID&quot;),
    };

    match repo.find_by_id(user_id).await {
        Ok(Some(user)) =&gt; {
            let response = UserResponseDto::from(user);
            HttpResponse::Ok().json(response)
        },
        Ok(None) =&gt; HttpResponse::NotFound().body(&quot;User not found&quot;),
        Err(e) =&gt; HttpResponse::InternalServerError().body(e.to_string()),
    }
}

// In your app configuration
let user_repository = Arc::new(PgUserRepository::new(pool.clone())) as Arc&lt;dyn UserRepository&gt;;

App::new()
    .app_data(web::Data::new(user_repository))
    // ...
<span class="boring">}</span></code></pre></pre>
<h3 id="migrations-with-sqlx"><a class="header" href="#migrations-with-sqlx">Migrations with SQLx</a></h3>
<p>SQLx provides a built-in migration system to manage database schema changes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sqlx::migrate::Migrator;
use std::path::Path;

// In your application startup
async fn run_migrations(pool: &amp;PgPool) -&gt; Result&lt;(), sqlx::Error&gt; {
    let migrations = Path::new(&quot;./migrations&quot;);
    Migrator::new(migrations)
        .await?
        .run(pool)
        .await
}
<span class="boring">}</span></code></pre></pre>
<p>You can create migrations using the SQLx CLI:</p>
<pre><code class="language-bash"># Install the CLI
cargo install sqlx-cli

# Create a new migration
sqlx migrate add create_users_table

# The above command creates a file like 'migrations/20230101120000_create_users_table.sql'
# Edit this file to add your SQL commands:

-- migrations/20230101120000_create_users_table.sql
CREATE TABLE users (
    id UUID PRIMARY KEY,
    username VARCHAR(255) NOT NULL UNIQUE,
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL
);
</code></pre>
<h3 id="testing-database-code"><a class="header" href="#testing-database-code">Testing Database Code</a></h3>
<p>Testing code that interacts with a database requires special consideration. Here are some approaches:</p>
<h4 id="integration-tests-with-a-test-database"><a class="header" href="#integration-tests-with-a-test-database">Integration Tests with a Test Database</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use dotenv::dotenv;
    use sqlx::postgres::PgPoolOptions;
    use std::env;

    async fn setup_test_db() -&gt; PgPool {
        dotenv().ok();

        let database_url = env::var(&quot;TEST_DATABASE_URL&quot;)
            .expect(&quot;TEST_DATABASE_URL must be set&quot;);

        let pool = PgPoolOptions::new()
            .max_connections(5)
            .connect(&amp;database_url)
            .await
            .expect(&quot;Failed to create pool&quot;);

        // Run migrations to ensure schema is up to date
        let migrations = Path::new(&quot;./migrations&quot;);
        Migrator::new(migrations)
            .await
            .expect(&quot;Failed to initialize migrator&quot;)
            .run(&amp;pool)
            .await
            .expect(&quot;Failed to run migrations&quot;);

        pool
    }

    #[actix_rt::test]
    async fn test_create_user() {
        let pool = setup_test_db().await;
        let repo = PgUserRepository::new(pool);

        let new_user = NewUser {
            username: &quot;test_user&quot;.to_string(),
            email: &quot;test@example.com&quot;.to_string(),
            password_hash: &quot;hashed_password&quot;.to_string(),
        };

        let user = repo.create(new_user).await.expect(&quot;Failed to create user&quot;);

        assert_eq!(user.username, &quot;test_user&quot;);
        assert_eq!(user.email, &quot;test@example.com&quot;);

        // Clean up
        repo.delete(user.id).await.expect(&quot;Failed to delete user&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="using-sqlxs-testing-features"><a class="header" href="#using-sqlxs-testing-features">Using SQLx's Testing Features</a></h4>
<p>SQLx provides features to make testing easier, like the ability to use transactions to automatically roll back changes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn test_with_transaction() {
    let pool = setup_test_db().await;

    // Start a transaction
    let mut tx = pool.begin().await.expect(&quot;Failed to start transaction&quot;);

    // Create a repository with the transaction
    let repo = PgUserRepository::new(tx.as_mut());

    // Test your code
    let new_user = NewUser { /* ... */ };
    let user = repo.create(new_user).await.expect(&quot;Failed to create user&quot;);

    assert_eq!(user.username, &quot;test_user&quot;);

    // The transaction will be rolled back when tx is dropped,
    // so no cleanup is necessary
}
<span class="boring">}</span></code></pre></pre>
<h3 id="best-practices-for-database-integration"><a class="header" href="#best-practices-for-database-integration">Best Practices for Database Integration</a></h3>
<ol>
<li><strong>Use Connection Pooling</strong>: Always use a connection pool to manage database connections efficiently.</li>
<li><strong>Implement the Repository Pattern</strong>: Separate database logic from business logic.</li>
<li><strong>Use Transactions</strong>: Wrap related operations in transactions to ensure data integrity.</li>
<li><strong>Leverage Compile-Time Checking</strong>: Use SQLx's <code>query!</code> and <code>query_as!</code> macros to catch SQL errors at compile time.</li>
<li><strong>Parameterize Queries</strong>: Always use parameters instead of string concatenation to prevent SQL injection.</li>
<li><strong>Manage Migrations</strong>: Use SQLx's migration system to track and apply schema changes.</li>
<li><strong>Test Database Code</strong>: Write integration tests for your database code.</li>
<li><strong>Handle Errors Gracefully</strong>: Implement proper error handling for database operations.</li>
<li><strong>Monitor Performance</strong>: Use logging and metrics to identify slow queries.</li>
<li><strong>Consider Security</strong>: Be careful with sensitive data and implement proper access controls.</li>
</ol>
<p>In the next section, we'll explore authentication and security in Rust web applications.</p>
<h2 id="authentication-and-security"><a class="header" href="#authentication-and-security">Authentication and Security</a></h2>
<p>Security is a critical aspect of web application development. In this section, we'll explore how to implement authentication, authorization, and other security measures in Rust web applications.</p>
<h3 id="authentication-fundamentals"><a class="header" href="#authentication-fundamentals">Authentication Fundamentals</a></h3>
<p>Authentication is the process of verifying the identity of a user. In web applications, common authentication methods include:</p>
<ol>
<li><strong>Username/Password Authentication</strong>: The most common method where users provide credentials.</li>
<li><strong>Token-Based Authentication</strong>: After successful login, the server issues a token (often a JWT) that the client includes in subsequent requests.</li>
<li><strong>OAuth 2.0</strong>: A protocol that allows users to grant limited access to their resources on one site to another site, without providing credentials.</li>
<li><strong>Multi-factor Authentication (MFA)</strong>: Requires additional verification beyond just a password.</li>
</ol>
<h3 id="implementing-password-based-authentication"><a class="header" href="#implementing-password-based-authentication">Implementing Password-Based Authentication</a></h3>
<p>Let's start with the basics of password-based authentication in Rust:</p>
<h4 id="secure-password-storage"><a class="header" href="#secure-password-storage">Secure Password Storage</a></h4>
<p>Never store passwords in plain text. Instead, use a cryptographic hashing function designed for passwords:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use argon2::{self, Config};
use rand::Rng;

fn hash_password(password: &amp;str) -&gt; Result&lt;String, argon2::Error&gt; {
    let salt = rand::thread_rng().gen::&lt;[u8; 32]&gt;();
    let config = Config::default();

    argon2::hash_encoded(password.as_bytes(), &amp;salt, &amp;config)
}

fn verify_password(hash: &amp;str, password: &amp;str) -&gt; Result&lt;bool, argon2::Error&gt; {
    argon2::verify_encoded(hash, password.as_bytes())
}

// Usage in user creation
async fn create_user(
    pool: &amp;PgPool,
    username: &amp;str,
    email: &amp;str,
    password: &amp;str,
) -&gt; Result&lt;User, ApiError&gt; {
    // Hash the password
    let password_hash = hash_password(password)
        .map_err(|_| ApiError::InternalError(&quot;Failed to hash password&quot;.to_string()))?;

    // Store the user with the hashed password
    // ...
}

// Usage in login
async fn login(
    pool: &amp;PgPool,
    email: &amp;str,
    password: &amp;str,
) -&gt; Result&lt;User, ApiError&gt; {
    // Find the user by email
    let user = sqlx::query_as!(
        User,
        &quot;SELECT * FROM users WHERE email = $1&quot;,
        email
    )
    .fetch_optional(pool)
    .await?
    .ok_or(ApiError::InvalidCredentials)?;

    // Verify the password
    let is_valid = verify_password(&amp;user.password_hash, password)
        .map_err(|_| ApiError::InternalError(&quot;Failed to verify password&quot;.to_string()))?;

    if !is_valid {
        return Err(ApiError::InvalidCredentials);
    }

    Ok(user)
}
<span class="boring">}</span></code></pre></pre>
<h4 id="token-based-authentication-with-jwt"><a class="header" href="#token-based-authentication-with-jwt">Token-Based Authentication with JWT</a></h4>
<p>JSON Web Tokens (JWT) are a popular mechanism for implementing token-based authentication:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::{Duration, Utc};
use jsonwebtoken::{encode, decode, Header, Validation, EncodingKey, DecodingKey};
use serde::{Serialize, Deserialize};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String,      // Subject (user ID)
    exp: usize,       // Expiration time
    iat: usize,       // Issued at
    role: String,     // User role
}

fn create_jwt(user_id: Uuid, role: &amp;str, secret: &amp;[u8]) -&gt; Result&lt;String, jsonwebtoken::errors::Error&gt; {
    let now = Utc::now();
    let expires_at = now + Duration::hours(24);

    let claims = Claims {
        sub: user_id.to_string(),
        exp: expires_at.timestamp() as usize,
        iat: now.timestamp() as usize,
        role: role.to_string(),
    };

    encode(
        &amp;Header::default(),
        &amp;claims,
        &amp;EncodingKey::from_secret(secret),
    )
}

fn validate_jwt(token: &amp;str, secret: &amp;[u8]) -&gt; Result&lt;Claims, jsonwebtoken::errors::Error&gt; {
    let validation = Validation::default();

    let token_data = decode::&lt;Claims&gt;(
        token,
        &amp;DecodingKey::from_secret(secret),
        &amp;validation,
    )?;

    Ok(token_data.claims)
}

// Login handler that issues a JWT
async fn login(
    form: web::Form&lt;LoginForm&gt;,
    data: web::Data&lt;AppState&gt;,
) -&gt; impl Responder {
    // Authenticate the user
    let user = match authenticate_user(&amp;data.pool, &amp;form.email, &amp;form.password).await {
        Ok(user) =&gt; user,
        Err(_) =&gt; return HttpResponse::Unauthorized().body(&quot;Invalid credentials&quot;),
    };

    // Create a JWT
    let token = match create_jwt(user.id, &amp;user.role, data.jwt_secret.as_bytes()) {
        Ok(token) =&gt; token,
        Err(_) =&gt; return HttpResponse::InternalServerError().body(&quot;Could not create token&quot;),
    };

    // Return the token
    HttpResponse::Ok().json(json!({ &quot;token&quot;: token }))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="implementing-authentication-middleware"><a class="header" href="#implementing-authentication-middleware">Implementing Authentication Middleware</a></h3>
<p>To protect routes, implement middleware that validates JWTs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{
    dev::ServiceRequest, dev::ServiceResponse, Error, HttpMessage,
    web, error::ErrorUnauthorized,
};
use actix_web_httpauth::extractors::bearer::{BearerAuth, Config};
use actix_web_httpauth::extractors::AuthenticationError;
use futures::future::{ready, Ready};

// Middleware factory
pub async fn auth_middleware(
    req: ServiceRequest,
    credentials: BearerAuth,
) -&gt; Result&lt;ServiceRequest, Error&gt; {
    // Extract the token
    let token = credentials.token();

    // Get the JWT secret from app data
    let app_state = req.app_data::&lt;web::Data&lt;AppState&gt;&gt;().unwrap();

    // Validate the token
    match validate_jwt(token, app_state.jwt_secret.as_bytes()) {
        Ok(claims) =&gt; {
            // Store the validated claims in request extensions for handlers to access
            req.extensions_mut().insert(claims);
            Ok(req)
        },
        Err(_) =&gt; {
            let config = req.app_data::&lt;Config&gt;().cloned().unwrap_or_default();
            Err(ErrorUnauthorized(AuthenticationError::from(config)))
        }
    }
}

// In your route configuration
App::new()
    .service(
        web::scope(&quot;/api&quot;)
            .service(
                web::scope(&quot;/public&quot;)
                    .route(&quot;/login&quot;, web::post().to(login))
                    // Other public routes
            )
            .service(
                web::scope(&quot;/private&quot;)
                    .wrap(HttpAuthentication::bearer(auth_middleware))
                    .route(&quot;/profile&quot;, web::get().to(get_profile))
                    // Other protected routes
            )
    )
<span class="boring">}</span></code></pre></pre>
<h3 id="role-based-authorization"><a class="header" href="#role-based-authorization">Role-Based Authorization</a></h3>
<p>Once a user is authenticated, you often need to check if they have the appropriate permissions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define roles
#[derive(Debug, PartialEq, Serialize, Deserialize)]
enum Role {
    User,
    Admin,
}

// Authorization middleware
fn check_admin(req: &amp;HttpRequest) -&gt; Result&lt;(), Error&gt; {
    // Get the claims from the request extensions
    if let Some(claims) = req.extensions().get::&lt;Claims&gt;() {
        if claims.role == &quot;admin&quot; {
            return Ok(());
        }
    }

    Err(ErrorForbidden(&quot;Insufficient permissions&quot;))
}

// Use in a handler
async fn admin_only(req: HttpRequest) -&gt; impl Responder {
    if let Err(e) = check_admin(&amp;req) {
        return e.into();
    }

    // Admin-only functionality
    HttpResponse::Ok().body(&quot;Admin area&quot;)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cors-configuration"><a class="header" href="#cors-configuration">CORS Configuration</a></h3>
<p>Cross-Origin Resource Sharing (CORS) is crucial when your API is accessed from different domains:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_cors::Cors;
use actix_web::http::header;

// In your app configuration
let cors = Cors::default()
    .allowed_origin(&quot;https://frontend.example.com&quot;)
    .allowed_methods(vec![&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;])
    .allowed_headers(vec![header::AUTHORIZATION, header::CONTENT_TYPE])
    .max_age(3600);

App::new()
    .wrap(cors)
    // ...
<span class="boring">}</span></code></pre></pre>
<h3 id="csrf-protection"><a class="header" href="#csrf-protection">CSRF Protection</a></h3>
<p>Cross-Site Request Forgery (CSRF) attacks can be mitigated using tokens:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_csrf::CsrfMiddleware;
use actix_session::Session;
use actix_web::cookie::Key;
use rand::Rng;

// Generate a CSRF key
let csrf_key = Key::generate();

// Create CSRF middleware
let csrf = CsrfMiddleware::new(csrf_key);

// In your app configuration
App::new()
    .wrap(csrf)
    // ...

// In a form handler
async fn render_form(session: Session) -&gt; impl Responder {
    // Get the CSRF token from the session
    let csrf_token = session.get::&lt;String&gt;(&quot;csrf-token&quot;).unwrap_or_else(|_| None);

    // Render the form with the token
    HttpResponse::Ok().body(format!(
        r#&quot;&lt;form method=&quot;post&quot;&gt;
            &lt;input type=&quot;hidden&quot; name=&quot;csrf-token&quot; value=&quot;{}&quot;&gt;
            &lt;!-- Other form fields --&gt;
            &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
        &lt;/form&gt;&quot;#,
        csrf_token.unwrap_or_default()
    ))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h3>
<p>Protect your API from abuse by implementing rate limiting:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::dev::{Service, ServiceRequest, ServiceResponse, Transform};
use futures::future::{ok, Ready};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::task::{Context, Poll};

// Simple in-memory rate limiter
struct RateLimiter {
    limits: Arc&lt;Mutex&lt;HashMap&lt;String, (usize, chrono::DateTime&lt;Utc&gt;)&gt;&gt;&gt;,
    max_requests: usize,
    window_secs: i64,
}

impl RateLimiter {
    fn new(max_requests: usize, window_secs: i64) -&gt; Self {
        Self {
            limits: Arc::new(Mutex::new(HashMap::new())),
            max_requests,
            window_secs,
        }
    }
}

impl&lt;S&gt; Transform&lt;S, ServiceRequest&gt; for RateLimiter
where
    S: Service&lt;ServiceRequest, Response = ServiceResponse, Error = Error&gt;,
    S::Future: 'static,
{
    type Response = ServiceResponse;
    type Error = Error;
    type Transform = RateLimiterMiddleware&lt;S&gt;;
    type InitError = ();
    type Future = Ready&lt;Result&lt;Self::Transform, Self::InitError&gt;&gt;;

    fn new_transform(&amp;self, service: S) -&gt; Self::Future {
        ok(RateLimiterMiddleware {
            service,
            limits: self.limits.clone(),
            max_requests: self.max_requests,
            window_secs: self.window_secs,
        })
    }
}

// Add to your app
App::new()
    .wrap(RateLimiter::new(100, 60)) // 100 requests per minute
    // ...
<span class="boring">}</span></code></pre></pre>
<h3 id="security-headers"><a class="header" href="#security-headers">Security Headers</a></h3>
<p>Add security headers to your responses to mitigate various attacks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::middleware::DefaultHeaders;

// In your app configuration
App::new()
    .wrap(
        DefaultHeaders::new()
            .add((&quot;X-Content-Type-Options&quot;, &quot;nosniff&quot;))
            .add((&quot;X-Frame-Options&quot;, &quot;DENY&quot;))
            .add((&quot;X-XSS-Protection&quot;, &quot;1; mode=block&quot;))
            .add((&quot;Strict-Transport-Security&quot;, &quot;max-age=31536000; includeSubDomains&quot;))
            .add((&quot;Referrer-Policy&quot;, &quot;strict-origin-when-cross-origin&quot;))
            .add((&quot;Content-Security-Policy&quot;, &quot;default-src 'self'&quot;))
    )
    // ...
<span class="boring">}</span></code></pre></pre>
<h3 id="secure-sessions"><a class="header" href="#secure-sessions">Secure Sessions</a></h3>
<p>For stateful applications, implement secure session management:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_session::{CookieSession, Session};
use actix_web::cookie::SameSite;

// In your app configuration
App::new()
    .wrap(
        CookieSession::signed(&amp;[0; 32]) // Use a proper key in production
            .secure(true)               // Only send over HTTPS
            .http_only(true)            // Not accessible via JavaScript
            .same_site(SameSite::Strict) // Prevent CSRF
            .max_age(3600)              // 1 hour expiration
    )
    // ...

// Using sessions in a handler
async fn handler(session: Session) -&gt; impl Responder {
    // Get a value from the session
    let user_id: Option&lt;String&gt; = session.get(&quot;user_id&quot;).unwrap_or(None);

    // Set a value in the session
    session.insert(&quot;user_id&quot;, &quot;12345&quot;).unwrap();

    // Clear the session
    session.purge();

    HttpResponse::Ok().finish()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="oauth-20-integration"><a class="header" href="#oauth-20-integration">OAuth 2.0 Integration</a></h3>
<p>For more complex authentication needs, integrate with OAuth 2.0 providers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use oauth2::{
    AuthUrl, ClientId, ClientSecret, RedirectUrl, Scope, TokenUrl,
    basic::BasicClient, AuthorizationCode, CsrfToken, TokenResponse,
};
use url::Url;

// Set up the OAuth client
fn create_oauth_client() -&gt; BasicClient {
    BasicClient::new(
        ClientId::new(&quot;client_id&quot;.to_string()),
        Some(ClientSecret::new(&quot;client_secret&quot;.to_string())),
        AuthUrl::new(&quot;https://provider.com/auth&quot;.to_string()).unwrap(),
        Some(TokenUrl::new(&quot;https://provider.com/token&quot;.to_string()).unwrap())
    )
    .set_redirect_uri(RedirectUrl::new(&quot;http://localhost:8080/auth/callback&quot;.to_string()).unwrap())
}

// Initiate OAuth flow
async fn start_oauth(session: Session) -&gt; impl Responder {
    let client = create_oauth_client();

    // Generate a CSRF token
    let (auth_url, csrf_token) = client
        .authorize_url(CsrfToken::new_random)
        .add_scope(Scope::new(&quot;email&quot;.to_string()))
        .add_scope(Scope::new(&quot;profile&quot;.to_string()))
        .url();

    // Store the CSRF token in the session
    session.insert(&quot;oauth_csrf&quot;, csrf_token.secret()).unwrap();

    // Redirect to the OAuth provider
    HttpResponse::Found()
        .header(header::LOCATION, auth_url.to_string())
        .finish()
}

// Handle the OAuth callback
async fn oauth_callback(
    query: web::Query&lt;HashMap&lt;String, String&gt;&gt;,
    session: Session,
) -&gt; impl Responder {
    // Get the authorization code
    let code = match query.get(&quot;code&quot;) {
        Some(code) =&gt; AuthorizationCode::new(code.to_string()),
        None =&gt; return HttpResponse::BadRequest().body(&quot;No code provided&quot;),
    };

    // Get the state (CSRF token)
    let state = match query.get(&quot;state&quot;) {
        Some(state) =&gt; state,
        None =&gt; return HttpResponse::BadRequest().body(&quot;No state provided&quot;),
    };

    // Verify the CSRF token
    let csrf = match session.get::&lt;String&gt;(&quot;oauth_csrf&quot;) {
        Ok(Some(csrf)) if csrf == state =&gt; csrf,
        _ =&gt; return HttpResponse::BadRequest().body(&quot;Invalid CSRF token&quot;),
    };

    // Exchange the authorization code for a token
    let client = create_oauth_client();
    let token_result = client
        .exchange_code(code)
        .request(oauth2::reqwest::async_http_client)
        .await;

    match token_result {
        Ok(token) =&gt; {
            // Process the token (e.g., fetch user info, create session)
            // ...

            HttpResponse::Found()
                .header(header::LOCATION, &quot;/dashboard&quot;)
                .finish()
        },
        Err(e) =&gt; HttpResponse::InternalServerError().body(format!(&quot;Error: {}&quot;, e)),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="best-practices-for-security"><a class="header" href="#best-practices-for-security">Best Practices for Security</a></h3>
<ol>
<li><strong>HTTPS Everywhere</strong>: Always use HTTPS in production, and consider redirecting HTTP to HTTPS.</li>
<li><strong>Proper Password Storage</strong>: Use strong hashing algorithms like Argon2 or bcrypt.</li>
<li><strong>Input Validation</strong>: Validate all user input on both client and server sides.</li>
<li><strong>Parameterized Queries</strong>: Use parameterized queries to prevent SQL injection.</li>
<li><strong>CSRF Protection</strong>: Implement CSRF tokens for state-changing operations.</li>
<li><strong>Security Headers</strong>: Add appropriate security headers to your responses.</li>
<li><strong>Rate Limiting</strong>: Protect endpoints from abuse, especially authentication endpoints.</li>
<li><strong>Principle of Least Privilege</strong>: Only grant the minimal permissions necessary.</li>
<li><strong>Regular Updates</strong>: Keep your dependencies up to date to address security vulnerabilities.</li>
<li><strong>Security Scanning</strong>: Use tools like <code>cargo-audit</code> to check for known vulnerabilities in your dependencies.</li>
</ol>
<h3 id="handling-sensitive-data"><a class="header" href="#handling-sensitive-data">Handling Sensitive Data</a></h3>
<p>When working with sensitive data, follow these additional guidelines:</p>
<ol>
<li><strong>Encryption at Rest</strong>: Encrypt sensitive data stored in your database.</li>
<li><strong>Secure Communication</strong>: Use TLS for all network communication.</li>
<li><strong>Minimal Data Retention</strong>: Only store necessary data, and delete what you don't need.</li>
<li><strong>Logging Considerations</strong>: Be careful not to log sensitive information like passwords or tokens.</li>
<li><strong>Environment Variables</strong>: Use environment variables for secrets, not hardcoded values.</li>
</ol>
<p>In the next section, we'll explore middleware and request handlers in Rust web frameworks.</p>
<h2 id="middleware-and-request-handlers"><a class="header" href="#middleware-and-request-handlers">Middleware and Request Handlers</a></h2>
<p>Middleware and request handlers are essential components of any web application. They allow you to intercept and process requests and responses, enabling features like logging, authentication, compression, and more. In this section, we'll explore how middleware works in Rust web frameworks and how to implement custom middleware.</p>
<h3 id="understanding-middleware-in-rust-web-frameworks"><a class="header" href="#understanding-middleware-in-rust-web-frameworks">Understanding Middleware in Rust Web Frameworks</a></h3>
<p>Middleware in Rust web frameworks follows a similar pattern to other languages, but with Rust's strong typing and ownership model providing additional safety guarantees. Middleware typically:</p>
<ol>
<li>Intercepts requests before they reach handlers</li>
<li>Can modify or process the request</li>
<li>Can short-circuit request processing</li>
<li>Can modify responses after handlers process them</li>
</ol>
<p>Let's look at how middleware is implemented in different Rust web frameworks.</p>
<h3 id="middleware-in-actix-web"><a class="header" href="#middleware-in-actix-web">Middleware in Actix Web</a></h3>
<p>Actix Web provides a robust middleware system based on the <code>Service</code> and <code>Transform</code> traits from the <code>tower-service</code> crate. This allows for powerful composition of middleware.</p>
<h4 id="built-in-middleware"><a class="header" href="#built-in-middleware">Built-in Middleware</a></h4>
<p>Actix Web includes several built-in middleware components:</p>
<pre><pre class="playground"><code class="language-rust">use actix_web::{
    middleware::{Logger, Compress, DefaultHeaders},
    App, HttpServer,
};

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    std::env::set_var(&quot;RUST_LOG&quot;, &quot;actix_web=info&quot;);
    env_logger::init();

    HttpServer::new(|| {
        App::new()
            // Logger middleware logs requests and responses
            .wrap(Logger::default())
            // Compress responses
            .wrap(Compress::default())
            // Add security headers
            .wrap(
                DefaultHeaders::new()
                    .add((&quot;X-Content-Type-Options&quot;, &quot;nosniff&quot;))
            )
            // Configure routes
            .service(/* ... */)
    })
    .bind(&quot;127.0.0.1:8080&quot;)?
    .run()
    .await
}</code></pre></pre>
<h4 id="creating-custom-middleware"><a class="header" href="#creating-custom-middleware">Creating Custom Middleware</a></h4>
<p>For more complex requirements, you can create custom middleware by implementing the <code>Service</code> and <code>Transform</code> traits:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{
    dev::{Service, ServiceRequest, ServiceResponse, Transform},
    Error,
};
use futures::future::{ok, Ready};
use futures::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

// Middleware for timing requests
pub struct RequestTimer;

impl&lt;S, B&gt; Transform&lt;S, ServiceRequest&gt; for RequestTimer
where
    S: Service&lt;ServiceRequest, Response = ServiceResponse&lt;B&gt;, Error = Error&gt;,
    S::Future: 'static,
    B: 'static,
{
    type Response = ServiceResponse&lt;B&gt;;
    type Error = Error;
    type Transform = RequestTimerMiddleware&lt;S&gt;;
    type InitError = ();
    type Future = Ready&lt;Result&lt;Self::Transform, Self::InitError&gt;&gt;;

    fn new_transform(&amp;self, service: S) -&gt; Self::Future {
        ok(RequestTimerMiddleware { service })
    }
}

pub struct RequestTimerMiddleware&lt;S&gt; {
    service: S,
}

impl&lt;S, B&gt; Service&lt;ServiceRequest&gt; for RequestTimerMiddleware&lt;S&gt;
where
    S: Service&lt;ServiceRequest, Response = ServiceResponse&lt;B&gt;, Error = Error&gt;,
    S::Future: 'static,
    B: 'static,
{
    type Response = ServiceResponse&lt;B&gt;;
    type Error = Error;
    type Future = Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;Self::Response, Self::Error&gt;&gt;&gt;&gt;;

    fn poll_ready(&amp;self, ctx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        self.service.poll_ready(ctx)
    }

    fn call(&amp;self, req: ServiceRequest) -&gt; Self::Future {
        let start = std::time::Instant::now();

        let fut = self.service.call(req);

        Box::pin(async move {
            let res = fut.await?;

            let duration = start.elapsed();
            println!(&quot;Request took {}ms&quot;, duration.as_millis());

            Ok(res)
        })
    }
}

// Add to your app
App::new()
    .wrap(RequestTimer)
    // ...
<span class="boring">}</span></code></pre></pre>
<h3 id="middleware-in-rocket"><a class="header" href="#middleware-in-rocket">Middleware in Rocket</a></h3>
<p>Rocket's approach to middleware is different from Actix Web's. Rocket uses &quot;Fairings&quot; for global request and response processing.</p>
<h4 id="using-fairings-in-rocket"><a class="header" href="#using-fairings-in-rocket">Using Fairings in Rocket</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rocket::{Request, Data, Response};
use rocket::fairing::{Fairing, Info, Kind};
use std::time::{Duration, Instant};

struct RequestTimer;

#[rocket::async_trait]
impl Fairing for RequestTimer {
    fn info(&amp;self) -&gt; Info {
        Info {
            name: &quot;Request Timer&quot;,
            kind: Kind::Request | Kind::Response,
        }
    }

    async fn on_request(&amp;self, request: &amp;mut Request&lt;'_&gt;, _: &amp;mut Data&lt;'_&gt;) {
        // Store the start time in request-local state
        request.local_cache(|| Instant::now());
    }

    async fn on_response&lt;'r&gt;(&amp;self, request: &amp;'r Request&lt;'_&gt;, response: &amp;mut Response&lt;'r&gt;) {
        let start_time = request.local_cache::&lt;Instant&gt;();
        let duration = start_time.elapsed();

        println!(&quot;Request to {} took {}ms&quot;, request.uri(), duration.as_millis());

        // Add timing header to response
        response.set_header(
            rocket::http::Header::new(
                &quot;X-Response-Time&quot;,
                format!(&quot;{}ms&quot;, duration.as_millis())
            )
        );
    }
}

// In your Rocket app
#[launch]
fn rocket() -&gt; _ {
    rocket::build()
        .attach(RequestTimer)
        // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="middleware-in-axum"><a class="header" href="#middleware-in-axum">Middleware in Axum</a></h3>
<p>Axum uses <code>tower::Layer</code> and <code>tower::Service</code> for middleware, making it highly composable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{
    Router,
    routing::get,
    middleware::{self, Next},
    response::IntoResponse,
    http::{Request, StatusCode},
};
use std::time::Instant;

// Simple request timing middleware
async fn track_time&lt;B&gt;(req: Request&lt;B&gt;, next: Next&lt;B&gt;) -&gt; impl IntoResponse {
    let start = Instant::now();

    // Pass the request to the next middleware or handler
    let response = next.run(req).await;

    // Record the time taken
    let duration = start.elapsed();
    println!(&quot;Request took {}ms&quot;, duration.as_millis());

    // Return the response
    response
}

// In your app
let app = Router::new()
    .route(&quot;/&quot;, get(|| async { &quot;Hello, World!&quot; }))
    .layer(middleware::from_fn(track_time));
<span class="boring">}</span></code></pre></pre>
<h3 id="request-handlers"><a class="header" href="#request-handlers">Request Handlers</a></h3>
<p>Request handlers are the functions that process specific routes in your web application. Let's look at how handlers work in different frameworks.</p>
<h4 id="handlers-in-actix-web"><a class="header" href="#handlers-in-actix-web">Handlers in Actix Web</a></h4>
<p>Actix Web handlers are async functions that take extractors as parameters and return types that implement the <code>Responder</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{web, HttpResponse, Responder, get, post};
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
struct CreateUserRequest {
    username: String,
    email: String,
}

#[derive(Serialize)]
struct UserResponse {
    id: String,
    username: String,
}

// Handler with path parameters
#[get(&quot;/users/{id}&quot;)]
async fn get_user(path: web::Path&lt;String&gt;) -&gt; impl Responder {
    let user_id = path.into_inner();
    // Fetch user from database...
    HttpResponse::Ok().json(UserResponse {
        id: user_id,
        username: &quot;johndoe&quot;.to_string(),
    })
}

// Handler with JSON body
#[post(&quot;/users&quot;)]
async fn create_user(user: web::Json&lt;CreateUserRequest&gt;) -&gt; impl Responder {
    // Create user in database...
    HttpResponse::Created().json(UserResponse {
        id: &quot;new-id&quot;.to_string(),
        username: user.username.clone(),
    })
}

// Handler with query parameters
async fn search_users(query: web::Query&lt;HashMap&lt;String, String&gt;&gt;) -&gt; impl Responder {
    let term = query.get(&quot;q&quot;).unwrap_or(&amp;&quot;&quot;.to_string());
    // Search users...
    HttpResponse::Ok().json(vec![
        UserResponse {
            id: &quot;1&quot;.to_string(),
            username: format!(&quot;Result for {}&quot;, term),
        }
    ])
}

// Handler with form data
async fn update_user_form(
    path: web::Path&lt;String&gt;,
    form: web::Form&lt;HashMap&lt;String, String&gt;&gt;,
) -&gt; impl Responder {
    // Update user...
    format!(&quot;Updated user {} to {}&quot;, path.into_inner(), form.username)
}
<span class="boring">}</span></code></pre></pre>
<h4 id="handlers-in-rocket"><a class="header" href="#handlers-in-rocket">Handlers in Rocket</a></h4>
<p>Rocket's handlers are annotated functions that can use various guards to extract data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rocket::serde::{Deserialize, Serialize, json::Json};
use rocket::form::Form;
use rocket::State;

#[derive(Deserialize)]
struct User {
    username: String,
    email: String,
}

#[derive(Serialize)]
struct UserResponse {
    id: String,
    username: String,
}

// Path parameters
#[get(&quot;/users/&lt;id&gt;&quot;)]
fn get_user(id: &amp;str) -&gt; Json&lt;UserResponse&gt; {
    // Fetch user from database...
    Json(UserResponse {
        id: id.to_string(),
        username: &quot;johndoe&quot;.to_string(),
    })
}

// JSON body
#[post(&quot;/users&quot;, data = &quot;&lt;user&gt;&quot;)]
fn create_user(user: Json&lt;User&gt;) -&gt; Json&lt;UserResponse&gt; {
    // Create user in database...
    Json(UserResponse {
        id: &quot;new-id&quot;.to_string(),
        username: user.username.clone(),
    })
}

// Query parameters
#[get(&quot;/users?&lt;q&gt;&quot;)]
fn search_users(q: Option&lt;&amp;str&gt;) -&gt; Json&lt;Vec&lt;UserResponse&gt;&gt; {
    let term = q.unwrap_or(&quot;&quot;);
    // Search users...
    Json(vec![
        UserResponse {
            id: &quot;1&quot;.to_string(),
            username: format!(&quot;Result for {}&quot;, term),
        }
    ])
}

// Form data
#[post(&quot;/users/&lt;id&gt;&quot;, data = &quot;&lt;form&gt;&quot;)]
fn update_user_form(id: &amp;str, form: Form&lt;User&gt;) -&gt; String {
    // Update user...
    format!(&quot;Updated user {} to {}&quot;, id, form.username)
}
<span class="boring">}</span></code></pre></pre>
<h4 id="handlers-in-axum"><a class="header" href="#handlers-in-axum">Handlers in Axum</a></h4>
<p>Axum handlers are async functions that use extractors to obtain data from requests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{
    extract::{Path, Query, Json, Form},
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Deserialize)]
struct User {
    username: String,
    email: String,
}

#[derive(Serialize)]
struct UserResponse {
    id: String,
    username: String,
}

// Path parameters
async fn get_user(Path(id): Path&lt;String&gt;) -&gt; Json&lt;UserResponse&gt; {
    // Fetch user from database...
    Json(UserResponse {
        id,
        username: &quot;johndoe&quot;.to_string(),
    })
}

// JSON body
async fn create_user(Json(user): Json&lt;User&gt;) -&gt; Json&lt;UserResponse&gt; {
    // Create user in database...
    Json(UserResponse {
        id: &quot;new-id&quot;.to_string(),
        username: user.username,
    })
}

// Query parameters
async fn search_users(Query(params): Query&lt;HashMap&lt;String, String&gt;&gt;) -&gt; Json&lt;Vec&lt;UserResponse&gt;&gt; {
    let term = params.get(&quot;q&quot;).unwrap_or(&amp;&quot;&quot;.to_string());
    // Search users...
    Json(vec![
        UserResponse {
            id: &quot;1&quot;.to_string(),
            username: format!(&quot;Result for {}&quot;, term),
        }
    ])
}

// Form data
async fn update_user_form(
    Path(id): Path&lt;String&gt;,
    Form(form): Form&lt;User&gt;,
) -&gt; String {
    // Update user...
    format!(&quot;Updated user {} to {}&quot;, id, form.username)
}

// Routing configuration
let app = Router::new()
    .route(&quot;/users/:id&quot;, get(get_user))
    .route(&quot;/users&quot;, post(create_user))
    .route(&quot;/users&quot;, get(search_users))
    .route(&quot;/users/:id&quot;, post(update_user_form));
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling-in-request-handlers"><a class="header" href="#error-handling-in-request-handlers">Error Handling in Request Handlers</a></h3>
<p>Proper error handling in request handlers is crucial for a robust API. Here's how you might handle errors in different frameworks:</p>
<h4 id="actix-web-error-handling"><a class="header" href="#actix-web-error-handling">Actix Web Error Handling</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{error, web, HttpResponse, Result};
use derive_more::{Display, Error};

#[derive(Debug, Display, Error)]
enum MyError {
    #[display(fmt = &quot;Internal error: {}&quot;, _0)]
    InternalError(String),

    #[display(fmt = &quot;Not found: {}&quot;, _0)]
    NotFound(String),

    #[display(fmt = &quot;Bad request: {}&quot;, _0)]
    BadRequest(String),
}

impl error::ResponseError for MyError {
    fn error_response(&amp;self) -&gt; HttpResponse {
        match *self {
            MyError::InternalError(_) =&gt; HttpResponse::InternalServerError().json(&quot;Internal server error&quot;),
            MyError::NotFound(ref message) =&gt; HttpResponse::NotFound().json(message),
            MyError::BadRequest(ref message) =&gt; HttpResponse::BadRequest().json(message),
        }
    }
}

async fn handler() -&gt; Result&lt;HttpResponse, MyError&gt; {
    // This might fail
    let result = do_something().map_err(|e| {
        MyError::InternalError(format!(&quot;Something went wrong: {}&quot;, e))
    })?;

    Ok(HttpResponse::Ok().json(result))
}
<span class="boring">}</span></code></pre></pre>
<h4 id="rocket-error-handling"><a class="header" href="#rocket-error-handling">Rocket Error Handling</a></h4>
<p>Rocket provides built-in support for common HTTP errors and allows you to implement the <code>Responder</code> trait for custom error types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rocket::response::{status, Responder};
use rocket::http::Status;
use rocket::serde::json::Json;
use serde::Serialize;
use thiserror::Error;

#[derive(Debug, Error)]
enum ApiError {
    #[error(&quot;Resource not found: {0}&quot;)]
    NotFound(String),

    #[error(&quot;Bad request: {0}&quot;)]
    BadRequest(String),

    #[error(&quot;Internal server error: {0}&quot;)]
    InternalError(String),
}

#[derive(Serialize)]
struct ErrorResponse {
    message: String,
}

impl&lt;'r&gt; Responder&lt;'r, 'static&gt; for ApiError {
    fn respond_to(self, _: &amp;'r rocket::Request&lt;'_&gt;) -&gt; rocket::response::Result&lt;'static&gt; {
        let error_message = self.to_string();
        let response = Json(ErrorResponse {
            message: error_message,
        });

        match self {
            ApiError::NotFound(_) =&gt; status::NotFound(response).respond_to(_),
            ApiError::BadRequest(_) =&gt; status::BadRequest(response).respond_to(_),
            ApiError::InternalError(_) =&gt; status::Custom(Status::InternalServerError, response).respond_to(_),
        }
    }
}

#[get(&quot;/users/&lt;id&gt;&quot;)]
fn get_user(id: &amp;str) -&gt; Result&lt;Json&lt;UserResponse&gt;, ApiError&gt; {
    // Fetch user from database
    let user = find_user(id).ok_or_else(|| {
        ApiError::NotFound(format!(&quot;User with id {} not found&quot;, id))
    })?;

    Ok(Json(user))
}
<span class="boring">}</span></code></pre></pre>
<h4 id="axum-error-handling"><a class="header" href="#axum-error-handling">Axum Error Handling</a></h4>
<p>Axum provides a flexible error handling system based on the <code>IntoResponse</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{
    response::{IntoResponse, Response},
    http::StatusCode,
    Json,
};
use serde_json::json;
use thiserror::Error;

#[derive(Error, Debug)]
enum AppError {
    #[error(&quot;Not found: {0}&quot;)]
    NotFound(String),

    #[error(&quot;Bad request: {0}&quot;)]
    BadRequest(String),

    #[error(&quot;Internal error: {0}&quot;)]
    InternalError(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -&gt; Response {
        let (status, error_message) = match self {
            AppError::NotFound(msg) =&gt; (StatusCode::NOT_FOUND, msg),
            AppError::BadRequest(msg) =&gt; (StatusCode::BAD_REQUEST, msg),
            AppError::InternalError(msg) =&gt; (StatusCode::INTERNAL_SERVER_ERROR, msg),
        };

        let body = Json(json!({
            &quot;error&quot;: {
                &quot;message&quot;: error_message,
                &quot;status&quot;: status.as_u16()
            }
        }));

        (status, body).into_response()
    }
}

async fn get_user(Path(id): Path&lt;String&gt;) -&gt; Result&lt;Json&lt;UserResponse&gt;, AppError&gt; {
    // Fetch user from database
    let user = find_user(&amp;id).ok_or_else(|| {
        AppError::NotFound(format!(&quot;User with id {} not found&quot;, id))
    })?;

    Ok(Json(user))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="best-practices-for-middleware-and-handlers"><a class="header" href="#best-practices-for-middleware-and-handlers">Best Practices for Middleware and Handlers</a></h3>
<ol>
<li><strong>Keep Middleware Focused</strong>: Each middleware should have a single responsibility.</li>
<li><strong>Use Middleware for Cross-Cutting Concerns</strong>: Logging, authentication, compression, etc.</li>
<li><strong>Separate Business Logic from Handlers</strong>: Keep handlers thin and move complex logic to service layers.</li>
<li><strong>Consistent Error Handling</strong>: Implement a unified error handling strategy.</li>
<li><strong>Use Type-Safe Extractors</strong>: Leverage Rust's type system to validate input data.</li>
<li><strong>Optimize Middleware Order</strong>: Place frequently short-circuiting middleware early in the chain.</li>
<li><strong>Handle Failures Gracefully</strong>: Provide meaningful error responses.</li>
<li><strong>Validate Input Data</strong>: Always validate user inputs before processing.</li>
<li><strong>Test Middleware and Handlers</strong>: Write unit and integration tests.</li>
<li><strong>Document Your API</strong>: Use tools like OpenAPI/Swagger for documentation.</li>
</ol>
<p>In the next section, we'll explore frontend development with WebAssembly and frameworks like Yew and Leptos.</p>
<h2 id="frontend-with-webassembly-and-yewleptos"><a class="header" href="#frontend-with-webassembly-and-yewleptos">Frontend with WebAssembly and Yew/Leptos</a></h2>
<p>While Rust has established itself as a powerful language for backend development, it's also making significant inroads into frontend development through WebAssembly (Wasm). In this section, we'll explore how to build web user interfaces using Rust with frameworks like Yew and Leptos.</p>
<h3 id="understanding-webassembly"><a class="header" href="#understanding-webassembly">Understanding WebAssembly</a></h3>
<p>WebAssembly is a binary instruction format that runs in web browsers, providing near-native performance for code written in languages like Rust, C++, and others. Key benefits include:</p>
<ol>
<li><strong>Performance</strong>: Wasm runs at near-native speed, significantly faster than JavaScript for CPU-intensive tasks.</li>
<li><strong>Language Agnostic</strong>: Allows using languages other than JavaScript in the browser.</li>
<li><strong>Security</strong>: Executes in a sandboxed environment with tight memory safety guarantees.</li>
<li><strong>Portability</strong>: Works across all modern browsers and platforms.</li>
</ol>
<p>For Rust developers, WebAssembly opens up the possibility to build complete web applications with Rust on both the frontend and backend.</p>
<h3 id="setting-up-a-rust-webassembly-project"><a class="header" href="#setting-up-a-rust-webassembly-project">Setting Up a Rust WebAssembly Project</a></h3>
<p>Let's start by setting up a basic Rust WebAssembly project:</p>
<pre><code class="language-bash"># Install wasm-pack, a tool for building Rust-generated WebAssembly
cargo install wasm-pack

# Create a new library for WebAssembly
cargo new --lib wasm-app
cd wasm-app

# Edit Cargo.toml to add necessary dependencies
</code></pre>
<p>Update your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;wasm-app&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]

[dependencies]
wasm-bindgen = &quot;0.2&quot;
js-sys = &quot;0.3&quot;
web-sys = { version = &quot;0.3&quot;, features = [
  &quot;console&quot;,
  &quot;Document&quot;,
  &quot;Element&quot;,
  &quot;HtmlElement&quot;,
  &quot;Window&quot;,
] }

[dev-dependencies]
wasm-bindgen-test = &quot;0.3&quot;
</code></pre>
<p>Create a simple WebAssembly module in <code>src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;

// Export a function to JavaScript
#[wasm_bindgen]
pub fn greet(name: &amp;str) -&gt; String {
    format!(&quot;Hello, {}!&quot;, name)
}

// Call JavaScript from Rust
#[wasm_bindgen]
pub fn display_alert(message: &amp;str) {
    // Get the window object
    let window = web_sys::window().expect(&quot;no global window exists&quot;);

    // Call the alert function
    window
        .alert_with_message(message)
        .expect(&quot;alert failed&quot;);
}

// DOM manipulation
#[wasm_bindgen(start)]
pub fn run() {
    // Log a message to the console
    web_sys::console::log_1(&amp;&quot;WebAssembly module loaded!&quot;.into());

    // Get the document
    let document = web_sys::window()
        .expect(&quot;no global window exists&quot;)
        .document()
        .expect(&quot;no document exists&quot;);

    // Create a new element
    let p = document
        .create_element(&quot;p&quot;)
        .expect(&quot;failed to create element&quot;);

    p.set_inner_html(&quot;This paragraph was created from Rust!&quot;);

    // Add the element to the document body
    let body = document.body().expect(&quot;document should have a body&quot;);
    body.append_child(&amp;p).expect(&quot;failed to append child&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Build the WebAssembly module:</p>
<pre><code class="language-bash">wasm-pack build --target web
</code></pre>
<p>This creates a <code>pkg</code> directory with JavaScript bindings for your Rust code. You can now use this in a web page:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;Rust WebAssembly Demo&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Rust WebAssembly Demo&lt;/h1&gt;
    &lt;button id=&quot;greet-button&quot;&gt;Greet&lt;/button&gt;

    &lt;script type=&quot;module&quot;&gt;
      import init, { greet, display_alert } from &quot;./pkg/wasm_app.js&quot;;

      async function run() {
        // Initialize the WebAssembly module
        await init();

        // Set up event listeners
        document
          .getElementById(&quot;greet-button&quot;)
          .addEventListener(&quot;click&quot;, () =&gt; {
            const result = greet(&quot;WebAssembly&quot;);
            display_alert(result);
          });
      }

      run();
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="introduction-to-yew"><a class="header" href="#introduction-to-yew">Introduction to Yew</a></h3>
<p>While the above example shows basic WebAssembly usage, building complex UIs this way would be tedious. This is where frameworks like Yew come in. Yew is a modern Rust framework for creating multi-threaded web applications with WebAssembly.</p>
<p>Yew provides:</p>
<ul>
<li>A component-based architecture similar to React</li>
<li>A virtual DOM implementation for efficient rendering</li>
<li>State management</li>
<li>Event handling</li>
<li>Routing capabilities</li>
</ul>
<p>Let's create a simple Yew application:</p>
<pre><code class="language-bash"># Create a new Yew project
cargo new --bin yew-app
cd yew-app
</code></pre>
<p>Update your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;yew-app&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
yew = { version = &quot;0.20&quot;, features = [&quot;csr&quot;] }
wasm-bindgen = &quot;0.2&quot;
web-sys = &quot;0.3&quot;
gloo = &quot;0.8&quot;
</code></pre>
<p>Create a simple Yew component in <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use yew::prelude::*;

#[function_component(App)]
fn app() -&gt; Html {
    let counter = use_state(|| 0);

    let onclick = {
        let counter = counter.clone();
        Callback::from(move |_| {
            let value = *counter + 1;
            counter.set(value);
        })
    };

    html! {
        &lt;div&gt;
            &lt;h1&gt;{ &quot;Yew Counter App&quot; }&lt;/h1&gt;
            &lt;p&gt;{ &quot;Current count: &quot; }{ *counter }&lt;/p&gt;
            &lt;button {onclick}&gt;{ &quot;Increment&quot; }&lt;/button&gt;
        &lt;/div&gt;
    }
}

fn main() {
    yew::Renderer::&lt;App&gt;::new().render();
}</code></pre></pre>
<p>Build and run the application:</p>
<pre><code class="language-bash">trunk serve  # You need to install trunk: cargo install trunk
</code></pre>
<h3 id="yew-component-lifecycle-and-state-management"><a class="header" href="#yew-component-lifecycle-and-state-management">Yew Component Lifecycle and State Management</a></h3>
<p>Yew provides hooks for managing component lifecycle and state, similar to React:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use yew::prelude::*;
use gloo::console::log;

#[function_component(ComplexApp)]
fn complex_app() -&gt; Html {
    // State hooks
    let counter = use_state(|| 0);
    let text = use_state(|| String::from(&quot;&quot;));

    // Ref hook
    let input_ref = use_node_ref();

    // Effect hook - runs on mount and when dependencies change
    use_effect_with_deps(
        move |counter| {
            log!(&quot;Counter changed to&quot;, *counter);
            // Cleanup function (similar to React useEffect return)
            || log!(&quot;Cleaning up effect&quot;)
        },
        counter.clone(),
    );

    // Event handlers
    let onclick = {
        let counter = counter.clone();
        Callback::from(move |_| {
            counter.set(*counter + 1);
        })
    };

    let oninput = {
        let text = text.clone();
        Callback::from(move |e: InputEvent| {
            let input: web_sys::HtmlInputElement = e.target_unchecked_into();
            text.set(input.value());
        })
    };

    let onsubmit = Callback::from(move |e: SubmitEvent| {
        e.prevent_default();
        log!(&quot;Form submitted&quot;);
    });

    html! {
        &lt;div&gt;
            &lt;h1&gt;{ &quot;Complex Yew App&quot; }&lt;/h1&gt;

            &lt;div&gt;
                &lt;p&gt;{ &quot;Counter: &quot; }{ *counter }&lt;/p&gt;
                &lt;button {onclick}&gt;{ &quot;Increment&quot; }&lt;/button&gt;
            &lt;/div&gt;

            &lt;form onsubmit={onsubmit}&gt;
                &lt;input
                    type=&quot;text&quot;
                    value={(*text).clone()}
                    oninput={oninput}
                    ref={input_ref.clone()}
                    placeholder=&quot;Type something...&quot;
                /&gt;
                &lt;p&gt;{ &quot;You typed: &quot; }{ (*text).clone() }&lt;/p&gt;
                &lt;button type=&quot;submit&quot;&gt;{ &quot;Submit&quot; }&lt;/button&gt;
            &lt;/form&gt;
        &lt;/div&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="building-a-todo-list-app-with-yew"><a class="header" href="#building-a-todo-list-app-with-yew">Building a Todo List App with Yew</a></h3>
<p>Let's create a more practical example - a Todo List application:</p>
<pre><pre class="playground"><code class="language-rust">use yew::prelude::*;
use gloo::storage::{LocalStorage, Storage};
use serde::{Deserialize, Serialize};

const STORAGE_KEY: &amp;str = &quot;yew.todo.list&quot;;

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Todo {
    id: usize,
    text: String,
    completed: bool,
}

#[function_component(TodoApp)]
fn todo_app() -&gt; Html {
    // Load todos from local storage or start with empty list
    let todos = use_state(|| {
        LocalStorage::get(STORAGE_KEY).unwrap_or_else(|_| Vec::&lt;Todo&gt;::new())
    });

    let next_id = use_state(|| {
        todos.iter().map(|todo| todo.id).max().unwrap_or(0) + 1
    });

    let new_todo_text = use_state(|| String::new());

    // Save todos to local storage whenever they change
    use_effect_with_deps(
        move |todos| {
            LocalStorage::set(STORAGE_KEY, todos.deref()).expect(&quot;failed to save todos&quot;);
            || ()
        },
        todos.clone(),
    );

    // Event handlers
    let oninput = {
        let new_todo_text = new_todo_text.clone();
        Callback::from(move |e: InputEvent| {
            let input: web_sys::HtmlInputElement = e.target_unchecked_into();
            new_todo_text.set(input.value());
        })
    };

    let onsubmit = {
        let todos = todos.clone();
        let new_todo_text = new_todo_text.clone();
        let next_id = next_id.clone();

        Callback::from(move |e: SubmitEvent| {
            e.prevent_default();

            let text = (*new_todo_text).trim();
            if !text.is_empty() {
                // Create new todo
                let mut updated_todos = (*todos).clone();
                updated_todos.push(Todo {
                    id: *next_id,
                    text: text.to_string(),
                    completed: false,
                });

                // Update state
                todos.set(updated_todos);
                next_id.set(*next_id + 1);
                new_todo_text.set(String::new());
            }
        })
    };

    let toggle_todo = {
        let todos = todos.clone();

        Callback::from(move |id: usize| {
            let mut updated_todos = (*todos).clone();
            if let Some(todo) = updated_todos.iter_mut().find(|t| t.id == id) {
                todo.completed = !todo.completed;
                todos.set(updated_todos);
            }
        })
    };

    let delete_todo = {
        let todos = todos.clone();

        Callback::from(move |id: usize| {
            let mut updated_todos = (*todos).clone();
            updated_todos.retain(|t| t.id != id);
            todos.set(updated_todos);
        })
    };

    html! {
        &lt;div class=&quot;todo-app&quot;&gt;
            &lt;h1&gt;{ &quot;Todo List&quot; }&lt;/h1&gt;

            &lt;form onsubmit={onsubmit}&gt;
                &lt;input
                    type=&quot;text&quot;
                    value={(*new_todo_text).clone()}
                    oninput={oninput}
                    placeholder=&quot;What needs to be done?&quot;
                /&gt;
                &lt;button type=&quot;submit&quot;&gt;{ &quot;Add&quot; }&lt;/button&gt;
            &lt;/form&gt;

            &lt;ul class=&quot;todo-list&quot;&gt;
                {
                    (*todos).iter().map(|todo| {
                        let id = todo.id;
                        let onclick_toggle = {
                            let toggle_todo = toggle_todo.clone();
                            Callback::from(move |_| toggle_todo.emit(id))
                        };

                        let onclick_delete = {
                            let delete_todo = delete_todo.clone();
                            Callback::from(move |_| delete_todo.emit(id))
                        };

                        html! {
                            &lt;li key={id} class={if todo.completed { &quot;completed&quot; } else { &quot;&quot; }}&gt;
                                &lt;input
                                    type=&quot;checkbox&quot;
                                    checked={todo.completed}
                                    onclick={onclick_toggle}
                                /&gt;
                                &lt;span&gt;{ &amp;todo.text }&lt;/span&gt;
                                &lt;button onclick={onclick_delete}&gt;{ &quot;Delete&quot; }&lt;/button&gt;
                            &lt;/li&gt;
                        }
                    }).collect::&lt;Html&gt;()
                }
            &lt;/ul&gt;

            &lt;div class=&quot;todo-count&quot;&gt;
                &lt;span&gt;{ format!(&quot;{} item(s) left&quot;, todos.iter().filter(|t| !t.completed).count()) }&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    }
}

fn main() {
    yew::Renderer::&lt;TodoApp&gt;::new().render();
}</code></pre></pre>
<h3 id="making-api-calls-with-yew"><a class="header" href="#making-api-calls-with-yew">Making API Calls with Yew</a></h3>
<p>Yew applications often need to communicate with backend APIs. Let's see how to make HTTP requests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use yew::prelude::*;
use gloo::net::http::Request;
use serde::{Deserialize, Serialize};
use wasm_bindgen_futures::spawn_local;

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
struct User {
    id: i32,
    name: String,
    email: String,
}

#[function_component(UserList)]
fn user_list() -&gt; Html {
    let users = use_state(|| Vec::&lt;User&gt;::new());
    let error = use_state(|| None::&lt;String&gt;);
    let is_loading = use_state(|| false);

    // Fetch users on component mount
    {
        let users = users.clone();
        let error = error.clone();
        let is_loading = is_loading.clone();

        use_effect_with_deps(
            move |_| {
                is_loading.set(true);

                spawn_local(async move {
                    match Request::get(&quot;https://api.example.com/users&quot;)
                        .send()
                        .await
                    {
                        Ok(response) =&gt; {
                            if response.status() == 200 {
                                match response.json::&lt;Vec&lt;User&gt;&gt;().await {
                                    Ok(data) =&gt; {
                                        users.set(data);
                                        error.set(None);
                                    }
                                    Err(e) =&gt; error.set(Some(format!(&quot;Error parsing JSON: {}&quot;, e))),
                                }
                            } else {
                                error.set(Some(format!(&quot;Error: {}&quot;, response.status())));
                            }
                        }
                        Err(e) =&gt; error.set(Some(format!(&quot;Request error: {}&quot;, e))),
                    }

                    is_loading.set(false);
                });

                || ()
            },
            (),
        );
    }

    html! {
        &lt;div&gt;
            &lt;h1&gt;{ &quot;User List&quot; }&lt;/h1&gt;

            if *is_loading {
                &lt;p&gt;{ &quot;Loading...&quot; }&lt;/p&gt;
            } else if let Some(err) = &amp;*error {
                &lt;p class=&quot;error&quot;&gt;{ err }&lt;/p&gt;
            } else if users.is_empty() {
                &lt;p&gt;{ &quot;No users found.&quot; }&lt;/p&gt;
            } else {
                &lt;ul&gt;
                    {
                        users.iter().map(|user| {
                            html! {
                                &lt;li key={user.id}&gt;
                                    &lt;strong&gt;{ &amp;user.name }&lt;/strong&gt;
                                    &lt;span&gt;{ format!(&quot; ({})&quot;, user.email) }&lt;/span&gt;
                                &lt;/li&gt;
                            }
                        }).collect::&lt;Html&gt;()
                    }
                &lt;/ul&gt;
            }
        &lt;/div&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="introduction-to-leptos"><a class="header" href="#introduction-to-leptos">Introduction to Leptos</a></h3>
<p>Leptos is a newer Rust framework for building web applications with a focus on fine-grained reactivity and minimal DOM updates. It offers a different approach compared to Yew, with inspiration from frameworks like Solid.js.</p>
<p>Key features of Leptos include:</p>
<ul>
<li>Fine-grained reactivity system</li>
<li>Server-side rendering</li>
<li>Seamless client-server integration</li>
<li>Small bundle size</li>
<li>Built-in error boundaries and suspense</li>
</ul>
<p>Let's create a simple Leptos application:</p>
<pre><code class="language-bash"># Create a new Leptos project
cargo new --bin leptos-app
cd leptos-app
</code></pre>
<p>Update your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;leptos-app&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
leptos = { version = &quot;0.4&quot;, features = [&quot;csr&quot;] }
wasm-bindgen = &quot;0.2&quot;
</code></pre>
<p>Create a simple Leptos component in <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

#[component]
fn App() -&gt; impl IntoView {
    let (count, set_count) = create_signal(0);

    let increment = move |_| set_count.update(|n| *n += 1);

    view! {
        &lt;div&gt;
            &lt;h1&gt;&quot;Leptos Counter App&quot;&lt;/h1&gt;
            &lt;p&gt;&quot;Current count: &quot; {count}&lt;/p&gt;
            &lt;button on:click=increment&gt;&quot;Increment&quot;&lt;/button&gt;
        &lt;/div&gt;
    }
}

fn main() {
    mount_to_body(App);
}</code></pre></pre>
<h3 id="reactivity-in-leptos"><a class="header" href="#reactivity-in-leptos">Reactivity in Leptos</a></h3>
<p>Leptos uses a fine-grained reactivity model where only the parts of the DOM that depend on changed values are updated:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use leptos::*;

#[component]
fn ReactiveExample() -&gt; impl IntoView {
    // Create signals for reactive state
    let (name, set_name) = create_signal(String::from(&quot;&quot;));
    let (count, set_count) = create_signal(0);

    // Derived computations
    let greeting = move || {
        if name().is_empty() {
            &quot;Please enter your name&quot;.to_string()
        } else {
            format!(&quot;Hello, {}!&quot;, name())
        }
    };

    // Only recalculates when count changes
    let count_squared = move || count() * count();

    // Event handlers
    let increment = move |_| set_count.update(|n| *n += 1);

    view! {
        &lt;div&gt;
            &lt;h1&gt;&quot;Reactivity Example&quot;&lt;/h1&gt;

            &lt;div&gt;
                &lt;label for=&quot;name-input&quot;&gt;&quot;Name: &quot;&lt;/label&gt;
                &lt;input
                    id=&quot;name-input&quot;
                    type=&quot;text&quot;
                    on:input=move |ev| {
                        set_name(event_target_value(&amp;ev));
                    }
                    prop:value=name
                /&gt;
                &lt;p&gt;{greeting}&lt;/p&gt;
            &lt;/div&gt;

            &lt;div&gt;
                &lt;p&gt;&quot;Count: &quot; {count}&lt;/p&gt;
                &lt;p&gt;&quot;Count squared: &quot; {count_squared}&lt;/p&gt;
                &lt;button on:click=increment&gt;&quot;Increment&quot;&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="building-a-todo-list-with-leptos"><a class="header" href="#building-a-todo-list-with-leptos">Building a Todo List with Leptos</a></h3>
<p>Let's recreate our Todo List application using Leptos:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
struct Todo {
    id: usize,
    text: String,
    completed: bool,
}

#[component]
fn TodoApp() -&gt; impl IntoView {
    // Load todos from local storage or start with empty list
    let storage_key = &quot;leptos.todo.list&quot;;

    let initial_todos: Vec&lt;Todo&gt; = web_sys::window()
        .and_then(|window| window.local_storage().ok())
        .flatten()
        .and_then(|storage| storage.get_item(storage_key).ok())
        .flatten()
        .and_then(|json| serde_json::from_str(&amp;json).ok())
        .unwrap_or_default();

    let (todos, set_todos) = create_signal(initial_todos);

    // Save todos to local storage whenever they change
    create_effect(move |_| {
        if let Ok(Some(storage)) = web_sys::window()
            .and_then(|window| Ok(window.local_storage().ok()?))
        {
            let json = serde_json::to_string(&amp;todos()).unwrap_or_default();
            let _ = storage.set_item(storage_key, &amp;json);
        }
    });

    let (new_todo_text, set_new_todo_text) = create_signal(String::new());

    let add_todo = move |ev: ev::SubmitEvent| {
        ev.prevent_default();

        let text = new_todo_text().trim().to_string();
        if !text.is_empty() {
            // Get the next ID
            let next_id = todos()
                .iter()
                .map(|todo| todo.id)
                .max()
                .unwrap_or(0) + 1;

            // Create new todo and add it to the list
            set_todos.update(|todos| {
                todos.push(Todo {
                    id: next_id,
                    text,
                    completed: false,
                });
            });

            // Clear the input
            set_new_todo_text(String::new());
        }
    };

    let toggle_todo = move |id: usize| {
        set_todos.update(|todos| {
            if let Some(todo) = todos.iter_mut().find(|t| t.id == id) {
                todo.completed = !todo.completed;
            }
        });
    };

    let delete_todo = move |id: usize| {
        set_todos.update(|todos| {
            todos.retain(|t| t.id != id);
        });
    };

    let remaining_count = move || todos().iter().filter(|t| !t.completed).count();

    view! {
        &lt;div class=&quot;todo-app&quot;&gt;
            &lt;h1&gt;&quot;Todo List&quot;&lt;/h1&gt;

            &lt;form on:submit=add_todo&gt;
                &lt;input
                    type=&quot;text&quot;
                    prop:value=new_todo_text
                    on:input=move |ev| set_new_todo_text(event_target_value(&amp;ev))
                    placeholder=&quot;What needs to be done?&quot;
                /&gt;
                &lt;button type=&quot;submit&quot;&gt;&quot;Add&quot;&lt;/button&gt;
            &lt;/form&gt;

            &lt;ul class=&quot;todo-list&quot;&gt;
                &lt;For
                    each=todos
                    key=|todo| todo.id
                    children=move |todo| {
                        let id = todo.id;
                        view! {
                            &lt;li class:completed=move || todo.completed&gt;
                                &lt;input
                                    type=&quot;checkbox&quot;
                                    prop:checked=move || todo.completed
                                    on:click=move |_| toggle_todo(id)
                                /&gt;
                                &lt;span&gt;{todo.text}&lt;/span&gt;
                                &lt;button on:click=move |_| delete_todo(id)&gt;&quot;Delete&quot;&lt;/button&gt;
                            &lt;/li&gt;
                        }
                    }
                /&gt;
            &lt;/ul&gt;

            &lt;div class=&quot;todo-count&quot;&gt;
                &lt;span&gt;{move || format!(&quot;{} item(s) left&quot;, remaining_count())}&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    }
}

fn main() {
    mount_to_body(TodoApp);
}</code></pre></pre>
<h3 id="server-side-rendering-with-leptos"><a class="header" href="#server-side-rendering-with-leptos">Server-Side Rendering with Leptos</a></h3>
<p>One of Leptos' standout features is its seamless server-side rendering (SSR) capabilities:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use leptos::*;
use leptos_router::*;

#[component]
fn App() -&gt; impl IntoView {
    view! {
        &lt;Router&gt;
            &lt;nav&gt;
                &lt;A href=&quot;/&quot;&gt;&quot;Home&quot;&lt;/A&gt;
                &lt;A href=&quot;/about&quot;&gt;&quot;About&quot;&lt;/A&gt;
                &lt;A href=&quot;/users&quot;&gt;&quot;Users&quot;&lt;/A&gt;
            &lt;/nav&gt;

            &lt;main&gt;
                &lt;Routes&gt;
                    &lt;Route path=&quot;/&quot; view=HomePage /&gt;
                    &lt;Route path=&quot;/about&quot; view=AboutPage /&gt;
                    &lt;Route path=&quot;/users&quot; view=UsersPage /&gt;
                    &lt;Route path=&quot;/users/:id&quot; view=UserDetail /&gt;
                &lt;/Routes&gt;
            &lt;/main&gt;
        &lt;/Router&gt;
    }
}

#[component]
fn HomePage() -&gt; impl IntoView {
    view! { &lt;h1&gt;&quot;Welcome to the Home Page&quot;&lt;/h1&gt; }
}

#[component]
fn AboutPage() -&gt; impl IntoView {
    view! { &lt;h1&gt;&quot;About Us&quot;&lt;/h1&gt; }
}

#[component]
fn UsersPage() -&gt; impl IntoView {
    // This could be a server function in SSR mode
    let users = create_resource(
        || (),
        |_| async { fetch_users().await }
    );

    view! {
        &lt;div&gt;
            &lt;h1&gt;&quot;Users&quot;&lt;/h1&gt;
            &lt;Suspense fallback=move || view! { &lt;p&gt;&quot;Loading...&quot;&lt;/p&gt; }&gt;
                {move || {
                    users.get().map(|users| {
                        match users {
                            Ok(list) =&gt; {
                                view! {
                                    &lt;ul&gt;
                                        &lt;For
                                            each=move || list.clone()
                                            key=|user| user.id
                                            children=move |user| {
                                                view! {
                                                    &lt;li&gt;
                                                        &lt;A href=format!(&quot;/users/{}&quot;, user.id)&gt;
                                                            {user.name}
                                                        &lt;/A&gt;
                                                    &lt;/li&gt;
                                                }
                                            }
                                        /&gt;
                                    &lt;/ul&gt;
                                }
                            }
                            Err(e) =&gt; view! { &lt;p&gt;&quot;Error loading users: &quot; {e.to_string()}&lt;/p&gt; }
                        }
                    })
                }}
            &lt;/Suspense&gt;
        &lt;/div&gt;
    }
}

#[component]
fn UserDetail() -&gt; impl IntoView {
    let params = use_params_map();
    let id = move || params.with(|p| p.get(&quot;id&quot;).cloned().unwrap_or_default());

    // This could be a server function in SSR mode
    let user = create_resource(
        id,
        |id| async move { fetch_user(id).await }
    );

    view! {
        &lt;div&gt;
            &lt;h1&gt;&quot;User Details&quot;&lt;/h1&gt;
            &lt;Suspense fallback=move || view! { &lt;p&gt;&quot;Loading user...&quot;&lt;/p&gt; }&gt;
                {move || {
                    user.get().map(|result| {
                        match result {
                            Ok(user) =&gt; {
                                view! {
                                    &lt;div&gt;
                                        &lt;h2&gt;{user.name}&lt;/h2&gt;
                                        &lt;p&gt;&quot;Email: &quot; {user.email}&lt;/p&gt;
                                        &lt;p&gt;&quot;ID: &quot; {user.id}&lt;/p&gt;
                                    &lt;/div&gt;
                                }
                            }
                            Err(e) =&gt; view! { &lt;p&gt;&quot;Error loading user: &quot; {e.to_string()}&lt;/p&gt; }
                        }
                    })
                }}
            &lt;/Suspense&gt;
            &lt;A href=&quot;/users&quot;&gt;&quot;Back to Users&quot;&lt;/A&gt;
        &lt;/div&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="comparing-yew-and-leptos"><a class="header" href="#comparing-yew-and-leptos">Comparing Yew and Leptos</a></h3>
<p>Both Yew and Leptos are powerful frameworks for building web applications with Rust, but they have different approaches:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Yew</th><th>Leptos</th></tr></thead><tbody>
<tr><td>Programming Model</td><td>Virtual DOM (like React)</td><td>Fine-grained reactivity (like Solid.js)</td></tr>
<tr><td>Rendering Strategy</td><td>Diff and patch</td><td>Precise DOM updates</td></tr>
<tr><td>Server-Side Rendering</td><td>Limited</td><td>First-class support</td></tr>
<tr><td>Bundle Size</td><td>Larger</td><td>Smaller</td></tr>
<tr><td>Learning Curve</td><td>Familiar for React developers</td><td>New reactivity concepts to learn</td></tr>
<tr><td>Community Size</td><td>Larger, more established</td><td>Growing</td></tr>
<tr><td>Performance</td><td>Good</td><td>Excellent for complex UIs</td></tr>
<tr><td>Hydration</td><td>Component-based</td><td>Fine-grained</td></tr>
</tbody></table>
</div>
<p>The choice between Yew and Leptos often depends on your specific requirements and preferences:</p>
<ul>
<li>Choose <strong>Yew</strong> if you're familiar with React and want a more established ecosystem.</li>
<li>Choose <strong>Leptos</strong> if you value performance, server-side rendering, and are willing to learn a new reactivity model.</li>
</ul>
<h3 id="best-practices-for-rust-webassembly-development"><a class="header" href="#best-practices-for-rust-webassembly-development">Best Practices for Rust WebAssembly Development</a></h3>
<ol>
<li><strong>Bundle Size Optimization</strong>: WebAssembly modules can be large, so use tools like <code>wasm-opt</code> to optimize size.</li>
<li><strong>Interoperability</strong>: Design your Rust-WebAssembly boundary carefully to minimize serialization overhead.</li>
<li><strong>Memory Management</strong>: Be aware of WebAssembly's linear memory model and how it affects your application.</li>
<li><strong>Performance Profiling</strong>: Use browser developer tools to profile your WebAssembly code.</li>
<li><strong>Progressive Enhancement</strong>: Consider using Rust for performance-critical parts while keeping basic functionality in JavaScript.</li>
<li><strong>Error Handling</strong>: Implement proper error handling across the Rust-JavaScript boundary.</li>
<li><strong>Testing</strong>: Write tests for both Rust code and the JavaScript integration.</li>
<li><strong>Loading States</strong>: Always handle loading states for asynchronous operations.</li>
<li><strong>Accessibility</strong>: Ensure your UI components are accessible.</li>
<li><strong>Browser Compatibility</strong>: Test across different browsers as WebAssembly support may vary.</li>
</ol>
<p>In the next section, we'll explore GraphQL in Rust with async-graphql.</p>
<h2 id="graphql-implementation-with-async-graphql"><a class="header" href="#graphql-implementation-with-async-graphql">GraphQL Implementation with async-graphql</a></h2>
<p>GraphQL has become a popular alternative to REST for building flexible APIs. In this section, we'll explore how to implement GraphQL servers in Rust using the async-graphql library.</p>
<h3 id="introduction-to-graphql-in-rust"><a class="header" href="#introduction-to-graphql-in-rust">Introduction to GraphQL in Rust</a></h3>
<p>GraphQL is a query language for your API that allows clients to request exactly the data they need. Unlike REST, which exposes a fixed set of endpoints with predetermined data structures, GraphQL provides a more flexible approach where clients can specify the structure of the response.</p>
<p>The <code>async-graphql</code> crate is a high-performance GraphQL implementation for Rust that integrates well with async runtimes and web frameworks. It provides:</p>
<ul>
<li>Type-safe schema definitions using Rust's type system</li>
<li>Support for queries, mutations, and subscriptions</li>
<li>Integration with common web frameworks like Actix Web, Warp, and Axum</li>
<li>Built-in validation, error handling, and introspection</li>
<li>Powerful features like dataloaders for efficient data fetching</li>
</ul>
<h3 id="defining-a-graphql-schema"><a class="header" href="#defining-a-graphql-schema">Defining a GraphQL Schema</a></h3>
<p>In async-graphql, you define your schema by creating Rust types and implementing resolvers for them. Here's a basic example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::{Context, Object, Schema, EmptyMutation, EmptySubscription, Result};

// Define a data structure
struct User {
    id: String,
    name: String,
    email: String,
}

// Define your queries
struct Query;

#[Object]
impl Query {
    async fn user(&amp;self, ctx: &amp;Context&lt;'_&gt;, id: String) -&gt; Result&lt;User&gt; {
        // In a real application, you would fetch this from a database
        Ok(User {
            id,
            name: &quot;John Doe&quot;.to_string(),
            email: &quot;john@example.com&quot;.to_string(),
        })
    }

    async fn users(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Result&lt;Vec&lt;User&gt;&gt; {
        // Return a list of users
        Ok(vec![
            User {
                id: &quot;1&quot;.to_string(),
                name: &quot;John Doe&quot;.to_string(),
                email: &quot;john@example.com&quot;.to_string(),
            },
            User {
                id: &quot;2&quot;.to_string(),
                name: &quot;Jane Doe&quot;.to_string(),
                email: &quot;jane@example.com&quot;.to_string(),
            },
        ])
    }
}

// Define your mutations
struct Mutation;

#[Object]
impl Mutation {
    async fn create_user(&amp;self, ctx: &amp;Context&lt;'_&gt;, id: String, name: String, email: String) -&gt; Result&lt;User&gt; {
        // In a real application, you would save this to a database
        // and handle validation, error cases, etc.
        let new_user = User { id, name, email };
        Ok(new_user)
    }
}

// Define your subscriptions
struct Subscription;

#[Subscription]
impl Subscription {
    async fn user_updated(&amp;self, ctx: &amp;Context&lt;'_&gt;, id: String) -&gt; impl Stream&lt;Item = Result&lt;User&gt;&gt; {
        // In a real application, you would subscribe to a message broker
        // or other event source

        let mut interval = tokio::time::interval(Duration::from_secs(5));

        async_stream::stream! {
            loop {
                interval.tick().await;

                let updated_user = User {
                    id: &quot;1&quot;.to_string(),
                    name: format!(&quot;John Doe {}&quot;, chrono::Utc::now()),
                    email: &quot;john@example.com&quot;.to_string(),
                };

                yield Ok(updated_user);
            }
        }
    }
}

// Build the schema
let schema = Schema::new(Query, Mutation, Subscription);
<span class="boring">}</span></code></pre></pre>
<h3 id="adding-mutations"><a class="header" href="#adding-mutations">Adding Mutations</a></h3>
<p>Mutations allow clients to modify data. Here's how to implement them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Mutation;

#[Object]
impl Mutation {
    async fn create_user(&amp;self, ctx: &amp;Context&lt;'_&gt;, id: String, name: String, email: String) -&gt; Result&lt;User&gt; {
        // In a real application, you would save this to a database
        // and handle validation, error cases, etc.
        let new_user = User { id, name, email };
        Ok(new_user)
    }

    async fn update_user(&amp;self, ctx: &amp;Context&lt;'_&gt;, id: String, name: Option&lt;String&gt;, email: Option&lt;String&gt;) -&gt; Result&lt;User&gt; {
        // Fetch existing user, update fields, save to database...

        Ok(User {
            id,
            name: name.unwrap_or_else(|| &quot;John Doe&quot;.to_string()),
            email: email.unwrap_or_else(|| &quot;john@example.com&quot;.to_string()),
        })
    }

    async fn delete_user(&amp;self, ctx: &amp;Context&lt;'_&gt;, id: String) -&gt; Result&lt;bool&gt; {
        // Delete user from database...

        Ok(true) // Return true if deletion was successful
    }
}

// Create a schema with query and mutation capabilities
let schema = Schema::build(Query::default(), Mutation::default(), Subscription::default())
    .finish();
<span class="boring">}</span></code></pre></pre>
<h3 id="implementing-subscriptions"><a class="header" href="#implementing-subscriptions">Implementing Subscriptions</a></h3>
<p>Subscriptions allow clients to receive real-time updates. They're implemented using Rust's async streams:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::{Context, Subscription, Schema, EmptyMutation, Result};
use async_stream::stream;
use futures_util::Stream;
use std::time::Duration;

#[derive(Default)]
struct Subscription;

#[Subscription]
impl Subscription {
    async fn countdown(&amp;self, from: i32) -&gt; impl Stream&lt;Item = Result&lt;i32&gt;&gt; {
        let mut current = from;
        stream! {
            while current &gt; 0 {
                tokio::time::sleep(Duration::from_secs(1)).await;
                yield Ok(current);
                current -= 1;
            }
        }
    }

    async fn user_updates(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; impl Stream&lt;Item = Result&lt;User&gt;&gt; {
        // In a real application, you would subscribe to a message broker
        // or other event source

        stream! {
            let mut interval = tokio::time::interval(Duration::from_secs(5));

            loop {
                interval.tick().await;

                let updated_user = User {
                    id: &quot;1&quot;.to_string(),
                    name: format!(&quot;John Doe {}&quot;, chrono::Utc::now()),
                    email: &quot;john@example.com&quot;.to_string(),
                };

                yield Ok(updated_user);
            }
        }
    }
}

// Create a schema with query, mutation, and subscription capabilities
let schema = Schema::build(Query::default(), Mutation::default(), Subscription::default())
    .finish();
<span class="boring">}</span></code></pre></pre>
<h3 id="integrating-with-web-frameworks"><a class="header" href="#integrating-with-web-frameworks">Integrating with Web Frameworks</a></h3>
<p>async-graphql integrates with popular Rust web frameworks. Here's an example with Actix Web:</p>
<pre><pre class="playground"><code class="language-rust">use actix_web::{web, App, HttpResponse, HttpServer, Result};
use async_graphql::http::{playground_source, GraphQLPlaygroundConfig};
use async_graphql_actix_web::{GraphQLRequest, GraphQLResponse, GraphQLSubscription};

// Handler for GraphQL queries and mutations
async fn graphql_handler(
    schema: web::Data&lt;AppSchema&gt;,
    req: GraphQLRequest,
) -&gt; GraphQLResponse {
    schema.execute(req.into_inner()).await.into()
}

// Handler for GraphQL subscriptions via WebSocket
async fn graphql_subscription(
    schema: web::Data&lt;AppSchema&gt;,
    req: HttpRequest,
    payload: web::Payload,
) -&gt; Result&lt;HttpResponse&gt; {
    GraphQLSubscription::new(Schema::clone(&amp;*schema))
        .start(&amp;req, payload)
}

// Handler for GraphQL Playground (web UI for testing GraphQL)
async fn graphql_playground() -&gt; HttpResponse {
    HttpResponse::Ok()
        .content_type(&quot;text/html; charset=utf-8&quot;)
        .body(playground_source(
            GraphQLPlaygroundConfig::new(&quot;/graphql&quot;)
                .subscription_endpoint(&quot;/graphql_ws&quot;),
        ))
}

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    // Build your schema
    let schema = Schema::build(Query::default(), Mutation::default(), Subscription::default())
        .finish();

    // Start the HTTP server
    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(schema.clone()))
            .service(
                web::resource(&quot;/graphql&quot;)
                    .route(web::post().to(graphql_handler))
                    .route(web::get().to(graphql_playground)),
            )
            .service(web::resource(&quot;/graphql_ws&quot;).route(web::get().to(graphql_subscription)))
    })
    .bind(&quot;127.0.0.1:8000&quot;)?
    .run()
    .await
}</code></pre></pre>
<h3 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h3>
<p>async-graphql provides several advanced features that can enhance your GraphQL implementation:</p>
<h4 id="dataloader-for-efficient-data-fetching"><a class="header" href="#dataloader-for-efficient-data-fetching">DataLoader for Efficient Data Fetching</a></h4>
<p>DataLoader helps solve the N+1 query problem by batching and caching database queries:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::dataloader::{DataLoader, Loader};
use async_trait::async_trait;
use std::collections::HashMap;

struct UserLoader;

#[async_trait]
impl Loader&lt;String&gt; for UserLoader {
    type Value = User;
    type Error = async_graphql::Error;

    async fn load(&amp;self, keys: &amp;[String]) -&gt; Result&lt;HashMap&lt;String, Self::Value&gt;, Self::Error&gt; {
        // In a real app, you would batch-load users from a database
        let mut users = HashMap::new();

        for key in keys {
            users.insert(key.clone(), User {
                id: key.clone(),
                name: format!(&quot;User {}&quot;, key),
                email: format!(&quot;user{}@example.com&quot;, key),
            });
        }

        Ok(users)
    }
}

// Use in a resolver
#[Object]
impl Query {
    async fn user(&amp;self, ctx: &amp;Context&lt;'_&gt;, id: String) -&gt; Result&lt;User&gt; {
        let loader = ctx.data_unchecked::&lt;DataLoader&lt;UserLoader&gt;&gt;();
        loader.load_one(id).await?
            .ok_or_else(|| &quot;User not found&quot;.into())
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="input-validation"><a class="header" href="#input-validation">Input Validation</a></h4>
<p>You can validate input data using the <code>validator</code> crate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::{InputObject, SimpleObject};
use validator::Validate;

#[derive(InputObject, Validate)]
struct CreateUserInput {
    #[validate(length(min = 3, max = 50))]
    name: String,

    #[validate(email)]
    email: String,
}

#[derive(SimpleObject)]
struct User {
    id: String,
    name: String,
    email: String,
}

#[Object]
impl Mutation {
    async fn create_user(&amp;self, ctx: &amp;Context&lt;'_&gt;, input: CreateUserInput) -&gt; Result&lt;User&gt; {
        // Validate the input
        if let Err(errors) = input.validate() {
            return Err(errors.to_string().into());
        }

        // Process the validated input...
        Ok(User {
            id: uuid::Uuid::new_v4().to_string(),
            name: input.name,
            email: input.email,
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="schema-composition"><a class="header" href="#schema-composition">Schema Composition</a></h4>
<p>For larger applications, you can split your schema into multiple parts and compose them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// User schema
let user_schema = Schema::build(UserQuery, UserMutation, EmptySubscription)
    .register_type::&lt;User&gt;()
    .finish();

// Product schema
let product_schema = Schema::build(ProductQuery, ProductMutation, EmptySubscription)
    .register_type::&lt;Product&gt;()
    .finish();

// Compose schemas
let schema = Schema::build(Query, Mutation, Subscription)
    .register_types_in(&amp;user_schema)
    .register_types_in(&amp;product_schema)
    .finish();
<span class="boring">}</span></code></pre></pre>
<h3 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h3>
<p>When implementing GraphQL APIs, it's important to consider security aspects:</p>
<ol>
<li>
<p><strong>Query Complexity</strong>: GraphQL allows for deeply nested queries that could lead to performance issues or DoS attacks. async-graphql provides complexity analysis to limit query depth and complexity.</p>
</li>
<li>
<p><strong>Rate Limiting</strong>: Implement rate limiting to prevent abuse.</p>
</li>
<li>
<p><strong>Authentication and Authorization</strong>: Use context to pass authentication information to resolvers and implement authorization checks.</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add authentication info to context
let schema = Schema::build(Query, Mutation, Subscription)
    .data(AuthInfo { /* ... */ })
    .finish();

// Use in resolver
async fn protected_resolver(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Result&lt;String&gt; {
    let auth_info = ctx.data::&lt;AuthInfo&gt;()?;

    if !auth_info.is_authenticated() {
        return Err(&quot;Not authenticated&quot;.into());
    }

    if !auth_info.has_permission(&quot;admin&quot;) {
        return Err(&quot;Not authorized&quot;.into());
    }

    Ok(&quot;Sensitive data&quot;.to_string())
}
<span class="boring">}</span></code></pre></pre>
<p>GraphQL with async-graphql provides a powerful and type-safe way to build flexible APIs in Rust. By leveraging Rust's type system and async capabilities, you can create high-performance GraphQL servers that are both robust and maintainable.</p>
<h2 id="websockets-and-real-time-communication"><a class="header" href="#websockets-and-real-time-communication">WebSockets and Real-Time Communication</a></h2>
<p>Real-time communication is a crucial component of modern web applications. WebSockets provide a persistent connection between client and server, allowing bidirectional data transfer. In this section, we'll explore how to implement WebSocket functionality in Rust web applications.</p>
<h3 id="understanding-websockets"><a class="header" href="#understanding-websockets">Understanding WebSockets</a></h3>
<p>WebSockets are a protocol that provides full-duplex communication channels over a single TCP connection. Unlike HTTP, which follows a request-response pattern, WebSockets allow both client and server to send messages independently once a connection is established.</p>
<p>Key benefits of WebSockets include:</p>
<ol>
<li><strong>Reduced Latency</strong>: No need to establish a new connection for each message</li>
<li><strong>Bidirectional Communication</strong>: Both server and client can initiate messages</li>
<li><strong>Efficiency</strong>: Lower overhead compared to repeated HTTP requests</li>
<li><strong>Real-Time Updates</strong>: Ideal for applications requiring immediate updates</li>
</ol>
<h3 id="websockets-in-actix-web"><a class="header" href="#websockets-in-actix-web">WebSockets in Actix Web</a></h3>
<p>Actix Web provides built-in support for WebSockets through its <code>actix-web-actors</code> crate:</p>
<pre><pre class="playground"><code class="language-rust">use actix::{Actor, StreamHandler};
use actix_web::{web, App, Error, HttpRequest, HttpResponse, HttpServer};
use actix_web_actors::ws;

// Define a WebSocket actor
struct MyWebSocket;

impl Actor for MyWebSocket {
    type Context = ws::WebsocketContext&lt;Self&gt;;
}

// Handle incoming WebSocket messages
impl StreamHandler&lt;Result&lt;ws::Message, ws::ProtocolError&gt;&gt; for MyWebSocket {
    fn handle(&amp;mut self, msg: Result&lt;ws::Message, ws::ProtocolError&gt;, ctx: &amp;mut Self::Context) {
        match msg {
            Ok(ws::Message::Ping(msg)) =&gt; ctx.pong(&amp;msg),
            Ok(ws::Message::Text(text)) =&gt; {
                println!(&quot;Received text message: {:?}&quot;, text);

                // Echo the message back
                ctx.text(text);
            },
            Ok(ws::Message::Binary(bin)) =&gt; ctx.binary(bin),
            Ok(ws::Message::Close(reason)) =&gt; {
                println!(&quot;Connection closed&quot;);
                ctx.close(reason);
            }
            _ =&gt; (),
        }
    }
}

// WebSocket connection handler
async fn websocket_route(req: HttpRequest, stream: web::Payload) -&gt; Result&lt;HttpResponse, Error&gt; {
    ws::start(MyWebSocket {}, &amp;req, stream)
}

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        App::new()
            .route(&quot;/ws&quot;, web::get().to(websocket_route))
    })
    .bind(&quot;127.0.0.1:8080&quot;)?
    .run()
    .await
}</code></pre></pre>
<h3 id="building-a-chat-application"><a class="header" href="#building-a-chat-application">Building a Chat Application</a></h3>
<p>Let's build a simple chat application using WebSockets in Actix Web:</p>
<pre><pre class="playground"><code class="language-rust">use std::time::{Duration, Instant};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

use actix::{Actor, ActorContext, Addr, AsyncContext, Handler, Message, StreamHandler};
use actix_web::{web, App, Error, HttpRequest, HttpResponse, HttpServer};
use actix_web_actors::ws;
use serde::{Deserialize, Serialize};
use serde_json::json;

// How often heartbeat pings are sent
const HEARTBEAT_INTERVAL: Duration = Duration::from_secs(5);
// How long before lack of client response causes a timeout
const CLIENT_TIMEOUT: Duration = Duration::from_secs(10);

// Chat server state
struct ChatServer {
    sessions: HashMap&lt;String, Addr&lt;ChatSession&gt;&gt;,
}

impl ChatServer {
    fn new() -&gt; Self {
        ChatServer {
            sessions: HashMap::new(),
        }
    }

    fn join(&amp;mut self, id: String, addr: Addr&lt;ChatSession&gt;) {
        self.sessions.insert(id, addr);
    }

    fn leave(&amp;mut self, id: String) {
        self.sessions.remove(&amp;id);
    }

    fn broadcast(&amp;self, message: &amp;str, sender_id: &amp;str) {
        for (id, addr) in self.sessions.iter() {
            if id != sender_id {
                addr.do_send(ChatMessage(message.to_owned()));
            }
        }
    }
}

// Chat session actor
struct ChatSession {
    id: String,
    server: Arc&lt;Mutex&lt;ChatServer&gt;&gt;,
    hb: Instant, // Heartbeat timestamp
}

impl ChatSession {
    fn new(id: String, server: Arc&lt;Mutex&lt;ChatServer&gt;&gt;) -&gt; Self {
        ChatSession {
            id,
            server,
            hb: Instant::now(),
        }
    }

    // Send heartbeat ping to client
    fn heartbeat(&amp;self, ctx: &amp;mut ws::WebsocketContext&lt;Self&gt;) {
        ctx.run_interval(HEARTBEAT_INTERVAL, |act, ctx| {
            // Check client heartbeat
            if Instant::now().duration_since(act.hb) &gt; CLIENT_TIMEOUT {
                println!(&quot;Client timed out, disconnecting: {}&quot;, act.id);

                // Disconnect session
                let mut server = act.server.lock().unwrap();
                server.leave(act.id.clone());

                // Stop the actor
                ctx.stop();
                return;
            }

            // Send ping
            ctx.ping(b&quot;&quot;);
        });
    }
}

impl Actor for ChatSession {
    type Context = ws::WebsocketContext&lt;Self&gt;;

    fn started(&amp;mut self, ctx: &amp;mut Self::Context) {
        // Start the heartbeat process
        self.heartbeat(ctx);

        // Register session with the server
        let mut server = self.server.lock().unwrap();
        server.join(self.id.clone(), ctx.address());
    }

    fn stopping(&amp;mut self, _: &amp;mut Self::Context) -&gt; actix::Running {
        // Unregister session from server
        let mut server = self.server.lock().unwrap();
        server.leave(self.id.clone());
        actix::Running::Stop
    }
}

// Message sent to chat session
#[derive(Message)]
#[rtype(result = &quot;()&quot;)]
struct ChatMessage(String);

impl Handler&lt;ChatMessage&gt; for ChatSession {
    type Result = ();

    fn handle(&amp;mut self, msg: ChatMessage, ctx: &amp;mut Self::Context) {
        // Send message to WebSocket client
        ctx.text(msg.0);
    }
}

// WebSocket message handler
impl StreamHandler&lt;Result&lt;ws::Message, ws::ProtocolError&gt;&gt; for ChatSession {
    fn handle(&amp;mut self, msg: Result&lt;ws::Message, ws::ProtocolError&gt;, ctx: &amp;mut Self::Context) {
        match msg {
            Ok(ws::Message::Ping(msg)) =&gt; {
                self.hb = Instant::now();
                ctx.pong(&amp;msg);
            }
            Ok(ws::Message::Pong(_)) =&gt; {
                self.hb = Instant::now();
            }
            Ok(ws::Message::Text(text)) =&gt; {
                let msg = text.trim();
                println!(&quot;Received message: {} from {}&quot;, msg, self.id);

                // Broadcast message to all other sessions
                let server = self.server.lock().unwrap();
                server.broadcast(msg, &amp;self.id);
            }
            Ok(ws::Message::Close(reason)) =&gt; {
                ctx.close(reason);
                ctx.stop();
            }
            _ =&gt; ctx.stop(),
        }
    }
}

// WebSocket connection handler
async fn chat_route(
    req: HttpRequest,
    stream: web::Payload,
    server: web::Data&lt;Arc&lt;Mutex&lt;ChatServer&gt;&gt;&gt;,
) -&gt; Result&lt;HttpResponse, Error&gt; {
    // Generate unique session ID
    let id = uuid::Uuid::new_v4().to_string();
    println!(&quot;New chat connection: {}&quot;, id);

    // Create chat session actor
    let session = ChatSession::new(id, server.get_ref().clone());

    // Start WebSocket session
    ws::start(session, &amp;req, stream)
}

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    // Create chat server
    let chat_server = Arc::new(Mutex::new(ChatServer::new()));

    // Start HTTP server
    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(chat_server.clone()))
            .route(&quot;/ws/chat&quot;, web::get().to(chat_route))
            .service(actix_files::Files::new(&quot;/&quot;, &quot;./static&quot;).index_file(&quot;index.html&quot;))
    })
    .bind(&quot;127.0.0.1:8080&quot;)?
    .run()
    .await
}</code></pre></pre>
<p>The HTML client for this chat application might look like:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Rust Chat App&lt;/title&gt;
    &lt;style&gt;
      body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
      }
      .chat-container {
        max-width: 600px;
        margin: 20px auto;
        border: 1px solid #ccc;
      }
      .chat-messages {
        height: 400px;
        overflow-y: auto;
        padding: 10px;
        background: #f9f9f9;
      }
      .message-input {
        display: flex;
        padding: 10px;
        border-top: 1px solid #ccc;
      }
      .message-input input {
        flex: 1;
        padding: 8px;
      }
      .message-input button {
        padding: 8px 16px;
        background: #4caf50;
        color: white;
        border: none;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;chat-container&quot;&gt;
      &lt;div id=&quot;messages&quot; class=&quot;chat-messages&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;message-input&quot;&gt;
        &lt;input type=&quot;text&quot; id=&quot;message&quot; placeholder=&quot;Type a message...&quot; /&gt;
        &lt;button id=&quot;send&quot;&gt;Send&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
      const messagesDiv = document.getElementById(&quot;messages&quot;);
      const messageInput = document.getElementById(&quot;message&quot;);
      const sendButton = document.getElementById(&quot;send&quot;);

      // Connect to WebSocket server
      const socket = new WebSocket(&quot;ws://&quot; + window.location.host + &quot;/ws/chat&quot;);

      socket.onopen = function (e) {
        addMessage(&quot;Connected to chat server&quot;);
      };

      socket.onmessage = function (e) {
        addMessage(e.data);
      };

      socket.onclose = function (e) {
        addMessage(&quot;Disconnected from chat server&quot;);
      };

      socket.onerror = function (e) {
        addMessage(&quot;Error: &quot; + e.message);
      };

      function addMessage(message) {
        const messageElement = document.createElement(&quot;div&quot;);
        messageElement.textContent = message;
        messagesDiv.appendChild(messageElement);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
      }

      function sendMessage() {
        const message = messageInput.value.trim();
        if (message) {
          socket.send(message);
          addMessage(&quot;You: &quot; + message);
          messageInput.value = &quot;&quot;;
        }
      }

      sendButton.addEventListener(&quot;click&quot;, sendMessage);
      messageInput.addEventListener(&quot;keypress&quot;, function (e) {
        if (e.key === &quot;Enter&quot;) {
          sendMessage();
        }
      });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="websockets-in-axum"><a class="header" href="#websockets-in-axum">WebSockets in Axum</a></h3>
<p>Axum also provides support for WebSockets:</p>
<pre><pre class="playground"><code class="language-rust">use axum::{
    extract::ws::{Message, WebSocket, WebSocketUpgrade},
    response::IntoResponse,
    routing::get,
    Router,
};
use futures::{sink::SinkExt, stream::StreamExt};
use std::net::SocketAddr;
use tokio::sync::broadcast;

#[tokio::main]
async fn main() {
    // Create a channel for broadcasting messages
    let (tx, _rx) = broadcast::channel::&lt;String&gt;(100);

    // Build our application with a route
    let app = Router::new()
        .route(&quot;/ws&quot;, get(ws_handler))
        .with_state(tx);

    // Run it
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    println!(&quot;Listening on {}&quot;, addr);
    axum::Server::bind(&amp;addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn ws_handler(
    ws: WebSocketUpgrade,
    State(tx): State&lt;broadcast::Sender&lt;String&gt;&gt;,
) -&gt; impl IntoResponse {
    ws.on_upgrade(|socket| handle_socket(socket, tx))
}

async fn handle_socket(socket: WebSocket, tx: broadcast::Sender&lt;String&gt;) {
    // Split the socket into sender and receiver
    let (mut sender, mut receiver) = socket.split();

    // Subscribe to the broadcast channel
    let mut rx = tx.subscribe();

    // Spawn a task to forward messages from the broadcast channel to the WebSocket
    let mut send_task = tokio::spawn(async move {
        while let Ok(msg) = rx.recv().await {
            if sender.send(Message::Text(msg)).await.is_err() {
                break;
            }
        }
    });

    // Process incoming messages
    let mut recv_task = tokio::spawn(async move {
        while let Some(Ok(msg)) = receiver.next().await {
            match msg {
                Message::Text(text) =&gt; {
                    // Broadcast this message to all other connected clients
                    let _ = tx.send(text);
                }
                Message::Close(_) =&gt; break,
                _ =&gt; {}
            }
        }
    });

    // Wait for either task to finish
    tokio::select! {
        _ = (&amp;mut send_task) =&gt; recv_task.abort(),
        _ = (&amp;mut recv_task) =&gt; send_task.abort(),
    };
}</code></pre></pre>
<h3 id="server-sent-events-sse"><a class="header" href="#server-sent-events-sse">Server-Sent Events (SSE)</a></h3>
<p>For one-way real-time communication from server to client, Server-Sent Events (SSE) provide a simpler alternative to WebSockets:</p>
<pre><pre class="playground"><code class="language-rust">use actix_web::{web, App, Error, HttpRequest, HttpResponse, HttpServer};
use futures::stream::{self, Stream};
use std::time::Duration;
use tokio::time::interval;
use tokio_stream::wrappers::IntervalStream;

// SSE handler
async fn sse_handler() -&gt; HttpResponse {
    // Create an interval stream that emits a message every second
    let interval = interval(Duration::from_secs(1));
    let stream = IntervalStream::new(interval).map(|_| {
        let timestamp = chrono::Utc::now().to_rfc3339();
        Ok::&lt;_, Error&gt;(format!(
            &quot;data: {{\&quot;time\&quot;: \&quot;{}\&quot;, \&quot;message\&quot;: \&quot;Server update\&quot;}}\n\n&quot;,
            timestamp
        ))
    });

    // Return a streaming response
    HttpResponse::Ok()
        .content_type(&quot;text/event-stream&quot;)
        .insert_header((&quot;Cache-Control&quot;, &quot;no-cache&quot;))
        .insert_header((&quot;Connection&quot;, &quot;keep-alive&quot;))
        .streaming(stream)
}

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        App::new()
            .route(&quot;/events&quot;, web::get().to(sse_handler))
    })
    .bind(&quot;127.0.0.1:8080&quot;)?
    .run()
    .await
}</code></pre></pre>
<p>Client-side JavaScript for SSE is much simpler than WebSockets:</p>
<pre><code class="language-javascript">const eventSource = new EventSource(&quot;/events&quot;);

eventSource.onmessage = function (event) {
  const data = JSON.parse(event.data);
  console.log(&quot;Received update:&quot;, data);

  // Update UI with the data
  document.getElementById(
    &quot;updates&quot;
  ).innerHTML += `&lt;div&gt;Time: ${data.time} - ${data.message}&lt;/div&gt;`;
};

eventSource.onerror = function (event) {
  console.error(&quot;EventSource error:&quot;, event);
  eventSource.close();
};
</code></pre>
<h3 id="best-practices-for-real-time-communication"><a class="header" href="#best-practices-for-real-time-communication">Best Practices for Real-Time Communication</a></h3>
<ol>
<li><strong>Connection Management</strong>: Implement heartbeats to detect disconnected clients and clean up resources.</li>
<li><strong>Scalability</strong>: For production applications, consider using a message broker (like Redis, RabbitMQ, or Kafka) to distribute messages across multiple server instances.</li>
<li><strong>Authentication</strong>: Secure WebSocket connections with proper authentication, often using tokens passed during the initial handshake.</li>
<li><strong>Error Handling</strong>: Implement robust error handling and reconnection logic on both client and server.</li>
<li><strong>Rate Limiting</strong>: Protect against abuse by implementing rate limiting for message sending.</li>
<li><strong>Message Validation</strong>: Validate all incoming messages to prevent security vulnerabilities.</li>
<li><strong>Choose the Right Technology</strong>: Use WebSockets for bidirectional communication, SSE for server-to-client updates, and HTTP for request-response patterns.</li>
<li><strong>Batching</strong>: Consider batching small, frequent updates to reduce overhead.</li>
<li><strong>Protocol Design</strong>: Design a clear message protocol with message types and versioning.</li>
<li><strong>Monitoring</strong>: Implement monitoring for connection counts, message rates, and error rates.</li>
</ol>
<h2 id="deployment-and-performance-optimization"><a class="header" href="#deployment-and-performance-optimization">Deployment and Performance Optimization</a></h2>
<p>Modern web applications need to be not only functional but also performant and reliable. In this section, we'll explore how to deploy Rust web applications and optimize their performance.</p>
<h3 id="containerization-with-docker"><a class="header" href="#containerization-with-docker">Containerization with Docker</a></h3>
<p>Docker provides a convenient way to package and deploy Rust applications:</p>
<pre><code class="language-Dockerfile"># Build stage
FROM rust:1.68 as builder
WORKDIR /usr/src/app
COPY . .
RUN cargo build --release

# Runtime stage
FROM debian:bullseye-slim
RUN apt-get update &amp;&amp; apt-get install -y ca-certificates &amp;&amp; rm -rf /var/lib/apt/lists/*
COPY --from=builder /usr/src/app/target/release/my-rust-app /usr/local/bin/my-rust-app
EXPOSE 8080
CMD [&quot;my-rust-app&quot;]
</code></pre>
<p>This multi-stage build creates a smaller final image by only including the compiled binary.</p>
<h3 id="deployment-options"><a class="header" href="#deployment-options">Deployment Options</a></h3>
<p>There are several options for deploying Rust web applications:</p>
<ol>
<li><strong>Bare Metal</strong>: Direct deployment to physical servers for maximum performance.</li>
<li><strong>Virtual Machines</strong>: Traditional cloud instances like AWS EC2, Google Compute Engine, or Azure VMs.</li>
<li><strong>Container Orchestration</strong>: Kubernetes or ECS for managing containerized applications.</li>
<li><strong>Serverless</strong>: Platforms like AWS Lambda (via custom runtimes or Rust Lambda).</li>
<li><strong>Platform as a Service</strong>: Services like Heroku or Fly.io that support containerized applications.</li>
</ol>
<h3 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h3>
<p>Rust already provides excellent performance, but there are additional optimizations you can apply:</p>
<h4 id="1-database-connection-pooling"><a class="header" href="#1-database-connection-pooling">1. Database Connection Pooling</a></h4>
<p>Properly configured connection pools are essential:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pool = PgPoolOptions::new()
    .max_connections(5)
    .min_connections(1)
    .max_lifetime(Duration::from_secs(30 * 60)) // 30 minutes
    .idle_timeout(Duration::from_secs(10 * 60)) // 10 minutes
    .connect(&quot;postgres://user:password@localhost/db&quot;)
    .await?;
<span class="boring">}</span></code></pre></pre>
<h4 id="2-async-worker-pools"><a class="header" href="#2-async-worker-pools">2. Async Worker Pools</a></h4>
<p>For CPU-intensive tasks, use a dedicated thread pool:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::task::spawn_blocking;

async fn handle_request() -&gt; Result&lt;HttpResponse, Error&gt; {
    // Offload CPU-intensive work to a blocking thread
    let result = spawn_blocking(|| {
        // Expensive computation here
        compute_something_expensive()
    }).await?;

    Ok(HttpResponse::Ok().json(result))
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-response-compression"><a class="header" href="#3-response-compression">3. Response Compression</a></h4>
<p>Enable compression for HTTP responses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::middleware::Compress;

App::new()
    .wrap(Compress::default())
    // ...
<span class="boring">}</span></code></pre></pre>
<h4 id="4-caching"><a class="header" href="#4-caching">4. Caching</a></h4>
<p>Implement caching for expensive operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use moka::future::Cache;
use std::time::Duration;

// Create a time-based cache
let cache: Cache&lt;String, Vec&lt;User&gt;&gt; = Cache::builder()
    .max_capacity(100)
    .time_to_live(Duration::from_secs(60))
    .build();

async fn get_users(cache: web::Data&lt;Cache&lt;String, Vec&lt;User&gt;&gt;&gt;) -&gt; HttpResponse {
    let cache_key = &quot;all_users&quot;.to_string();

    // Try to get from cache
    if let Some(users) = cache.get(&amp;cache_key).await {
        return HttpResponse::Ok().json(users);
    }

    // Not in cache, fetch from database
    let users = fetch_users_from_db().await?;

    // Insert into cache
    cache.insert(cache_key, users.clone()).await;

    HttpResponse::Ok().json(users)
}
<span class="boring">}</span></code></pre></pre>
<h4 id="5-static-file-serving"><a class="header" href="#5-static-file-serving">5. Static File Serving</a></h4>
<p>Serve static files efficiently with proper caching headers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_files as fs;

App::new()
    .service(fs::Files::new(&quot;/static&quot;, &quot;./static&quot;)
        .prefer_utf8(true)
        .use_last_modified(true)
        .use_etag(true))
    // ...
<span class="boring">}</span></code></pre></pre>
<h4 id="6-load-testing"><a class="header" href="#6-load-testing">6. Load Testing</a></h4>
<p>Use tools like <code>wrk</code>, <code>hey</code>, or <code>k6</code> to load test your application and identify bottlenecks:</p>
<pre><code class="language-bash"># Example with wrk
wrk -t12 -c400 -d30s http://localhost:8080/api/users
</code></pre>
<h3 id="monitoring-and-observability"><a class="header" href="#monitoring-and-observability">Monitoring and Observability</a></h3>
<p>Implement proper monitoring for production applications:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{info, error, Level};
use tracing_subscriber::FmtSubscriber;

// Initialize the tracing subscriber
fn init_tracing() {
    let subscriber = FmtSubscriber::builder()
        .with_max_level(Level::INFO)
        .finish();
    tracing::subscriber::set_global_default(subscriber)
        .expect(&quot;setting default subscriber failed&quot;);
}

// Use in your application
async fn handle_request() -&gt; impl Responder {
    info!(&quot;Handling request&quot;);

    match do_something().await {
        Ok(result) =&gt; {
            info!(&quot;Request succeeded&quot;);
            HttpResponse::Ok().json(result)
        },
        Err(e) =&gt; {
            error!(&quot;Request failed: {}&quot;, e);
            HttpResponse::InternalServerError().finish()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For more comprehensive monitoring, integrate with services like Prometheus and Grafana:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web_prom::{PrometheusMetrics, PrometheusMetricsBuilder};

// Create prometheus metrics middleware
let prometheus = PrometheusMetricsBuilder::new(&quot;api&quot;)
    .endpoint(&quot;/metrics&quot;)
    .build()
    .unwrap();

// Add to your app
App::new()
    .wrap(prometheus.clone())
    // ...
<span class="boring">}</span></code></pre></pre>
<h2 id="webassembly-for-frontend-development"><a class="header" href="#webassembly-for-frontend-development">WebAssembly for Frontend Development</a></h2>
<p>WebAssembly (Wasm) has revolutionized web development by enabling languages other than JavaScript to run in the browser at near-native speed. Rust has emerged as one of the most compelling languages for WebAssembly development due to its performance, safety guarantees, and excellent tooling support.</p>
<h3 id="understanding-webassembly-1"><a class="header" href="#understanding-webassembly-1">Understanding WebAssembly</a></h3>
<p>WebAssembly is a binary instruction format designed as a portable compilation target for high-level languages. Key characteristics include:</p>
<ul>
<li><strong>Performance</strong>: WebAssembly code executes at near-native speed</li>
<li><strong>Safety</strong>: Runs in a sandboxed environment with memory safety guarantees</li>
<li><strong>Portability</strong>: Works across all modern browsers and platforms</li>
<li><strong>Compatibility</strong>: Interoperates seamlessly with JavaScript and DOM APIs</li>
</ul>
<p>For Rust developers, WebAssembly offers a way to leverage Rust's strengths in frontend development without sacrificing performance or browser compatibility.</p>
<h3 id="rust-to-webassembly-toolchain"><a class="header" href="#rust-to-webassembly-toolchain">Rust to WebAssembly Toolchain</a></h3>
<p>The Rust ecosystem provides excellent tools for WebAssembly development:</p>
<h4 id="wasm-pack"><a class="header" href="#wasm-pack">wasm-pack</a></h4>
<p>The primary tool for building and packaging Rust-generated WebAssembly modules is <code>wasm-pack</code>. It handles:</p>
<ul>
<li>Compiling Rust code to WebAssembly</li>
<li>Generating appropriate JavaScript bindings</li>
<li>Creating npm packages for easy integration with JavaScript tooling</li>
</ul>
<p>To install <code>wasm-pack</code>:</p>
<pre><code class="language-bash">cargo install wasm-pack
</code></pre>
<p>A basic workflow looks like:</p>
<pre><code class="language-bash"># Create a new library for WebAssembly
cargo new --lib my-wasm-project

# Build the WebAssembly package
cd my-wasm-project
wasm-pack build --target web
</code></pre>
<h4 id="wasm-bindgen"><a class="header" href="#wasm-bindgen">wasm-bindgen</a></h4>
<p>At the core of Rust's WebAssembly support is the <code>wasm-bindgen</code> crate, which facilitates communication between Rust and JavaScript. It allows:</p>
<ul>
<li>Exporting Rust functions and types to JavaScript</li>
<li>Importing JavaScript functions and objects into Rust</li>
<li>Converting between Rust and JavaScript data types</li>
<li>Working with DOM elements and browser APIs</li>
</ul>
<p>Here's a simple example of using <code>wasm-bindgen</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;

// Export a Rust function to JavaScript
#[wasm_bindgen]
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// Import a JavaScript function
#[wasm_bindgen]
extern &quot;C&quot; {
    fn alert(s: &amp;str);
}

// Call JavaScript from Rust
#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!(&quot;Hello, {}!&quot;, name));
}
<span class="boring">}</span></code></pre></pre>
<h4 id="web-sys-and-js-sys"><a class="header" href="#web-sys-and-js-sys">web-sys and js-sys</a></h4>
<p>These companion crates provide typed interfaces to:</p>
<ul>
<li><code>web-sys</code>: Browser APIs and DOM manipulation</li>
<li><code>js-sys</code>: JavaScript standard library functionality</li>
</ul>
<p>Example of DOM manipulation with <code>web-sys</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;
use web_sys::{Document, Element, HtmlElement, Window};

#[wasm_bindgen]
pub fn create_element() -&gt; Result&lt;(), JsValue&gt; {
    // Get the window object
    let window = web_sys::window().expect(&quot;no global window exists&quot;);

    // Get the document object
    let document = window.document().expect(&quot;should have a document on window&quot;);

    // Create a div element
    let div = document.create_element(&quot;div&quot;)?;
    div.set_inner_html(&quot;Hello from Rust!&quot;);

    // Append to the body
    let body = document.body().expect(&quot;document should have a body&quot;);
    body.append_child(&amp;div)?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="optimizing-webassembly-performance"><a class="header" href="#optimizing-webassembly-performance">Optimizing WebAssembly Performance</a></h3>
<p>While WebAssembly is already fast, several optimizations can further improve performance:</p>
<h4 id="size-optimization"><a class="header" href="#size-optimization">Size Optimization</a></h4>
<pre><code class="language-toml"># In Cargo.toml
[profile.release]
# Tell `rustc` to optimize for small code size.
opt-level = &quot;s&quot;
lto = true
codegen-units = 1
</code></pre>
<h4 id="reducing-wasm-size-with-wasm-opt"><a class="header" href="#reducing-wasm-size-with-wasm-opt">Reducing Wasm Size with wasm-opt</a></h4>
<p>The <code>wasm-opt</code> tool from the Binaryen toolkit can further optimize WebAssembly binaries:</p>
<pre><code class="language-bash">wasm-opt -Oz -o optimized.wasm input.wasm
</code></pre>
<h4 id="minimizing-javascript-glue-code"><a class="header" href="#minimizing-javascript-glue-code">Minimizing JavaScript Glue Code</a></h4>
<p>Use appropriate <code>wasm-bindgen</code> settings to minimize generated JavaScript:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use raw WebAssembly without JavaScript glue when possible
#[wasm_bindgen(raw_module = &quot;./path/to/module&quot;)]
extern &quot;C&quot; {
    // Imports
}
<span class="boring">}</span></code></pre></pre>
<h3 id="debugging-webassembly"><a class="header" href="#debugging-webassembly">Debugging WebAssembly</a></h3>
<p>Debugging WebAssembly can be challenging, but several tools can help:</p>
<ol>
<li><strong>Browser DevTools</strong>: Chrome and Firefox now have native WebAssembly debugging support</li>
<li><strong>console_error_panic_hook</strong>: A crate that redirects Rust panics to the browser console</li>
<li><strong>wasm-logger</strong>: Redirects Rust's <code>log</code> output to the browser console</li>
</ol>
<p>Example of configuring panic and logging hooks:</p>
<pre><pre class="playground"><code class="language-rust">use wasm_bindgen::prelude::*;

#[wasm_bindgen(start)]
pub fn main() {
    // This forwards Rust panics to JavaScript console.error
    console_error_panic_hook::set_once();

    // Initialize logger
    wasm_logger::init(wasm_logger::Config::default());

    // Now we can use log macros
    log::info!(&quot;WebAssembly module initialized&quot;);
}</code></pre></pre>
<h3 id="integrating-with-javascript-frameworks"><a class="header" href="#integrating-with-javascript-frameworks">Integrating with JavaScript Frameworks</a></h3>
<p>WebAssembly modules can be integrated with any JavaScript framework:</p>
<h4 id="with-react"><a class="header" href="#with-react">With React</a></h4>
<pre><code class="language-javascript">import React, { useEffect, useState } from &quot;react&quot;;
import init, { add } from &quot;./pkg/my_wasm_module&quot;;

function App() {
  const [result, setResult] = useState(null);

  useEffect(() =&gt; {
    async function loadWasm() {
      await init();
      setResult(add(40, 2));
    }
    loadWasm();
  }, []);

  return &lt;div&gt;Result from Wasm: {result !== null ? result : &quot;Loading...&quot;}&lt;/div&gt;;
}
</code></pre>
<h4 id="with-vue"><a class="header" href="#with-vue">With Vue</a></h4>
<pre><code class="language-javascript">import { createApp } from &quot;vue&quot;;
import init, { add } from &quot;./pkg/my_wasm_module&quot;;

const app = createApp({
  data() {
    return {
      result: null,
    };
  },
  async mounted() {
    await init();
    this.result = add(40, 2);
  },
  template: `&lt;div&gt;Result from Wasm: {{ result !== null ? result : 'Loading...' }}&lt;/div&gt;`,
});

app.mount(&quot;#app&quot;);
</code></pre>
<h2 id="modern-rust-ui-frameworks"><a class="header" href="#modern-rust-ui-frameworks">Modern Rust UI Frameworks</a></h2>
<p>While WebAssembly enables Rust to run in the browser, building complex UIs directly with WebAssembly APIs would be cumbersome. Fortunately, several Rust frameworks provide higher-level abstractions for frontend development.</p>
<h3 id="yew-react-inspired-framework"><a class="header" href="#yew-react-inspired-framework">Yew: React-inspired Framework</a></h3>
<p>Yew is one of the most mature Rust frontend frameworks, drawing inspiration from React and Elm. It provides a component-based architecture with a virtual DOM implementation.</p>
<h4 id="key-features-3"><a class="header" href="#key-features-3">Key Features</a></h4>
<ul>
<li>Component-based architecture</li>
<li>JSX-like syntax with Rust macros</li>
<li>State management</li>
<li>Efficient rendering with virtual DOM</li>
<li>Server-side rendering support</li>
<li>Strong typing throughout the application</li>
</ul>
<h4 id="basic-example-3"><a class="header" href="#basic-example-3">Basic Example</a></h4>
<pre><pre class="playground"><code class="language-rust">use yew::prelude::*;

#[function_component]
fn App() -&gt; Html {
    let counter = use_state(|| 0);
    let onclick = {
        let counter = counter.clone();
        Callback::from(move |_| {
            counter.set(*counter + 1);
        })
    };

    html! {
        &lt;div&gt;
            &lt;h1&gt;{ &quot;Yew Counter Example&quot; }&lt;/h1&gt;
            &lt;button {onclick}&gt;{ &quot;+1&quot; }&lt;/button&gt;
            &lt;p&gt;{ *counter }&lt;/p&gt;
        &lt;/div&gt;
    }
}

fn main() {
    yew::Renderer::&lt;App&gt;::new().render();
}</code></pre></pre>
<h4 id="component-lifecycle"><a class="header" href="#component-lifecycle">Component Lifecycle</a></h4>
<p>Yew components can be implemented using either function components (with hooks) or struct components:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Struct component example
struct CounterComponent {
    counter: i32,
}

enum Msg {
    Increment,
    Decrement,
}

impl Component for CounterComponent {
    type Message = Msg;
    type Properties = ();

    fn create(_ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
        Self { counter: 0 }
    }

    fn update(&amp;mut self, _ctx: &amp;Context&lt;Self&gt;, msg: Self::Message) -&gt; bool {
        match msg {
            Msg::Increment =&gt; {
                self.counter += 1;
                true
            }
            Msg::Decrement =&gt; {
                self.counter -= 1;
                true
            }
        }
    }

    fn view(&amp;self, ctx: &amp;Context&lt;Self&gt;) -&gt; Html {
        let link = ctx.link();
        html! {
            &lt;div&gt;
                &lt;button onclick={link.callback(|_| Msg::Increment)}&gt;{ &quot;+1&quot; }&lt;/button&gt;
                &lt;button onclick={link.callback(|_| Msg::Decrement)}&gt;{ &quot;-1&quot; }&lt;/button&gt;
                &lt;p&gt;{ self.counter }&lt;/p&gt;
            &lt;/div&gt;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="leptos-fine-grained-reactive-framework"><a class="header" href="#leptos-fine-grained-reactive-framework">Leptos: Fine-grained Reactive Framework</a></h3>
<p>Leptos is a newer framework that focuses on fine-grained reactivity, inspired by SolidJS. Unlike Yew's virtual DOM approach, Leptos updates only what needs to change, potentially offering better performance.</p>
<h4 id="key-features-4"><a class="header" href="#key-features-4">Key Features</a></h4>
<ul>
<li>Fine-grained reactivity</li>
<li>Server-side rendering with hydration</li>
<li>Islands architecture</li>
<li>Small bundle sizes</li>
<li>Signals for state management</li>
<li>View macros for declarative UI</li>
</ul>
<h4 id="basic-example-4"><a class="header" href="#basic-example-4">Basic Example</a></h4>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

#[component]
fn Counter() -&gt; impl IntoView {
    let (count, set_count) = create_signal(0);

    view! {
        &lt;div&gt;
            &lt;h2&gt;&quot;Counter Example&quot;&lt;/h2&gt;
            &lt;button on:click=move |_| set_count.update(|n| *n += 1)&gt;
                &quot;Increment&quot;
            &lt;/button&gt;
            &lt;p&gt;&quot;Count: &quot; {count}&lt;/p&gt;
        &lt;/div&gt;
    }
}

fn main() {
    mount_to_body(|| view! { &lt;Counter/&gt; });
}</code></pre></pre>
<h4 id="signals-and-derived-values"><a class="header" href="#signals-and-derived-values">Signals and Derived Values</a></h4>
<p>Leptos uses signals for state management:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use leptos::*;

#[component]
fn TemperatureConverter() -&gt; impl IntoView {
    let (celsius, set_celsius) = create_signal(0.0);

    // Derived computation that automatically updates
    let fahrenheit = move || celsius() * 9.0 / 5.0 + 32.0;

    view! {
        &lt;div&gt;
            &lt;input
                type=&quot;number&quot;
                prop:value=celsius
                on:input=move |ev| {
                    if let Ok(val) = event_target_value(&amp;ev).parse::&lt;f64&gt;() {
                        set_celsius(val);
                    }
                }
            /&gt;
            &lt;p&gt;&quot;Celsius: &quot; {celsius}&lt;/p&gt;
            &lt;p&gt;&quot;Fahrenheit: &quot; {fahrenheit}&lt;/p&gt;
        &lt;/div&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="dioxus-cross-platform-ui-framework"><a class="header" href="#dioxus-cross-platform-ui-framework">Dioxus: Cross-platform UI Framework</a></h3>
<p>Dioxus aims to be a cross-platform UI framework, targeting not just WebAssembly but also desktop, mobile, and TUI (terminal UI) applications.</p>
<h4 id="key-features-5"><a class="header" href="#key-features-5">Key Features</a></h4>
<ul>
<li>Unified API across platforms</li>
<li>React-like component model</li>
<li>Hot reloading</li>
<li>Small runtime</li>
<li>Efficient rendering</li>
<li>Hooks-based state management</li>
</ul>
<h4 id="basic-example-5"><a class="header" href="#basic-example-5">Basic Example</a></h4>
<pre><pre class="playground"><code class="language-rust">use dioxus::prelude::*;

fn main() {
    dioxus_web::launch(App);
}

fn App() -&gt; Element {
    let mut count = use_state(|| 0);

    rsx! {
        div {
            h1 { &quot;Counter Example&quot; }
            button {
                onclick: move |_| count += 1,
                &quot;+1&quot;
            }
            p { &quot;Count: {count}&quot; }
        }
    }
}</code></pre></pre>
<h4 id="cross-platform-example"><a class="header" href="#cross-platform-example">Cross-platform Example</a></h4>
<p>The same component can be used across different platforms:</p>
<pre><pre class="playground"><code class="language-rust">// For web
fn main() {
    dioxus_web::launch(App);
}

// For desktop
fn main() {
    dioxus_desktop::launch(App);
}

// For mobile
fn main() {
    dioxus_mobile::launch(App);
}</code></pre></pre>
<h2 id="full-stack-rust-sharing-code-between-frontend-and-backend"><a class="header" href="#full-stack-rust-sharing-code-between-frontend-and-backend">Full-stack Rust: Sharing Code Between Frontend and Backend</a></h2>
<p>One of the most compelling advantages of using Rust for both frontend and backend development is the ability to share code between them. This can reduce duplication, ensure consistency, and improve maintainability.</p>
<h3 id="code-sharing-strategies"><a class="header" href="#code-sharing-strategies">Code Sharing Strategies</a></h3>
<h4 id="1-workspace-structure"><a class="header" href="#1-workspace-structure">1. Workspace Structure</a></h4>
<p>A typical full-stack Rust project might use a Cargo workspace structure:</p>
<pre><code class="language-toml"># Cargo.toml
[workspace]
members = [
    &quot;common&quot;,   # Shared code
    &quot;frontend&quot;, # WebAssembly frontend
    &quot;backend&quot;   # Server backend
]
</code></pre>
<h4 id="2-shared-models-and-validation"><a class="header" href="#2-shared-models-and-validation">2. Shared Models and Validation</a></h4>
<p>Data models and validation logic are prime candidates for sharing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// common/src/models.rs
use serde::{Deserialize, Serialize};
use validator::Validate;

#[derive(Debug, Serialize, Deserialize, Validate, Clone)]
pub struct User {
    #[validate(length(min = 3, max = 50))]
    pub username: String,

    #[validate(email)]
    pub email: String,

    #[validate(length(min = 8))]
    pub password: String,
}
<span class="boring">}</span></code></pre></pre>
<p>This model can be used both in frontend forms and backend validation.</p>
<h4 id="3-shared-api-definitions"><a class="header" href="#3-shared-api-definitions">3. Shared API Definitions</a></h4>
<p>API endpoints and request/response types can be defined once:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// common/src/api.rs
use serde::{Deserialize, Serialize};
use crate::models::User;

#[derive(Debug, Serialize, Deserialize)]
pub struct LoginRequest {
    pub email: String,
    pub password: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LoginResponse {
    pub token: String,
    pub user: User,
}

pub const LOGIN_ENDPOINT: &amp;str = &quot;/api/login&quot;;
<span class="boring">}</span></code></pre></pre>
<h4 id="4-error-handling"><a class="header" href="#4-error-handling">4. Error Handling</a></h4>
<p>Consistent error types across frontend and backend:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// common/src/errors.rs
use serde::{Deserialize, Serialize};
use thiserror::Error;

#[derive(Debug, Error, Serialize, Deserialize)]
pub enum AppError {
    #[error(&quot;Authentication failed&quot;)]
    AuthenticationError,

    #[error(&quot;Not authorized to access this resource&quot;)]
    AuthorizationError,

    #[error(&quot;Resource not found&quot;)]
    NotFoundError,

    #[error(&quot;Validation error: {0}&quot;)]
    ValidationError(String),

    #[error(&quot;Server error&quot;)]
    ServerError,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="practical-example-full-stack-form-handling"><a class="header" href="#practical-example-full-stack-form-handling">Practical Example: Full-stack Form Handling</a></h3>
<p>Here's how shared code can be used for form validation in a full-stack application:</p>
<h4 id="shared-validation-common-crate"><a class="header" href="#shared-validation-common-crate">Shared Validation (common crate)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// common/src/validation.rs
use serde::{Deserialize, Serialize};
use validator::Validate;

#[derive(Debug, Serialize, Deserialize, Validate)]
pub struct RegistrationForm {
    #[validate(length(min = 3, message = &quot;Username must be at least 3 characters&quot;))]
    pub username: String,

    #[validate(email(message = &quot;Invalid email format&quot;))]
    pub email: String,

    #[validate(length(min = 8, message = &quot;Password must be at least 8 characters&quot;))]
    pub password: String,
}

pub fn validate_form(form: &amp;RegistrationForm) -&gt; Result&lt;(), Vec&lt;String&gt;&gt; {
    match form.validate() {
        Ok(_) =&gt; Ok(()),
        Err(errors) =&gt; {
            let error_messages = errors
                .field_errors()
                .iter()
                .flat_map(|(_, errs)| errs.iter().map(|e| e.message.clone().unwrap_or_default().to_string()))
                .collect();
            Err(error_messages)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="frontend-implementation-yew"><a class="header" href="#frontend-implementation-yew">Frontend Implementation (Yew)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// frontend/src/pages/register.rs
use common::validation::{RegistrationForm, validate_form};
use yew::prelude::*;

#[function_component]
pub fn RegisterPage() -&gt; Html {
    let form = use_state(|| RegistrationForm {
        username: String::new(),
        email: String::new(),
        password: String::new(),
    });

    let errors = use_state(Vec::new);

    let onsubmit = {
        let form = form.clone();
        let errors = errors.clone();

        Callback::from(move |e: SubmitEvent| {
            e.prevent_default();
            let current_form = (*form).clone();

            match validate_form(&amp;current_form) {
                Ok(_) =&gt; {
                    // Form is valid, send to server
                    errors.set(vec![]);
                    // API call here
                },
                Err(validation_errors) =&gt; {
                    errors.set(validation_errors);
                }
            }
        })
    };

    // Render form with validation errors
    html! {
        &lt;form onsubmit={onsubmit}&gt;
            // Form fields
            // Display errors
        &lt;/form&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="backend-implementation-axum"><a class="header" href="#backend-implementation-axum">Backend Implementation (Axum)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// backend/src/handlers/auth.rs
use axum::{
    extract::Json,
    http::StatusCode,
    response::IntoResponse,
};
use common::validation::{RegistrationForm, validate_form};

pub async fn register(
    Json(form): Json&lt;RegistrationForm&gt;,
) -&gt; impl IntoResponse {
    // Use the shared validation
    match validate_form(&amp;form) {
        Ok(_) =&gt; {
            // Process valid registration
            // Save to database, etc.
            (StatusCode::CREATED, &quot;User registered successfully&quot;.to_string())
        }
        Err(errors) =&gt; {
            (StatusCode::BAD_REQUEST, format!(&quot;Validation errors: {:?}&quot;, errors))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="server-side-rendering-with-rust"><a class="header" href="#server-side-rendering-with-rust">Server-side Rendering with Rust</a></h2>
<p>Server-side rendering (SSR) improves initial page load performance and SEO by rendering the HTML on the server before sending it to the client. Rust's web frameworks are increasingly supporting SSR capabilities.</p>
<h3 id="benefits-of-ssr"><a class="header" href="#benefits-of-ssr">Benefits of SSR</a></h3>
<ul>
<li><strong>Faster Initial Load</strong>: Users see content sooner</li>
<li><strong>Improved SEO</strong>: Search engines can more easily index content</li>
<li><strong>Better Performance on Low-end Devices</strong>: Less client-side JavaScript execution</li>
<li><strong>Progressive Enhancement</strong>: Basic functionality without JavaScript</li>
</ul>
<h3 id="ssr-with-leptos"><a class="header" href="#ssr-with-leptos">SSR with Leptos</a></h3>
<p>Leptos has first-class support for server-side rendering with hydration:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

#[component]
fn App() -&gt; impl IntoView {
    let (count, set_count) = create_signal(0);

    view! {
        &lt;div&gt;
            &lt;h1&gt;&quot;Server Rendered Counter&quot;&lt;/h1&gt;
            &lt;button on:click=move |_| set_count.update(|n| *n += 1)&gt;
                &quot;Increment&quot;
            &lt;/button&gt;
            &lt;p&gt;&quot;Count: &quot; {count}&lt;/p&gt;
        &lt;/div&gt;
    }
}

// For client-side rendering
#[cfg(feature = &quot;hydrate&quot;)]
fn main() {
    leptos::mount_to_body(App);
}

// For server-side rendering
#[cfg(feature = &quot;ssr&quot;)]
#[tokio::main]
async fn main() {
    use axum::{
        routing::get,
        Router,
    };
    use leptos_axum::{generate_route_list, LeptosRoutes};

    let conf = get_configuration(None).await.unwrap();
    let leptos_options = conf.leptos_options;
    let routes = generate_route_list(|cx| view! { cx, &lt;App/&gt; });

    let app = Router::new()
        .route(&quot;/&quot;, get(leptos_axum::render_app_to_stream))
        .leptos_routes(leptos_options.clone(), routes, |cx| view! { cx, &lt;App/&gt; })
        .with_state(leptos_options);

    let addr = std::net::SocketAddr::from(([127, 0, 0, 1], 3000));
    axum::Server::bind(&amp;addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}</code></pre></pre>
<h3 id="islands-architecture"><a class="header" href="#islands-architecture">Islands Architecture</a></h3>
<p>The &quot;islands architecture&quot; is a hybrid approach where most of the page is static HTML, with interactive &quot;islands&quot; hydrated on the client:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use leptos::*;

// This component will be hydrated and interactive
#[island]
fn Counter() -&gt; impl IntoView {
    let (count, set_count) = create_signal(0);

    view! {
        &lt;div&gt;
            &lt;button on:click=move |_| set_count.update(|n| *n += 1)&gt;
                &quot;Increment&quot;
            &lt;/button&gt;
            &lt;p&gt;&quot;Count: &quot; {count}&lt;/p&gt;
        &lt;/div&gt;
    }
}

// This part remains static HTML
#[component]
fn StaticContent() -&gt; impl IntoView {
    view! {
        &lt;div&gt;
            &lt;h1&gt;&quot;Welcome to Our Site&quot;&lt;/h1&gt;
            &lt;p&gt;&quot;This content doesn't need interactivity.&quot;&lt;/p&gt;
        &lt;/div&gt;
    }
}

#[component]
fn App() -&gt; impl IntoView {
    view! {
        &lt;div&gt;
            &lt;StaticContent/&gt;
            &lt;Counter/&gt;
        &lt;/div&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="progressive-enhancement"><a class="header" href="#progressive-enhancement">Progressive Enhancement</a></h3>
<p>A core principle of SSR is progressive enhancement—ensuring basic functionality works without JavaScript:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use leptos::*;

#[component]
fn SearchForm() -&gt; impl IntoView {
    let (query, set_query) = create_signal(String::new());
    let results = create_resource(
        move || query.get(),
        |q| async move {
            if q.is_empty() {
                vec![]
            } else {
                search_api(q).await
            }
        }
    );

    // Form works without JS via action, but uses JS when available
    view! {
        &lt;form
            action=&quot;/search&quot;
            method=&quot;GET&quot;
            on:submit=move |ev| {
                ev.prevent_default();
                // Client-side search when JS is available
            }
        &gt;
            &lt;input
                type=&quot;text&quot;
                name=&quot;q&quot;
                prop:value=query
                on:input=move |ev| set_query(event_target_value(&amp;ev))
            /&gt;
            &lt;button type=&quot;submit&quot;&gt;&quot;Search&quot;&lt;/button&gt;
        &lt;/form&gt;

        // Show results client-side when available
        &lt;Suspense fallback=move || view! { &lt;p&gt;&quot;Loading...&quot;&lt;/p&gt; }&gt;
            {move || results.get().map(|r| view! {
                &lt;ul&gt;
                    {r.into_iter().map(|item| view! {
                        &lt;li&gt;{item}&lt;/li&gt;
                    }).collect::&lt;Vec&lt;_&gt;&gt;()}
                &lt;/ul&gt;
            })}
        &lt;/Suspense&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="seo-considerations"><a class="header" href="#seo-considerations">SEO Considerations</a></h3>
<p>For content-heavy sites, proper metadata is crucial:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use leptos::*;
use leptos_meta::*;

#[component]
fn BlogPost(post: BlogPostData) -&gt; impl IntoView {
    view! {
        &lt;&gt;
            &lt;Title text=post.title.clone()/&gt;
            &lt;Meta name=&quot;description&quot; content=post.summary.clone()/&gt;
            &lt;Meta property=&quot;og:title&quot; content=post.title.clone()/&gt;
            &lt;Meta property=&quot;og:description&quot; content=post.summary.clone()/&gt;

            &lt;article&gt;
                &lt;h1&gt;{post.title}&lt;/h1&gt;
                &lt;div class=&quot;content&quot;&gt;{post.content}&lt;/div&gt;
            &lt;/article&gt;
        &lt;/&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this chapter, we've explored the rapidly evolving world of web development in Rust. We've seen how Rust's core strengths—performance, memory safety, and concurrency—make it an excellent choice for building robust web applications.</p>
<p>We've covered backend frameworks like Actix Web, Rocket, and Axum, showing how each provides different approaches to building web services. We've learned how to design RESTful APIs, integrate with databases using SQLx, implement authentication and security, and create middleware for cross-cutting concerns.</p>
<p>For frontend development, we've explored how Rust can be compiled to WebAssembly, enabling the creation of high-performance web interfaces with frameworks like Yew and Leptos. We've also looked at GraphQL implementation with async-graphql, WebSockets for real-time communication, and deployment strategies for Rust web applications.</p>
<p>The Rust web ecosystem is still evolving, but it already offers powerful tools for building fast, reliable, and secure web applications. As the ecosystem continues to mature, Rust is becoming an increasingly attractive option for web development, especially for applications where performance, safety, and reliability are critical.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li>
<p><strong>Basic Web Server</strong>: Implement a simple web server using Actix Web that serves static files and handles basic form submissions.</p>
</li>
<li>
<p><strong>RESTful API</strong>: Create a CRUD API for a resource of your choice (e.g., books, products, tasks) using one of the frameworks discussed in this chapter.</p>
</li>
<li>
<p><strong>Database Integration</strong>: Extend your API to store and retrieve data from a PostgreSQL database using SQLx.</p>
</li>
<li>
<p><strong>Authentication</strong>: Add JWT-based authentication to your API, with protected and public routes.</p>
</li>
<li>
<p><strong>WebAssembly Frontend</strong>: Build a simple frontend application using Yew or Leptos that interacts with your API.</p>
</li>
<li>
<p><strong>Real-Time Chat</strong>: Implement a real-time chat application using WebSockets, with features like user presence and message history.</p>
</li>
<li>
<p><strong>GraphQL API</strong>: Convert your REST API to a GraphQL API using async-graphql.</p>
</li>
<li>
<p><strong>Performance Optimization</strong>: Load test your application and implement at least three performance optimizations.</p>
</li>
<li>
<p><strong>Deployment</strong>: Package your application in a Docker container and deploy it to a cloud provider.</p>
</li>
<li>
<p><strong>Full-Stack Project</strong>: Build a complete web application that combines backend APIs, database integration, authentication, and a WebAssembly frontend.</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapters/29-cli.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapters/31-database.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapters/29-cli.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapters/31-database.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
