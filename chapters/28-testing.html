<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Writing Tests in Rust - Rust Universe: Fearless Systems Engineering</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="A comprehensive guide to learning the Rust programming language from fundamentals to mastery.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 1: Fundamentals</li><li class="chapter-item expanded "><a href="../chapters/01-about-this-book.html"><strong aria-hidden="true">1.</strong> About This Book</a></li><li class="chapter-item expanded "><a href="../chapters/02-introduction-to-rust.html"><strong aria-hidden="true">2.</strong> Introduction to Rust</a></li><li class="chapter-item expanded "><a href="../chapters/03-getting-started.html"><strong aria-hidden="true">3.</strong> Getting Started with the Rust Toolchain</a></li><li class="chapter-item expanded "><a href="../chapters/04-basic-syntax.html"><strong aria-hidden="true">4.</strong> Basic Syntax and Data Types</a></li><li class="chapter-item expanded "><a href="../chapters/05-control-flow.html"><strong aria-hidden="true">5.</strong> Control Flow in Rust</a></li><li class="chapter-item expanded "><a href="../chapters/06-functions.html"><strong aria-hidden="true">6.</strong> Functions and Procedures</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 2: Ownership - Rust's Secret Weapon</li><li class="chapter-item expanded "><a href="../chapters/07-understanding-ownership.html"><strong aria-hidden="true">7.</strong> Understanding Ownership</a></li><li class="chapter-item expanded "><a href="../chapters/08-borrowing-references.html"><strong aria-hidden="true">8.</strong> Borrowing and References</a></li><li class="chapter-item expanded "><a href="../chapters/09-strings-slices.html"><strong aria-hidden="true">9.</strong> Working with Strings and Slices</a></li><li class="chapter-item expanded "><a href="../chapters/10-advanced-ownership.html"><strong aria-hidden="true">10.</strong> Advanced Ownership Patterns</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 3: Organizing Code</li><li class="chapter-item expanded "><a href="../chapters/11-structs.html"><strong aria-hidden="true">11.</strong> Structs and Custom Types</a></li><li class="chapter-item expanded "><a href="../chapters/12-enums.html"><strong aria-hidden="true">12.</strong> Enums and Pattern Matching</a></li><li class="chapter-item expanded "><a href="../chapters/13-modules.html"><strong aria-hidden="true">13.</strong> Modules and Organizing Code</a></li><li class="chapter-item expanded "><a href="../chapters/14-collections.html"><strong aria-hidden="true">14.</strong> Collections and Data Structures</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 4: Generic Programming</li><li class="chapter-item expanded "><a href="../chapters/15-generics.html"><strong aria-hidden="true">15.</strong> Introduction to Generics</a></li><li class="chapter-item expanded "><a href="../chapters/16-traits.html"><strong aria-hidden="true">16.</strong> Traits and Polymorphism</a></li><li class="chapter-item expanded "><a href="../chapters/17-advanced-traits.html"><strong aria-hidden="true">17.</strong> Advanced Trait Patterns</a></li><li class="chapter-item expanded "><a href="../chapters/18-lifetimes.html"><strong aria-hidden="true">18.</strong> Understanding Lifetimes</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 5: Error Handling</li><li class="chapter-item expanded "><a href="../chapters/19-panic.html"><strong aria-hidden="true">19.</strong> Panic and Unrecoverable Errors</a></li><li class="chapter-item expanded "><a href="../chapters/20-result-option.html"><strong aria-hidden="true">20.</strong> Result, Option, and Recoverable Errors</a></li><li class="chapter-item expanded "><a href="../chapters/21-error-patterns.html"><strong aria-hidden="true">21.</strong> Error Handling Patterns and Libraries</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 6: Advanced Rust</li><li class="chapter-item expanded "><a href="../chapters/22-iterators.html"><strong aria-hidden="true">22.</strong> Iterators and Functional Programming</a></li><li class="chapter-item expanded "><a href="../chapters/23-closures.html"><strong aria-hidden="true">23.</strong> Closures in Depth</a></li><li class="chapter-item expanded "><a href="../chapters/24-concurrency.html"><strong aria-hidden="true">24.</strong> Concurrency Fundamentals</a></li><li class="chapter-item expanded "><a href="../chapters/25-async.html"><strong aria-hidden="true">25.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="../chapters/26-macros.html"><strong aria-hidden="true">26.</strong> Macros and Metaprogramming</a></li><li class="chapter-item expanded "><a href="../chapters/27-unsafe.html"><strong aria-hidden="true">27.</strong> Unsafe Rust</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 7: Practical Rust</li><li class="chapter-item expanded "><a href="../chapters/28-testing.html" class="active"><strong aria-hidden="true">28.</strong> Writing Tests in Rust</a></li><li class="chapter-item expanded "><a href="../chapters/29-cli.html"><strong aria-hidden="true">29.</strong> Command-Line Applications</a></li><li class="chapter-item expanded "><a href="../chapters/30-web.html"><strong aria-hidden="true">30.</strong> Web Development with Rust</a></li><li class="chapter-item expanded "><a href="../chapters/31-database.html"><strong aria-hidden="true">31.</strong> Database Interaction</a></li><li class="chapter-item expanded "><a href="../chapters/32-network.html"><strong aria-hidden="true">32.</strong> Network Programming</a></li><li class="chapter-item expanded "><a href="../chapters/33-systems.html"><strong aria-hidden="true">33.</strong> Systems Programming</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 8: The Rust Ecosystem</li><li class="chapter-item expanded "><a href="../chapters/34-cargo.html"><strong aria-hidden="true">34.</strong> Package Management with Cargo</a></li><li class="chapter-item expanded "><a href="../chapters/35-build-systems.html"><strong aria-hidden="true">35.</strong> Build Systems and Tooling</a></li><li class="chapter-item expanded "><a href="../chapters/36-performance.html"><strong aria-hidden="true">36.</strong> Performance Optimization</a></li><li class="chapter-item expanded "><a href="../chapters/37-interoperability.html"><strong aria-hidden="true">37.</strong> Interoperability with Other Languages</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 9: Modern Rust Applications</li><li class="chapter-item expanded "><a href="../chapters/38-database-building.html"><strong aria-hidden="true">38.</strong> Building a Database</a></li><li class="chapter-item expanded "><a href="../chapters/39-game-development.html"><strong aria-hidden="true">39.</strong> Game Development</a></li><li class="chapter-item expanded "><a href="../chapters/40-cloud-native.html"><strong aria-hidden="true">40.</strong> Cloud Native Rust</a></li><li class="chapter-item expanded "><a href="../chapters/41-distributed-systems.html"><strong aria-hidden="true">41.</strong> Distributed Systems</a></li><li class="chapter-item expanded "><a href="../chapters/42-machine-learning.html"><strong aria-hidden="true">42.</strong> Machine Learning and Data Science</a></li><li class="chapter-item expanded "><a href="../chapters/43-embedded.html"><strong aria-hidden="true">43.</strong> Embedded Systems and IoT</a></li><li class="chapter-item expanded "><a href="../chapters/44-production-ready.html"><strong aria-hidden="true">44.</strong> Production-Ready Rust</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 10: Capstone Projects</li><li class="chapter-item expanded "><a href="../chapters/45-search-engine.html"><strong aria-hidden="true">45.</strong> Building a Search Engine</a></li><li class="chapter-item expanded "><a href="../chapters/46-programming-language.html"><strong aria-hidden="true">46.</strong> Developing a Programming Language</a></li><li class="chapter-item expanded "><a href="../chapters/47-blockchain.html"><strong aria-hidden="true">47.</strong> Creating a Blockchain Application</a></li><li class="chapter-item expanded "><a href="../chapters/48-data-processing.html"><strong aria-hidden="true">48.</strong> Real-Time Data Processing System</a></li><li class="chapter-item expanded "><a href="../chapters/49-wasm-frontend.html"><strong aria-hidden="true">49.</strong> WebAssembly and Frontend Development</a></li><li class="chapter-item expanded "><a href="../chapters/50-advanced-memory.html"><strong aria-hidden="true">50.</strong> Advanced Memory Management</a></li><li class="chapter-item expanded "><a href="../chapters/51-edge-computing.html"><strong aria-hidden="true">51.</strong> Rust for Edge Computing</a></li><li class="chapter-item expanded "><a href="../chapters/52-security.html"><strong aria-hidden="true">52.</strong> Rust Security Patterns and Auditing</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="../appendices/a-idioms-patterns.html"><strong aria-hidden="true">53.</strong> Common Rust Idioms and Patterns</a></li><li class="chapter-item expanded "><a href="../appendices/b-rust-evolution.html"><strong aria-hidden="true">54.</strong> Rust's Evolution: Editions and Features</a></li><li class="chapter-item expanded "><a href="../appendices/c-language-comparison.html"><strong aria-hidden="true">55.</strong> Comparison with Other Languages</a></li><li class="chapter-item expanded "><a href="../appendices/d-recommended-libraries.html"><strong aria-hidden="true">56.</strong> Recommended Libraries and Crates</a></li><li class="chapter-item expanded "><a href="../appendices/e-memory-model.html"><strong aria-hidden="true">57.</strong> Rust's Memory Model In-Depth</a></li><li class="chapter-item expanded "><a href="../appendices/f-community-resources.html"><strong aria-hidden="true">58.</strong> Community Resources and Contribution Guide</a></li><li class="chapter-item expanded "><a href="../appendices/g-debugging.html"><strong aria-hidden="true">59.</strong> Debugging and Troubleshooting Guide</a></li><li class="chapter-item expanded "><a href="../appendices/h-optimization-cookbook.html"><strong aria-hidden="true">60.</strong> Performance Optimization Cookbook</a></li><li class="chapter-item expanded "><a href="../appendices/i-glossary.html"><strong aria-hidden="true">61.</strong> Comprehensive Glossary</a></li><li class="chapter-item expanded "><a href="../appendices/j-learning-paths.html"><strong aria-hidden="true">62.</strong> Learning Paths for Different Backgrounds</a></li><li class="chapter-item expanded "><a href="../appendices/k-interview-questions.html"><strong aria-hidden="true">63.</strong> Interview Questions and Answers</a></li><li class="chapter-item expanded "><a href="../appendices/l-resources.html"><strong aria-hidden="true">64.</strong> Recommended Reading and Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Universe: Fearless Systems Engineering</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/saeedalam/rust-universe" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/saeedalam/rust-universe/edit/main/src/chapters/28-testing.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-28-writing-tests-in-rust"><a class="header" href="#chapter-28-writing-tests-in-rust">Chapter 28: Writing Tests in Rust</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Testing is an essential practice in software development that helps ensure your code behaves as expected and continues to work correctly as it evolves. Rust takes testing seriously, with built-in support for various testing methodologies directly integrated into the language and its tooling.</p>
<p>Unlike many languages where testing is an afterthought, Rust's approach to testing is both comprehensive and ergonomic. The compiler, cargo, and standard library all work together to make writing and running tests straightforward and efficient. This first-class support reflects Rust's broader commitment to producing reliable, maintainable software.</p>
<p>In this chapter, we'll explore Rust's testing ecosystem in depth. We'll begin with basic unit testing and gradually progress to more advanced testing techniques. You'll learn how to structure tests, mock dependencies, perform property-based testing, and measure the performance of your code through benchmarking. By the end of this chapter, you'll have the knowledge and tools to build robust test suites that give you confidence in your Rust code.</p>
<p>Whether you're developing a small library or a complex application, the testing practices covered in this chapter will help you catch bugs early, document your code's behavior, and maintain a high standard of quality as your project grows.</p>
<h2 id="testing-philosophy-in-rust"><a class="header" href="#testing-philosophy-in-rust">Testing Philosophy in Rust</a></h2>
<p>Before diving into the technical aspects of testing in Rust, it's worth understanding the philosophy that shapes Rust's approach to testing.</p>
<h3 id="safety-beyond-the-compiler"><a class="header" href="#safety-beyond-the-compiler">Safety Beyond the Compiler</a></h3>
<p>Rust's compiler provides strong guarantees about memory safety and thread safety, eliminating entire classes of bugs at compile time. However, logical errors, incorrect business rules, and unexpected edge cases can still exist in perfectly valid Rust code. Testing complements the compiler's checks by verifying that your code's behavior matches your intentions.</p>
<h3 id="testing-as-documentation"><a class="header" href="#testing-as-documentation">Testing as Documentation</a></h3>
<p>Tests serve as executable documentation, demonstrating how code is meant to be used and what results to expect. This is particularly valuable in Rust, where strong type safety and ownership rules can make the correct usage patterns less immediately obvious to newcomers.</p>
<h3 id="the-testing-spectrum"><a class="header" href="#the-testing-spectrum">The Testing Spectrum</a></h3>
<p>Rust supports a spectrum of testing approaches:</p>
<ol>
<li><strong>Unit Tests</strong>: Verify that individual components work in isolation</li>
<li><strong>Integration Tests</strong>: Ensure that components work together correctly</li>
<li><strong>Documentation Tests</strong>: Validate code examples in documentation</li>
<li><strong>Property-Based Tests</strong>: Check that properties of the code hold for many inputs</li>
<li><strong>Benchmarks</strong>: Measure and optimize performance</li>
</ol>
<p>Each approach has its place in a comprehensive testing strategy.</p>
<h3 id="the-rust-testing-mindset"><a class="header" href="#the-rust-testing-mindset">The Rust Testing Mindset</a></h3>
<p>The Rust community generally embraces several testing principles:</p>
<ol>
<li><strong>Test-Driven Development (TDD)</strong>: Many Rustaceans practice writing tests before implementing features.</li>
<li><strong>Fail Fast</strong>: Tests should fail clearly and early when something goes wrong.</li>
<li><strong>Determinism</strong>: Tests should produce the same results consistently.</li>
<li><strong>Isolation</strong>: Tests should not depend on each other or external state.</li>
<li><strong>Completeness</strong>: Aim for high test coverage, especially around error handling and edge cases.</li>
</ol>
<h3 id="when-to-test"><a class="header" href="#when-to-test">When to Test</a></h3>
<p>In Rust, testing is integrated into the development workflow:</p>
<ul>
<li><strong>During Development</strong>: Write tests alongside or before code to clarify requirements.</li>
<li><strong>Before Refactoring</strong>: Ensure you have tests in place before modifying existing code.</li>
<li><strong>After Bug Fixes</strong>: Add tests that reproduce bugs to prevent regressions.</li>
<li><strong>When Publishing</strong>: Verify that your crate works correctly before sharing it with others.</li>
</ul>
<p>With this philosophy in mind, let's explore how Rust makes testing practical and effective.</p>
<h2 id="unit-tests-and-the-test-module"><a class="header" href="#unit-tests-and-the-test-module">Unit Tests and the Test Module</a></h2>
<p>Unit tests verify that individual components of your code work correctly in isolation. In Rust, unit tests are typically placed in the same file as the code they test, inside a special test module.</p>
<h3 id="basic-unit-test-structure"><a class="header" href="#basic-unit-test-structure">Basic Unit Test Structure</a></h3>
<p>Here's a simple example of a unit test in Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A function we want to test
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// The test module
#[cfg(test)]
mod tests {
    // Import the parent module's items
    use super::*;

    // A test function
    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
        assert_eq!(add(-1, 1), 0);
        assert_eq!(add(0, 0), 0);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Let's break down the key elements:</p>
<ol>
<li>
<p><strong><code>#[cfg(test)]</code></strong>: This attribute tells the compiler to only include this module when running tests, not when building your program for regular use.</p>
</li>
<li>
<p><strong><code>mod tests</code></strong>: Convention is to name the test module <code>tests</code>, though you can use any name.</p>
</li>
<li>
<p><strong><code>use super::*</code></strong>: This imports all items from the parent module, making the functions you want to test available within the test module.</p>
</li>
<li>
<p><strong><code>#[test]</code></strong>: This attribute marks a function as a test. When you run <code>cargo test</code>, Rust will find and execute all functions marked with this attribute.</p>
</li>
<li>
<p><strong><code>assert_eq!</code></strong>: A macro that checks if two values are equal. If they're not, the test fails with a helpful error message.</p>
</li>
</ol>
<h3 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h3>
<p>To run your tests, use the <code>cargo test</code> command:</p>
<pre><code class="language-bash">$ cargo test
   Compiling myproject v0.1.0 (/path/to/myproject)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/myproject-1a2b3c4d)

running 1 test
test tests::test_add ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.0s
</code></pre>
<p>This command compiles your code in test mode and runs all the test functions. The output shows which tests passed, which failed, and how long they took to run.</p>
<h3 id="assertion-macros"><a class="header" href="#assertion-macros">Assertion Macros</a></h3>
<p>Rust provides several assertion macros for different testing needs:</p>
<ol>
<li><strong><code>assert!</code></strong>: Checks that a boolean expression is true.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_positive() {
    let result = 42;
    assert!(result &gt; 0);
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong><code>assert_eq!</code></strong>: Checks that two expressions are equal.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_equality() {
    let result = add(2, 2);
    assert_eq!(result, 4);
}
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li><strong><code>assert_ne!</code></strong>: Checks that two expressions are not equal.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_inequality() {
    let result = add(2, 3);
    assert_ne!(result, 4);
}
<span class="boring">}</span></code></pre></pre>
<ol start="4">
<li><strong><code>debug_assert!</code></strong>, <strong><code>debug_assert_eq!</code></strong>, and <strong><code>debug_assert_ne!</code></strong>: These work the same as their non-debug counterparts but are only enabled in debug builds, not in release builds.</li>
</ol>
<h3 id="custom-error-messages"><a class="header" href="#custom-error-messages">Custom Error Messages</a></h3>
<p>All assertion macros accept an optional format string and arguments to provide a custom error message when the assertion fails:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_with_message() {
    let a = 3;
    let b = 5;
    let expected = 8;
    let result = add(a, b);

    assert_eq!(
        result,
        expected,
        &quot;Adding {} and {} should equal {}, but got {}&quot;,
        a, b, expected, result
    );
}
<span class="boring">}</span></code></pre></pre>
<p>This helps make test failures more informative and easier to debug.</p>
<h3 id="testing-for-panics"><a class="header" href="#testing-for-panics">Testing for Panics</a></h3>
<p>Sometimes, you want to verify that your code panics under certain conditions. The <code>#[should_panic]</code> attribute lets you test this behavior:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn divide(a: i32, b: i32) -&gt; i32 {
    if b == 0 {
        panic!(&quot;Cannot divide by zero&quot;);
    }
    a / b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn test_divide_by_zero() {
        divide(10, 0);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For more specific testing, you can check that the panic message contains expected text:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[should_panic(expected = &quot;Cannot divide by zero&quot;)]
fn test_divide_by_zero_message() {
    divide(10, 0);
}
<span class="boring">}</span></code></pre></pre>
<p>This test will only pass if the function panics with a message containing the specified text.</p>
<h3 id="result-based-tests"><a class="header" href="#result-based-tests">Result-Based Tests</a></h3>
<p>Instead of using assertion macros, you can return a <code>Result&lt;(), E&gt;</code> from your test function. This allows for a more concise style, especially when testing functions that return <code>Result</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_config(config: &amp;str) -&gt; Result&lt;u32, String&gt; {
    // Implementation
    if config.is_empty() {
        return Err(&quot;Empty configuration&quot;.to_string());
    }
    Ok(42)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valid_config() -&gt; Result&lt;(), String&gt; {
        let config = &quot;valid_setting=true&quot;;
        let result = parse_config(config)?;
        assert_eq!(result, 42);
        Ok(())
    }

    #[test]
    fn test_empty_config() -&gt; Result&lt;(), String&gt; {
        let result = parse_config(&quot;&quot;);
        assert!(result.is_err());
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this style, the test passes if it returns <code>Ok(())</code> and fails if it returns an <code>Err</code> or panics.</p>
<h3 id="ignoring-tests"><a class="header" href="#ignoring-tests">Ignoring Tests</a></h3>
<p>Sometimes you might want to temporarily disable a test without removing it. The <code>#[ignore]</code> attribute lets you do this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[ignore]
fn expensive_test() {
    // A test that takes a long time to run
}
<span class="boring">}</span></code></pre></pre>
<p>To run only the ignored tests:</p>
<pre><code class="language-bash">$ cargo test -- --ignored
</code></pre>
<p>To run all tests, including ignored ones:</p>
<pre><code class="language-bash">$ cargo test -- --include-ignored
</code></pre>
<h3 id="filtering-tests"><a class="header" href="#filtering-tests">Filtering Tests</a></h3>
<p>You can run a subset of tests by providing a pattern to match against test names:</p>
<pre><code class="language-bash">$ cargo test add  # Runs all tests with &quot;add&quot; in their name
</code></pre>
<p>For more complex filtering, you can use the <code>--exact</code> flag:</p>
<pre><code class="language-bash">$ cargo test test_add -- --exact  # Runs only the test named &quot;test_add&quot;
</code></pre>
<h3 id="private-functions"><a class="header" href="#private-functions">Private Functions</a></h3>
<p>In Rust, you can test private functions directly from the test module, which is a child of the module containing the private functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A private function
fn internal_add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// Public function that uses the private function
pub fn calculate(a: i32, b: i32) -&gt; i32 {
    internal_add(a, b)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_internal_add() {
        // Can access internal_add because tests is a child module
        assert_eq!(internal_add(3, 4), 7);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This ability to test private functions directly is a distinctive feature of Rust's testing approach.</p>
<h2 id="test-organization"><a class="header" href="#test-organization">Test Organization</a></h2>
<p>As your codebase grows, organizing your tests becomes increasingly important. Well-structured tests are easier to maintain, faster to run, and provide clearer feedback when they fail. Let's explore various strategies for organizing tests in Rust.</p>
<h3 id="test-modules-and-files"><a class="header" href="#test-modules-and-files">Test Modules and Files</a></h3>
<p>For small to medium-sized projects, keeping tests in a <code>tests</code> module within each source file is usually sufficient. However, as the number of tests grows, you might want to split them into multiple modules or files.</p>
<h4 id="multiple-test-modules"><a class="header" href="#multiple-test-modules">Multiple Test Modules</a></h4>
<p>You can organize related tests into separate modules within your test module:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    mod basic_operations {
        use super::*;

        #[test]
        fn test_add() {
            assert_eq!(add(2, 3), 5);
        }

        #[test]
        fn test_subtract() {
            assert_eq!(subtract(5, 2), 3);
        }
    }

    mod edge_cases {
        use super::*;

        #[test]
        fn test_zero() {
            assert_eq!(add(0, 0), 0);
        }

        #[test]
        fn test_negative() {
            assert_eq!(add(-1, 1), 0);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This approach keeps related tests together while providing logical separation.</p>
<h4 id="separate-test-files"><a class="header" href="#separate-test-files">Separate Test Files</a></h4>
<p>For very large modules, you might want to move tests to separate files in the same directory:</p>
<pre><code>src/
├── lib.rs
├── math.rs
└── math_tests.rs
</code></pre>
<p>In <code>math_tests.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod math_tests {
    use crate::math::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }

    // More tests...
}
<span class="boring">}</span></code></pre></pre>
<p>This keeps your main code files cleaner but requires you to be careful about visibility and imports.</p>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h3>
<p>While unit tests focus on testing individual components in isolation, integration tests verify that different parts of your code work together correctly. In Rust, integration tests are placed in a separate <code>tests</code> directory at the root of your project:</p>
<pre><code>my_project/
├── Cargo.toml
├── src/
│   ├── lib.rs
│   └── math.rs
└── tests/
    ├── integration_test.rs
    └── utils/
        └── helpers.rs
</code></pre>
<p>Each file in the <code>tests</code> directory (except those in subdirectories) is compiled as a separate crate that depends on your main crate. This ensures that you're testing your code as if it were being used by an external consumer.</p>
<p>Here's an example integration test:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/integration_test.rs

use my_project; // Import your crate

#[test]
fn test_math_operations() {
    let result = my_project::calculate_complex_result(10, 5);
    assert_eq!(result, 42);
}
<span class="boring">}</span></code></pre></pre>
<p>Running <code>cargo test</code> will execute both unit tests and integration tests. To run only integration tests:</p>
<pre><code class="language-bash">$ cargo test --test integration_test
</code></pre>
<h4 id="helper-modules-in-integration-tests"><a class="header" href="#helper-modules-in-integration-tests">Helper Modules in Integration Tests</a></h4>
<p>Files in subdirectories of the <code>tests</code> directory are not treated as test crates, which makes them perfect for shared helper functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/utils/helpers.rs

pub fn setup_test_data() -&gt; Vec&lt;i32&gt; {
    vec![1, 2, 3, 4, 5]
}
<span class="boring">}</span></code></pre></pre>
<p>You can use these helpers in your integration tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/integration_test.rs

mod utils;

use my_project;
use utils::helpers::setup_test_data;

#[test]
fn test_with_helpers() {
    let data = setup_test_data();
    let result = my_project::process_data(&amp;data);
    assert_eq!(result, 15);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="test-conventions-and-naming"><a class="header" href="#test-conventions-and-naming">Test Conventions and Naming</a></h3>
<p>Consistent naming and organization make your tests easier to understand and maintain:</p>
<ol>
<li>
<p><strong>Test Function Names</strong>: Name your test functions clearly and descriptively. Common patterns include:</p>
<ul>
<li><code>test_&lt;function_name&gt;</code>: For testing basic functionality</li>
<li><code>test_&lt;function_name&gt;_&lt;scenario&gt;</code>: For testing specific scenarios</li>
<li><code>test_&lt;behavior_description&gt;</code>: For testing more complex behaviors</li>
</ul>
</li>
<li>
<p><strong>Arrange-Act-Assert Pattern</strong>: Structure the content of your test functions using the AAA pattern:</p>
<ul>
<li><strong>Arrange</strong>: Set up the test data and environment</li>
<li><strong>Act</strong>: Call the function or code being tested</li>
<li><strong>Assert</strong>: Verify the results</li>
</ul>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_process_data_with_empty_input() {
    // Arrange
    let data = Vec::&lt;i32&gt;::new();

    // Act
    let result = process_data(&amp;data);

    // Assert
    assert_eq!(result, 0);
}
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li><strong>Group Related Tests</strong>: Keep tests for related functionality together, either in the same module or using naming conventions.</li>
</ol>
<h3 id="test-data-management"><a class="header" href="#test-data-management">Test Data Management</a></h3>
<p>Managing test data effectively is crucial for maintainable tests:</p>
<h4 id="constants-and-shared-setup"><a class="header" href="#constants-and-shared-setup">Constants and Shared Setup</a></h4>
<p>For data used across multiple tests, consider defining constants or setup functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    // Shared test data
    const TEST_DATA: [i32; 5] = [1, 2, 3, 4, 5];

    fn setup_complex_data() -&gt; Vec&lt;String&gt; {
        vec![&quot;a&quot;.to_string(), &quot;b&quot;.to_string(), &quot;c&quot;.to_string()]
    }

    #[test]
    fn test_sum() {
        let result = sum(&amp;TEST_DATA);
        assert_eq!(result, 15);
    }

    #[test]
    fn test_process_strings() {
        let data = setup_complex_data();
        let result = process_strings(&amp;data);
        assert_eq!(result, &quot;abc&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="using-fixtures"><a class="header" href="#using-fixtures">Using Fixtures</a></h4>
<p>For more complex test environments, you might need to create and tear down resources for each test. While Rust doesn't have built-in fixtures like some testing frameworks, you can implement similar patterns:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TestFixture {
    data: Vec&lt;i32&gt;,
    temp_file: std::path::PathBuf,
}

impl TestFixture {
    fn new() -&gt; Self {
        let data = vec![1, 2, 3, 4, 5];
        let temp_file = std::env::temp_dir().join(&quot;test_file.txt&quot;);
        std::fs::write(&amp;temp_file, &quot;test data&quot;).unwrap();

        TestFixture { data, temp_file }
    }
}

impl Drop for TestFixture {
    fn drop(&amp;mut self) {
        // Clean up resources
        let _ = std::fs::remove_file(&amp;self.temp_file);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_with_fixture() {
        let fixture = TestFixture::new();
        let result = process_with_file(&amp;fixture.data, &amp;fixture.temp_file);
        assert!(result.is_ok());
        // Fixture will be automatically cleaned up when it goes out of scope
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="conditional-compilation-for-tests"><a class="header" href="#conditional-compilation-for-tests">Conditional Compilation for Tests</a></h3>
<p>Sometimes you might need to include code that is only used in tests. The <code>#[cfg(test)]</code> attribute can be used not just for test modules but also for individual items:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ComplexStruct {
    field1: i32,
    field2: String,
    #[cfg(test)]
    test_field: bool, // This field only exists in test builds
}

impl ComplexStruct {
    pub fn new(field1: i32, field2: String) -&gt; Self {
        ComplexStruct {
            field1,
            field2,
            #[cfg(test)]
            test_field: false,
        }
    }

    #[cfg(test)]
    pub fn set_test_field(&amp;mut self, value: bool) {
        self.test_field = value;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This approach allows you to add testing-specific functionality without cluttering your production code.</p>
<h3 id="running-tests-in-parallel"><a class="header" href="#running-tests-in-parallel">Running Tests in Parallel</a></h3>
<p>By default, Rust runs tests in parallel to speed up execution. While this is generally beneficial, it can cause issues if tests depend on shared resources or state.</p>
<p>To run tests sequentially:</p>
<pre><code class="language-bash">$ cargo test -- --test-threads=1
</code></pre>
<p>Alternatively, you can design your tests to be independent and run safely in parallel by:</p>
<ol>
<li>Avoiding shared mutable state</li>
<li>Using unique resources (like file paths) for each test</li>
<li>Using thread-safe synchronization when necessary</li>
</ol>
<h2 id="documentation-tests"><a class="header" href="#documentation-tests">Documentation Tests</a></h2>
<p>One of Rust's most innovative testing features is the ability to run code examples directly from documentation as tests. This ensures that your documentation stays accurate and up-to-date with your code.</p>
<h3 id="writing-documentation-tests"><a class="header" href="#writing-documentation-tests">Writing Documentation Tests</a></h3>
<p>Documentation tests are code blocks in your documentation comments that are executed when you run <code>cargo test</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adds two numbers together.
///
/// # Examples
///
/// ```
/// let result = my_crate::add(2, 3);
/// assert_eq!(result, 5);
/// ```
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<p>When you run <code>cargo test</code>, this example will be compiled and executed as a test. If the assertion fails, the test fails.</p>
<h3 id="documentation-test-benefits"><a class="header" href="#documentation-test-benefits">Documentation Test Benefits</a></h3>
<p>Documentation tests provide several benefits:</p>
<ol>
<li><strong>Verified Examples</strong>: Users can trust that the examples in your documentation actually work.</li>
<li><strong>Automatic Testing</strong>: Documentation is tested alongside your code, not as an afterthought.</li>
<li><strong>Consistency</strong>: Documentation and functionality stay in sync as your code evolves.</li>
<li><strong>Reduced Duplication</strong>: You don't need separate tests for functionality already covered in documentation examples.</li>
</ol>
<h3 id="running-documentation-tests"><a class="header" href="#running-documentation-tests">Running Documentation Tests</a></h3>
<p>Documentation tests are run automatically with <code>cargo test</code>. You can run only the documentation tests with:</p>
<pre><code class="language-bash">$ cargo test --doc
</code></pre>
<h3 id="hiding-code-in-documentation-tests"><a class="header" href="#hiding-code-in-documentation-tests">Hiding Code in Documentation Tests</a></h3>
<p>Sometimes you need setup code in your examples that isn't relevant to the documentation. You can hide lines from the rendered documentation by adding a <code>#</code> at the start of the line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Returns the square of a number.
///
/// # Examples
///
/// ```
/// # use my_crate::square;
/// let result = square(4);
/// assert_eq!(result, 16);
/// ```
pub fn square(n: i32) -&gt; i32 {
    n * n
}
<span class="boring">}</span></code></pre></pre>
<p>In the rendered documentation, users will only see:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = square(4);
assert_eq!(result, 16);
<span class="boring">}</span></code></pre></pre>
<p>The import statement is hidden but still executed when testing.</p>
<h3 id="testing-error-cases"><a class="header" href="#testing-error-cases">Testing Error Cases</a></h3>
<p>You can also test error cases in documentation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Divides two numbers.
///
/// # Examples
///
/// ```
/// let result = my_crate::divide(10, 2);
/// assert_eq!(result, Ok(5));
///
/// let error = my_crate::divide(10, 0);
/// assert!(error.is_err());
/// ```
///
/// # Errors
///
/// Returns an error if the divisor is zero.
pub fn divide(a: i32, b: i32) -&gt; Result&lt;i32, &amp;'static str&gt; {
    if b == 0 {
        Err(&quot;Cannot divide by zero&quot;)
    } else {
        Ok(a / b)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-panicking-code"><a class="header" href="#testing-panicking-code">Testing Panicking Code</a></h3>
<p>If your example is expected to panic, you can tell the documentation tester to expect it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Returns the index of an element in a slice.
///
/// # Examples
///
/// ```
/// let v = vec![10, 20, 30];
/// assert_eq!(my_crate::get_index(&amp;v, 1), 20);
/// ```
///
/// ```should_panic
/// let v = vec![10, 20, 30];
/// my_crate::get_index(&amp;v, 5); // This will panic
/// ```
pub fn get_index(slice: &amp;[i32], index: usize) -&gt; i32 {
    slice[index]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="ignoring-documentation-tests"><a class="header" href="#ignoring-documentation-tests">Ignoring Documentation Tests</a></h3>
<p>If a code example isn't meant to be run as a test, you can mark it to be ignored:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This function does something complex.
///
/// ```ignore
/// // This code won't be tested
/// let result = complex_function(complex_input);
/// ```
pub fn complex_function(input: ComplexType) -&gt; ComplexResult {
    // Implementation
}
<span class="boring">}</span></code></pre></pre>
<p>Other options include:</p>
<ul>
<li><code>no_run</code>: Compile but don't run the example</li>
<li><code>compile_fail</code>: Ensure the example fails to compile</li>
<li><code>edition2018</code>: Specify the Rust edition for the test</li>
</ul>
<h3 id="testing-external-functionality"><a class="header" href="#testing-external-functionality">Testing External Functionality</a></h3>
<p>Documentation tests run in their own environment, so you need to import any external items you use:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Concatenates two strings.
///
/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let s1 = Rc::new(&quot;Hello, &quot;.to_string());
/// let s2 = &quot;world!&quot;.to_string();
/// let result = my_crate::concat_string(s1, s2);
/// assert_eq!(result, &quot;Hello, world!&quot;);
/// ```
pub fn concat_string(s1: std::rc::Rc&lt;String&gt;, s2: String) -&gt; String {
    format!(&quot;{}{}&quot;, s1, s2)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-documentation-tests-effectively"><a class="header" href="#using-documentation-tests-effectively">Using Documentation Tests Effectively</a></h3>
<p>To get the most out of documentation tests:</p>
<ol>
<li><strong>Provide a complete example</strong>: Show initialization, usage, and verification.</li>
<li><strong>Keep examples simple</strong>: Focus on the specific functionality you're documenting.</li>
<li><strong>Cover edge cases</strong>: Demonstrate how your function handles errors or special inputs.</li>
<li><strong>Test complex interactions</strong>: Show how different parts of your API work together.</li>
<li><strong>Structure examples as mini-tutorials</strong>: Guide users through common use cases.</li>
</ol>
<p>Here's an example of a comprehensive documentation test:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A simple key-value store with string keys.
///
/// # Examples
///
/// Creating a new store and adding values:
///
/// ```
/// use my_crate::KeyValueStore;
///
/// let mut store = KeyValueStore::new();
/// store.insert(&quot;key1&quot;, 42);
/// store.insert(&quot;key2&quot;, 100);
///
/// assert_eq!(store.get(&quot;key1&quot;), Some(42));
/// ```
///
/// Handling missing keys:
///
/// ```
/// # use my_crate::KeyValueStore;
/// # let mut store = KeyValueStore::new();
/// assert_eq!(store.get(&quot;nonexistent&quot;), None);
/// ```
///
/// Updating values:
///
/// ```
/// # use my_crate::KeyValueStore;
/// # let mut store = KeyValueStore::new();
/// # store.insert(&quot;key1&quot;, 42);
/// store.insert(&quot;key1&quot;, 100);  // Updates the existing value
/// assert_eq!(store.get(&quot;key1&quot;), Some(100));
/// ```
pub struct KeyValueStore {
    // Implementation details
}

impl KeyValueStore {
    // Implementation methods
}
<span class="boring">}</span></code></pre></pre>
<p>In the next section, we'll explore how to test code that depends on external systems or has complex dependencies using mocking and test doubles.</p>
<h2 id="mocking-and-test-doubles"><a class="header" href="#mocking-and-test-doubles">Mocking and Test Doubles</a></h2>
<p>When testing code with dependencies on external systems or complex components, you often need to substitute these dependencies with simplified versions to enable focused, reliable testing. In testing terminology, these substitutes are called &quot;test doubles.&quot; Mocking is a specific form of test double that allows you to set expectations about how the double will be used.</p>
<h3 id="types-of-test-doubles"><a class="header" href="#types-of-test-doubles">Types of Test Doubles</a></h3>
<p>In Rust testing, you'll encounter several types of test doubles:</p>
<ol>
<li><strong>Dummy Objects</strong>: Placeholder objects passed to satisfy function signatures but never actually used.</li>
<li><strong>Fake Objects</strong>: Simplified working implementations (like an in-memory database instead of a real one).</li>
<li><strong>Stubs</strong>: Provide canned answers to specific calls during tests.</li>
<li><strong>Spies</strong>: Record calls made during tests for later verification.</li>
<li><strong>Mocks</strong>: Pre-programmed with expectations that form a specification of the calls they are expected to receive.</li>
</ol>
<h3 id="approaches-to-test-doubles-in-rust"><a class="header" href="#approaches-to-test-doubles-in-rust">Approaches to Test Doubles in Rust</a></h3>
<p>Unlike some languages that use runtime reflection for mocking, Rust's static type system requires different approaches. Here are the main strategies:</p>
<h4 id="1-trait-based-mocking"><a class="header" href="#1-trait-based-mocking">1. Trait-Based Mocking</a></h4>
<p>The most common approach in Rust is to design your code around traits, then implement those traits with both real and test versions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The trait representing our dependency
pub trait Database {
    fn get_user(&amp;self, id: u64) -&gt; Option&lt;User&gt;;
    fn save_user(&amp;self, user: &amp;User) -&gt; Result&lt;(), String&gt;;
}

// The real implementation
pub struct PostgresDatabase {
    // Implementation details...
}

impl Database for PostgresDatabase {
    fn get_user(&amp;self, id: u64) -&gt; Option&lt;User&gt; {
        // Real implementation that talks to Postgres
    }

    fn save_user(&amp;self, user: &amp;User) -&gt; Result&lt;(), String&gt; {
        // Real implementation
    }
}

// A mock implementation for testing
#[cfg(test)]
pub struct MockDatabase {
    users: std::collections::HashMap&lt;u64, User&gt;,
}

#[cfg(test)]
impl MockDatabase {
    pub fn new() -&gt; Self {
        MockDatabase {
            users: std::collections::HashMap::new(),
        }
    }

    pub fn with_user(mut self, user: User) -&gt; Self {
        self.users.insert(user.id, user);
        self
    }
}

#[cfg(test)]
impl Database for MockDatabase {
    fn get_user(&amp;self, id: u64) -&gt; Option&lt;User&gt; {
        self.users.get(&amp;id).cloned()
    }

    fn save_user(&amp;self, user: &amp;User) -&gt; Result&lt;(), String&gt; {
        // Simplified implementation for testing
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now, your main code can accept any type that implements the <code>Database</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct UserService&lt;D: Database&gt; {
    database: D,
}

impl&lt;D: Database&gt; UserService&lt;D&gt; {
    pub fn new(database: D) -&gt; Self {
        UserService { database }
    }

    pub fn get_user_name(&amp;self, id: u64) -&gt; Option&lt;String&gt; {
        self.database.get_user(id).map(|user| user.name)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And your tests can use the mock implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_user_name() {
        // Create a mock database with a test user
        let mock_db = MockDatabase::new()
            .with_user(User { id: 1, name: &quot;Alice&quot;.to_string() });

        // Create the service with the mock
        let service = UserService::new(mock_db);

        // Test the service
        assert_eq!(service.get_user_name(1), Some(&quot;Alice&quot;.to_string()));
        assert_eq!(service.get_user_name(2), None);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-using-mocking-libraries"><a class="header" href="#2-using-mocking-libraries">2. Using Mocking Libraries</a></h4>
<p>For more complex mocking needs, several libraries are available:</p>
<h5 id="mockall"><a class="header" href="#mockall">mockall</a></h5>
<p><a href="https://crates.io/crates/mockall">mockall</a> is a popular mocking library for Rust that can automatically generate mock implementations for traits:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mockall::predicate::*;
use mockall::*;

#[automock]
pub trait Database {
    fn get_user(&amp;self, id: u64) -&gt; Option&lt;User&gt;;
    fn save_user(&amp;self, user: &amp;User) -&gt; Result&lt;(), String&gt;;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_user() {
        let mut mock = MockDatabase::new();

        // Set up expectations
        mock.expect_get_user()
            .with(eq(1))
            .times(1)
            .returning(|_| Some(User { id: 1, name: &quot;Alice&quot;.to_string() }));

        mock.expect_get_user()
            .with(eq(2))
            .times(1)
            .returning(|_| None);

        // Use the mock
        assert_eq!(mock.get_user(1), Some(User { id: 1, name: &quot;Alice&quot;.to_string() }));
        assert_eq!(mock.get_user(2), None);
    }
}
<span class="boring">}</span></code></pre></pre>
<h5 id="mocktopus"><a class="header" href="#mocktopus">mocktopus</a></h5>
<p><a href="https://crates.io/crates/mocktopus">mocktopus</a> takes a different approach by allowing you to mock individual functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(test, mockable)]
pub fn get_user_from_database(id: u64) -&gt; Option&lt;User&gt; {
    // Real implementation
}

#[cfg(test)]
mod tests {
    use super::*;
    use mocktopus::mocking::*;

    #[test]
    fn test_with_mocked_function() {
        // Mock the function
        get_user_from_database.mock_safe(|id| {
            if id == 1 {
                MockResult::Return(Some(User { id: 1, name: &quot;Alice&quot;.to_string() }))
            } else {
                MockResult::Return(None)
            }
        });

        // Use the mocked function
        assert_eq!(get_user_from_database(1), Some(User { id: 1, name: &quot;Alice&quot;.to_string() }));
        assert_eq!(get_user_from_database(2), None);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-manual-mocking-with-closures"><a class="header" href="#3-manual-mocking-with-closures">3. Manual Mocking with Closures</a></h4>
<p>For simpler cases, you can use closures to create flexible test doubles:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserService&lt;F&gt;
where
    F: Fn(u64) -&gt; Option&lt;User&gt;,
{
    get_user: F,
}

impl&lt;F&gt; UserService&lt;F&gt;
where
    F: Fn(u64) -&gt; Option&lt;User&gt;,
{
    fn new(get_user: F) -&gt; Self {
        UserService { get_user }
    }

    fn get_user_name(&amp;self, id: u64) -&gt; Option&lt;String&gt; {
        (self.get_user)(id).map(|user| user.name)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_user_name_with_closure() {
        // Create a service with a closure that simulates the database
        let service = UserService::new(|id| {
            if id == 1 {
                Some(User { id: 1, name: &quot;Alice&quot;.to_string() })
            } else {
                None
            }
        });

        // Test the service
        assert_eq!(service.get_user_name(1), Some(&quot;Alice&quot;.to_string()));
        assert_eq!(service.get_user_name(2), None);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-asynchronous-code"><a class="header" href="#testing-asynchronous-code">Testing Asynchronous Code</a></h3>
<p>Mocking becomes particularly important when testing asynchronous code. Here's how you can approach it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait AsyncDatabase {
    async fn get_user(&amp;self, id: u64) -&gt; Option&lt;User&gt;;
    async fn save_user(&amp;self, user: &amp;User) -&gt; Result&lt;(), String&gt;;
}

struct MockAsyncDatabase {
    users: std::collections::HashMap&lt;u64, User&gt;,
}

#[async_trait]
impl AsyncDatabase for MockAsyncDatabase {
    async fn get_user(&amp;self, id: u64) -&gt; Option&lt;User&gt; {
        self.users.get(&amp;id).cloned()
    }

    async fn save_user(&amp;self, user: &amp;User) -&gt; Result&lt;(), String&gt; {
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_async_function() {
        let mock_db = MockAsyncDatabase {
            users: {
                let mut map = std::collections::HashMap::new();
                map.insert(1, User { id: 1, name: &quot;Alice&quot;.to_string() });
                map
            },
        };

        let service = AsyncUserService::new(mock_db);
        let result = service.get_user_name(1).await;

        assert_eq!(result, Some(&quot;Alice&quot;.to_string()));
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="best-practices-for-test-doubles"><a class="header" href="#best-practices-for-test-doubles">Best Practices for Test Doubles</a></h3>
<p>When using test doubles in Rust, follow these best practices:</p>
<ol>
<li>
<p><strong>Design for Testability</strong>: Structure your code around traits or other abstractions that can be easily mocked.</p>
</li>
<li>
<p><strong>Mock at the Right Level</strong>: Mock at interface boundaries rather than trying to mock every component.</p>
</li>
<li>
<p><strong>Keep Mocks Simple</strong>: Mocks should only implement the behavior needed for the specific test.</p>
</li>
<li>
<p><strong>Don't Over-Mock</strong>: If a component is simple and has no side effects, consider using the real implementation.</p>
</li>
<li>
<p><strong>Use Dependency Injection</strong>: Make it easy to substitute dependencies in tests by using constructors or builder patterns.</p>
</li>
<li>
<p><strong>Test the Contract</strong>: Ensure that your real implementations and mocks follow the same contract.</p>
</li>
<li>
<p><strong>Consider Using Fakes for Complex Dependencies</strong>: For databases or external APIs, consider writing a simplified in-memory implementation.</p>
</li>
</ol>
<h3 id="testing-http-clients-and-servers"><a class="header" href="#testing-http-clients-and-servers">Testing HTTP Clients and Servers</a></h3>
<p>For testing HTTP clients and servers, specialized mocking tools are available:</p>
<h4 id="http-client-testing-with-mockito"><a class="header" href="#http-client-testing-with-mockito">HTTP Client Testing with mockito</a></h4>
<p><a href="https://crates.io/crates/mockito">mockito</a> is a useful library for mocking HTTP servers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reqwest;

async fn fetch_user(id: u64) -&gt; Result&lt;String, reqwest::Error&gt; {
    let url = format!(&quot;http://api.example.com/users/{}&quot;, id);
    let response = reqwest::get(&amp;url).await?;
    let body = response.text().await?;
    Ok(body)
}

#[cfg(test)]
mod tests {
    use super::*;
    use mockito;

    #[tokio::test]
    async fn test_fetch_user() {
        // Set up the mock server
        let mut server = mockito::Server::new();

        // Create a mock endpoint
        let mock = server.mock(&quot;GET&quot;, &quot;/users/1&quot;)
            .with_status(200)
            .with_header(&quot;content-type&quot;, &quot;application/json&quot;)
            .with_body(r#&quot;{&quot;id&quot;: 1, &quot;name&quot;: &quot;Alice&quot;}&quot;#)
            .create();

        // Override the API URL to use our mock server
        let url = format!(&quot;{}/users/1&quot;, server.url());

        // Test the function
        let body = fetch_user(1).await.unwrap();
        assert_eq!(body, r#&quot;{&quot;id&quot;: 1, &quot;name&quot;: &quot;Alice&quot;}&quot;#);

        // Verify that the endpoint was called
        mock.assert();
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="http-server-testing-with-reqwest"><a class="header" href="#http-server-testing-with-reqwest">HTTP Server Testing with reqwest</a></h4>
<p>For testing HTTP servers, you can use <code>reqwest</code> to make requests to your server:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Assuming you have an HTTP server implementation
async fn start_server() -&gt; impl Future&lt;Output = ()&gt; {
    // Server implementation
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_server() {
        // Start the server in the background
        let server_handle = tokio::spawn(start_server());

        // Wait for the server to start
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

        // Make a request to the server
        let response = reqwest::get(&quot;http://localhost:8080/users/1&quot;).await.unwrap();
        assert_eq!(response.status(), 200);

        let body = response.text().await.unwrap();
        assert_eq!(body, r#&quot;{&quot;id&quot;: 1, &quot;name&quot;: &quot;Alice&quot;}&quot;#);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="creating-specialized-test-environments"><a class="header" href="#creating-specialized-test-environments">Creating Specialized Test Environments</a></h3>
<p>For more complex testing scenarios, you might need to create specialized test environments:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TestEnvironment {
    db: MockDatabase,
    api_client: MockApiClient,
    config: TestConfig,
    temp_dir: tempfile::TempDir,
}

impl TestEnvironment {
    fn new() -&gt; Self {
        let temp_dir = tempfile::tempdir().unwrap();

        TestEnvironment {
            db: MockDatabase::new(),
            api_client: MockApiClient::new(),
            config: TestConfig {
                data_dir: temp_dir.path().to_path_buf(),
                // Other configuration...
            },
            temp_dir,
        }
    }

    fn with_user(mut self, user: User) -&gt; Self {
        self.db = self.db.with_user(user);
        self
    }

    fn with_api_response(mut self, endpoint: &amp;str, response: ApiResponse) -&gt; Self {
        self.api_client = self.api_client.with_response(endpoint, response);
        self
    }

    fn create_service(&amp;self) -&gt; UserService&lt;MockDatabase, MockApiClient&gt; {
        UserService::new(self.db.clone(), self.api_client.clone(), self.config.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_complex_service() {
        let env = TestEnvironment::new()
            .with_user(User { id: 1, name: &quot;Alice&quot;.to_string() })
            .with_api_response(&quot;/status&quot;, ApiResponse::Ok);

        let service = env.create_service();

        let result = service.process_user(1);
        assert!(result.is_ok());
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In the next section, we'll explore property-based testing, a powerful approach that can find edge cases you might not have thought of.</p>
<h2 id="property-based-testing-with-proptest"><a class="header" href="#property-based-testing-with-proptest">Property-Based Testing with proptest</a></h2>
<p>Traditional testing involves writing specific test cases with predefined inputs and expected outputs. While this approach is valuable, it can miss edge cases that you didn't think to test. Property-based testing takes a different approach: instead of testing specific examples, you define properties that should hold true for all inputs, and the testing framework automatically generates diverse test cases to verify these properties.</p>
<h3 id="the-concept-of-property-based-testing"><a class="header" href="#the-concept-of-property-based-testing">The Concept of Property-Based Testing</a></h3>
<p>The core idea of property-based testing is to:</p>
<ol>
<li>Define properties your code should satisfy</li>
<li>Let the testing framework generate random inputs</li>
<li>Verify that the properties hold for all generated inputs</li>
<li>If a failing case is found, automatically reduce it to a minimal counterexample</li>
</ol>
<p>This approach can find bugs that traditional testing might miss, particularly in edge cases or unusual input combinations.</p>
<h3 id="getting-started-with-proptest"><a class="header" href="#getting-started-with-proptest">Getting Started with proptest</a></h3>
<p><a href="https://crates.io/crates/proptest">proptest</a> is the most popular property-based testing framework for Rust. Let's see how to use it:</p>
<p>First, add it to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
proptest = &quot;1.0&quot;
</code></pre>
<p>Now, let's write a simple property test:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proptest::prelude::*;

// Function we want to test
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn test_add_commutative(a in -1000..1000, b in -1000..1000) {
            // Property: addition should be commutative
            prop_assert_eq!(add(a, b), add(b, a));
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This test verifies that addition is commutative (a + b = b + a) for integers in the range -1000 to 1000. proptest will generate hundreds of random test cases to verify this property.</p>
<h3 id="defining-strategies"><a class="header" href="#defining-strategies">Defining Strategies</a></h3>
<p>In property-based testing, a &quot;strategy&quot; defines how to generate random values for your tests. proptest provides strategies for many common types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>proptest! {
    // Integers within ranges
    #[test]
    fn test_with_integers(a in 0..100, b in -50..50) {
        // Test code using a and b
    }

    // Floating point numbers
    #[test]
    fn test_with_floats(x in 0.0..1.0f64) {
        // Test code using x
    }

    // Strings
    #[test]
    fn test_with_strings(s in &quot;\\PC{1,10}&quot;) {
        // Test code using s (1-10 printable characters)
    }

    // Vectors
    #[test]
    fn test_with_vectors(v in prop::collection::vec(0..100, 0..10)) {
        // Test code using v (vector of 0-10 elements, each 0-100)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You can also create custom strategies or combine existing ones:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
struct User {
    id: u64,
    name: String,
    age: u8,
}

proptest! {
    #[test]
    fn test_user_processing(
        // Generate a user with controlled random values
        user in (
            1..1000u64,  // id
            &quot;\\PC{1,20}&quot;,  // name (1-20 printable chars)
            0..120u8,    // age
        ).prop_map(|(id, name, age)| User { id, name, age })
    ) {
        // Test code using the generated user
        let result = process_user(&amp;user);

        // Properties that should hold
        prop_assert!(result.is_ok());
        if let Ok(processed) = result {
            prop_assert_eq!(processed.id, user.id);
            prop_assert!(processed.name.len() &gt; 0);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-properties-of-your-code"><a class="header" href="#testing-properties-of-your-code">Testing Properties of Your Code</a></h3>
<p>The power of property-based testing comes from defining meaningful properties. Here are some common types of properties:</p>
<h4 id="1-invariants"><a class="header" href="#1-invariants">1. Invariants</a></h4>
<p>Properties that should always be true regardless of input:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>proptest! {
    #[test]
    fn absolute_value_is_non_negative(x in any::&lt;i32&gt;()) {
        let abs_x = x.abs();
        prop_assert!(abs_x &gt;= 0);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-roundtrip-properties"><a class="header" href="#2-roundtrip-properties">2. Roundtrip Properties</a></h4>
<p>If you convert data from one form to another and back, you should get the original data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>proptest! {
    #[test]
    fn parse_print_roundtrip(n in 0..10000i32) {
        let s = n.to_string();
        let parsed = s.parse::&lt;i32&gt;().unwrap();
        prop_assert_eq!(n, parsed);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-equivalence-properties"><a class="header" href="#3-equivalence-properties">3. Equivalence Properties</a></h4>
<p>Different ways of computing the same thing should yield the same result:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>proptest! {
    #[test]
    fn sum_is_same_as_fold(
        v in prop::collection::vec(0..100i32, 0..20)
    ) {
        let sum1: i32 = v.iter().sum();
        let sum2: i32 = v.iter().fold(0, |acc, &amp;x| acc + x);
        prop_assert_eq!(sum1, sum2);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="4-model-based-properties"><a class="header" href="#4-model-based-properties">4. Model-Based Properties</a></h4>
<p>Compare your implementation against a simpler, obviously correct (but perhaps less efficient) implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Efficient implementation
fn quick_sort&lt;T: Ord + Clone&gt;(mut v: Vec&lt;T&gt;) -&gt; Vec&lt;T&gt; {
    // Implementation of quick sort
    // ...
    v // Placeholder for the actual implementation
}

proptest! {
    #[test]
    fn quick_sort_same_as_std_sort(
        v in prop::collection::vec(0..1000i32, 0..100)
    ) {
        let mut v_clone = v.clone();
        v_clone.sort();

        let quick_sorted = quick_sort(v);
        prop_assert_eq!(quick_sorted, v_clone);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="handling-test-failures"><a class="header" href="#handling-test-failures">Handling Test Failures</a></h3>
<p>When proptest finds a failing case, it automatically tries to reduce it to a minimal counterexample. This process, called &quot;shrinking,&quot; makes it much easier to understand and fix the issue:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Buggy function that fails for negative numbers
fn buggy_abs(x: i32) -&gt; i32 {
    if x &lt; 0 {
        // Bug: returns negative instead of positive
        x
    } else {
        x
    }
}

proptest! {
    #[test]
    fn abs_is_non_negative(x in any::&lt;i32&gt;()) {
        let abs_x = buggy_abs(x);
        prop_assert!(abs_x &gt;= 0);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>When this test runs, proptest will find a failing case and shrink it to the simplest counterexample (likely -1).</p>
<h3 id="controlling-test-generation"><a class="header" href="#controlling-test-generation">Controlling Test Generation</a></h3>
<p>You can control how proptest generates test cases:</p>
<h4 id="limiting-test-cases"><a class="header" href="#limiting-test-cases">Limiting Test Cases</a></h4>
<p>By default, proptest runs 100 test cases for each property. You can adjust this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proptest::test_runner::Config;

proptest! {
    #![proptest_config(Config::with_cases(500))]
    #[test]
    fn more_thorough_test(x in any::&lt;i32&gt;()) {
        // This will run 500 test cases
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="filtering-generated-values"><a class="header" href="#filtering-generated-values">Filtering Generated Values</a></h4>
<p>You can filter the generated values to focus on cases you're interested in:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>proptest! {
    #[test]
    fn test_even_numbers(x in any::&lt;i32&gt;().prop_filter(
        &quot;x must be even&quot;, |x| x % 2 == 0
    )) {
        // x is guaranteed to be even
        prop_assert_eq!(x % 2, 0);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>However, be careful with filtering—if your filter is too restrictive, proptest may struggle to generate enough valid examples.</p>
<h4 id="deterministic-tests"><a class="header" href="#deterministic-tests">Deterministic Tests</a></h4>
<p>For reproducible tests, you can specify a random seed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>proptest! {
    #![proptest_config(Config::with_cases(100).with_rng_seed(12345))]
    #[test]
    fn deterministic_test(x in any::&lt;i32&gt;()) {
        // This will always generate the same test cases
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="complex-property-testing-examples"><a class="header" href="#complex-property-testing-examples">Complex Property Testing Examples</a></h3>
<p>Let's look at some more complex examples of property-based testing:</p>
<h4 id="testing-a-sorting-algorithm"><a class="header" href="#testing-a-sorting-algorithm">Testing a Sorting Algorithm</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn insertion_sort&lt;T: Ord + Clone&gt;(mut v: Vec&lt;T&gt;) -&gt; Vec&lt;T&gt; {
    for i in 1..v.len() {
        let mut j = i;
        while j &gt; 0 &amp;&amp; v[j - 1] &gt; v[j] {
            v.swap(j - 1, j);
            j -= 1;
        }
    }
    v
}

proptest! {
    #[test]
    fn sort_produces_ordered_result(
        v in prop::collection::vec(0..1000i32, 0..100)
    ) {
        let sorted = insertion_sort(v);

        // Property 1: Result should be ordered
        for i in 1..sorted.len() {
            prop_assert!(sorted[i-1] &lt;= sorted[i]);
        }
    }

    #[test]
    fn sort_preserves_elements(
        v in prop::collection::vec(-100..100i32, 0..20)
    ) {
        let orig = v.clone();
        let sorted = insertion_sort(v);

        // Property 2: Sorting should preserve all elements
        prop_assert_eq!(orig.len(), sorted.len());

        let mut orig_counts = std::collections::HashMap::new();
        let mut sorted_counts = std::collections::HashMap::new();

        for &amp;x in &amp;orig {
            *orig_counts.entry(x).or_insert(0) += 1;
        }

        for &amp;x in &amp;sorted {
            *sorted_counts.entry(x).or_insert(0) += 1;
        }

        prop_assert_eq!(orig_counts, sorted_counts);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="testing-a-parser"><a class="header" href="#testing-a-parser">Testing a Parser</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum JsonValue {
    Null,
    Bool(bool),
    Number(f64),
    String(String),
    Array(Vec&lt;JsonValue&gt;),
    Object(std::collections::HashMap&lt;String, JsonValue&gt;),
}

fn parse_json(input: &amp;str) -&gt; Result&lt;JsonValue, String&gt; {
    // Implementation of JSON parser
    // ...
    Err(&quot;Not implemented&quot;.to_string()) // Placeholder
}

fn stringify_json(value: &amp;JsonValue) -&gt; String {
    // Implementation of JSON stringifier
    // ...
    &quot;&quot;.to_string() // Placeholder
}

proptest! {
    #[test]
    fn json_roundtrip(
        // Generate a simple JSON value
        value in prop_oneof![
            Just(JsonValue::Null),
            any::&lt;bool&gt;().prop_map(JsonValue::Bool),
            any::&lt;f64&gt;().prop_map(JsonValue::Number),
            &quot;\\PC{0,20}&quot;.prop_map(JsonValue::String),
            prop::collection::vec(Just(JsonValue::Null), 0..5)
                .prop_map(JsonValue::Array)
        ]
    ) {
        let json_str = stringify_json(&amp;value);
        let parsed = parse_json(&amp;json_str)?;

        // Comparing complex structures directly can be tricky
        // Here's a simplified approach
        let round_trip_str = stringify_json(&amp;parsed);
        prop_assert_eq!(json_str, round_trip_str);

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="combining-proptest-with-other-testing-approaches"><a class="header" href="#combining-proptest-with-other-testing-approaches">Combining proptest with Other Testing Approaches</a></h3>
<p>Property-based testing complements, rather than replaces, other testing approaches. A comprehensive testing strategy might include:</p>
<ol>
<li><strong>Unit tests</strong> for specific cases and edge conditions</li>
<li><strong>Property tests</strong> to find unexpected edge cases and validate broader properties</li>
<li><strong>Integration tests</strong> to verify that components work together correctly</li>
<li><strong>Benchmarks</strong> to ensure performance meets requirements</li>
</ol>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;

    // Traditional unit tests
    #[test]
    fn test_specific_cases() {
        assert_eq!(process_data(&amp;[1, 2, 3]), Ok(6));
        assert_eq!(process_data(&amp;[]), Ok(0));
        assert!(process_data(&amp;[-1]).is_err());
    }

    // Property-based tests
    proptest! {
        #[test]
        fn process_data_properties(
            v in prop::collection::vec(0..100i32, 0..20)
        ) {
            let result = process_data(&amp;v);

            // Should succeed for all non-negative inputs
            prop_assert!(result.is_ok());

            // Sum should be greater than or equal to largest element
            if let Ok(sum) = result {
                if let Some(&amp;max) = v.iter().max() {
                    prop_assert!(sum &gt;= max);
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="best-practices-for-property-based-testing"><a class="header" href="#best-practices-for-property-based-testing">Best Practices for Property-Based Testing</a></h3>
<p>To get the most out of property-based testing:</p>
<ol>
<li>
<p><strong>Focus on properties, not examples</strong>: Think about what invariants, equivalences, or roundtrip properties your code should satisfy.</p>
</li>
<li>
<p><strong>Start simple</strong>: Begin with basic properties and gradually add more complex ones.</p>
</li>
<li>
<p><strong>Combine with traditional tests</strong>: Use traditional tests for known edge cases and property tests for exploring the space of possible inputs.</p>
</li>
<li>
<p><strong>Don't filter too aggressively</strong>: If you're filtering out most generated values, consider restructuring your strategy instead.</p>
</li>
<li>
<p><strong>Pay attention to performance</strong>: Property tests run many examples, so make sure your test code is efficient.</p>
</li>
<li>
<p><strong>Use shrinking effectively</strong>: When a test fails, proptest will try to find the simplest failing case. Examine this case carefully to understand the root cause.</p>
</li>
<li>
<p><strong>Consider model-based testing</strong>: Comparing against a simpler but correct implementation is a powerful approach to finding bugs.</p>
</li>
</ol>
<p>In the next section, we'll explore benchmarking in Rust, which helps you measure and optimize the performance of your code.</p>
<h2 id="benchmarking-with-criterion"><a class="header" href="#benchmarking-with-criterion">Benchmarking with criterion</a></h2>
<p>Testing ensures your code works correctly, but it doesn't tell you how fast it runs. Benchmarking fills this gap by measuring your code's performance, helping you identify bottlenecks and validate optimizations.</p>
<h3 id="introduction-to-benchmarking-in-rust"><a class="header" href="#introduction-to-benchmarking-in-rust">Introduction to Benchmarking in Rust</a></h3>
<p>While Rust's standard library includes a benchmarking framework, it's only available in nightly Rust. For stable Rust, <a href="https://crates.io/crates/criterion">criterion</a> is the most widely used benchmarking library. Criterion provides robust, statistically sound benchmarks with detailed analysis and pretty reports.</p>
<h3 id="setting-up-criterion"><a class="header" href="#setting-up-criterion">Setting Up criterion</a></h3>
<p>First, add criterion to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
criterion = &quot;0.4&quot;

[[bench]]
name = &quot;my_benchmark&quot;
harness = false
</code></pre>
<p>Next, create a benchmark file at <code>benches/my_benchmark.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use criterion::{black_box, criterion_group, criterion_main, Criterion};

// Function we want to benchmark
fn fibonacci(n: u64) -&gt; u64 {
    match n {
        0 =&gt; 0,
        1 =&gt; 1,
        n =&gt; fibonacci(n - 1) + fibonacci(n - 2),
    }
}

fn bench_fibonacci(c: &amp;mut Criterion) {
    c.bench_function(&quot;fibonacci 20&quot;, |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, bench_fibonacci);
criterion_main!(benches);
<span class="boring">}</span></code></pre></pre>
<p>Now run your benchmark:</p>
<pre><code class="language-bash">$ cargo bench
</code></pre>
<p>Criterion will run your benchmark, analyze the results, and generate a report showing how long your function took to execute.</p>
<h3 id="understanding-criterion-output"><a class="header" href="#understanding-criterion-output">Understanding Criterion Output</a></h3>
<p>Criterion produces detailed output with statistical analysis:</p>
<pre><code>fibonacci 20             time:   [21.518 ms 21.612 ms 21.714 ms]
</code></pre>
<p>This shows the:</p>
<ul>
<li>Lower bound of the confidence interval (21.518 ms)</li>
<li>Point estimate (21.612 ms)</li>
<li>Upper bound of the confidence interval (21.714 ms)</li>
</ul>
<p>Criterion also generates HTML reports with charts in the <code>target/criterion</code> directory, which you can open in a web browser for more detailed analysis.</p>
<h3 id="writing-effective-benchmarks"><a class="header" href="#writing-effective-benchmarks">Writing Effective Benchmarks</a></h3>
<p>Here are some patterns for effective benchmarking:</p>
<h4 id="benchmarking-functions-with-input-parameters"><a class="header" href="#benchmarking-functions-with-input-parameters">Benchmarking Functions with Input Parameters</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bench_fibonacci(c: &amp;mut Criterion) {
    let mut group = c.benchmark_group(&quot;fibonacci&quot;);
    for i in [5, 10, 15, 20].iter() {
        group.bench_with_input(format!(&quot;fibonacci {}&quot;, i), i, |b, &amp;i| {
            b.iter(|| fibonacci(black_box(i)))
        });
    }
    group.finish();
}
<span class="boring">}</span></code></pre></pre>
<p>This benchmarks <code>fibonacci</code> with different inputs, showing how performance scales with input size.</p>
<h4 id="benchmarking-multiple-implementations"><a class="header" href="#benchmarking-multiple-implementations">Benchmarking Multiple Implementations</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Recursive implementation
fn fibonacci_recursive(n: u64) -&gt; u64 {
    match n {
        0 =&gt; 0,
        1 =&gt; 1,
        n =&gt; fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2),
    }
}

// Iterative implementation
fn fibonacci_iterative(n: u64) -&gt; u64 {
    let mut a = 0;
    let mut b = 1;
    for _ in 0..n {
        let c = a + b;
        a = b;
        b = c;
    }
    a
}

fn compare_fibonacci_implementations(c: &amp;mut Criterion) {
    let mut group = c.benchmark_group(&quot;fibonacci&quot;);

    for i in [20, 25, 30].iter() {
        group.bench_with_input(format!(&quot;recursive {}&quot;, i), i, |b, &amp;i| {
            b.iter(|| fibonacci_recursive(black_box(i)))
        });

        group.bench_with_input(format!(&quot;iterative {}&quot;, i), i, |b, &amp;i| {
            b.iter(|| fibonacci_iterative(black_box(i)))
        });
    }

    group.finish();
}
<span class="boring">}</span></code></pre></pre>
<p>This compares recursive and iterative implementations, helping you choose the more efficient approach.</p>
<h4 id="benchmarking-setup-and-cleanup"><a class="header" href="#benchmarking-setup-and-cleanup">Benchmarking Setup and Cleanup</a></h4>
<p>Sometimes you need to prepare data before benchmarking or clean up afterward:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bench_sort(c: &amp;mut Criterion) {
    let mut group = c.benchmark_group(&quot;sort&quot;);

    group.bench_function(&quot;sort 1000 elements&quot;, |b| {
        b.iter_batched(
            // Setup (executed before each iteration)
            || {
                let mut data: Vec&lt;i32&gt; = (0..1000).collect();
                data.shuffle(&amp;mut rand::thread_rng());
                data
            },
            // Benchmark (executed during measurement)
            |mut data| {
                data.sort();
                data
            },
            // Batch size (how often to run setup)
            criterion::BatchSize::SmallInput,
        )
    });

    group.finish();
}
<span class="boring">}</span></code></pre></pre>
<p>This approach ensures that setup and cleanup time doesn't affect your measurements.</p>
<h3 id="advanced-benchmarking-techniques"><a class="header" href="#advanced-benchmarking-techniques">Advanced Benchmarking Techniques</a></h3>
<h4 id="parameterized-benchmarks"><a class="header" href="#parameterized-benchmarks">Parameterized Benchmarks</a></h4>
<p>You can use parameterized benchmarks to explore how performance varies with different inputs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bench_sorting(c: &amp;mut Criterion) {
    let sizes = [10, 100, 1000, 10000];
    let mut group = c.benchmark_group(&quot;sorting&quot;);

    for size in sizes.iter() {
        group.throughput(criterion::Throughput::Elements(*size as u64));

        group.bench_with_input(format!(&quot;sort {}&quot;, size), size, |b, &amp;size| {
            b.iter_batched(
                || {
                    let mut data: Vec&lt;i32&gt; = (0..size).collect();
                    data.shuffle(&amp;mut rand::thread_rng());
                    data
                },
                |mut data| {
                    data.sort();
                    data
                },
                criterion::BatchSize::SmallInput,
            )
        });
    }

    group.finish();
}
<span class="boring">}</span></code></pre></pre>
<p>This measures not just time but throughput (elements sorted per second), which helps you understand scaling behavior.</p>
<h4 id="measuring-memory-usage"><a class="header" href="#measuring-memory-usage">Measuring Memory Usage</a></h4>
<p>Criterion focuses on time measurements, but you might also want to measure memory usage. For this, you'd need additional tools like <code>heaptrack</code> or custom instrumentation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn memory_usage&lt;F, T&gt;(f: F) -&gt; (T, usize)
where
    F: FnOnce() -&gt; T,
{
    // Record memory before
    let before = std::mem::size_of::&lt;usize&gt;() * 8; // Simplified example

    // Run the function
    let result = f();

    // Record memory after
    let after = std::mem::size_of::&lt;usize&gt;() * 16; // Simplified example

    (result, after - before)
}

#[test]
fn test_vector_memory() {
    let (vec, bytes) = memory_usage(|| {
        let mut vec = Vec::new();
        for i in 0..1000 {
            vec.push(i);
        }
        vec
    });

    println!(&quot;Created vector of size {} using {} bytes&quot;, vec.len(), bytes);
}
<span class="boring">}</span></code></pre></pre>
<p>This is a simplified example—real memory profiling typically requires OS-specific tools or libraries.</p>
<h3 id="benchmarking-best-practices"><a class="header" href="#benchmarking-best-practices">Benchmarking Best Practices</a></h3>
<p>To get reliable, useful benchmarks:</p>
<ol>
<li>
<p><strong>Ensure Stable Environment</strong>: Run benchmarks on a consistent, quiet system. Close other applications and disable power management features that might affect CPU speed.</p>
</li>
<li>
<p><strong>Use <code>black_box</code></strong>: This prevents the compiler from optimizing away your benchmark code.</p>
</li>
<li>
<p><strong>Benchmark Real-World Scenarios</strong>: Test with realistic data sizes and patterns.</p>
</li>
<li>
<p><strong>Compare Like with Like</strong>: When comparing implementations, ensure they solve exactly the same problem.</p>
</li>
<li>
<p><strong>Look Beyond Averages</strong>: Pay attention to variance and outliers in your benchmark results.</p>
</li>
<li>
<p><strong>Avoid Microbenchmarking Pitfalls</strong>: Very short functions might be dominated by measurement overhead.</p>
</li>
<li>
<p><strong>Profile Before Optimizing</strong>: Use profiling tools to identify actual bottlenecks before benchmarking.</p>
</li>
</ol>
<h3 id="continuous-benchmarking"><a class="header" href="#continuous-benchmarking">Continuous Benchmarking</a></h3>
<p>For long-term performance tracking, integrate benchmarking into your continuous integration:</p>
<ol>
<li>
<p><strong>Store Benchmark Results</strong>: Save results in a database or log file.</p>
</li>
<li>
<p><strong>Track Changes Over Time</strong>: Plot performance metrics across versions.</p>
</li>
<li>
<p><strong>Set Performance Budgets</strong>: Establish thresholds for acceptable performance.</p>
</li>
<li>
<p><strong>Automatic Regression Detection</strong>: Configure CI to fail if performance degrades beyond a threshold.</p>
</li>
</ol>
<p>Here's a simplified example using GitHub Actions:</p>
<pre><code class="language-yaml"># .github/workflows/benchmark.yml
name: Benchmark

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  benchmark:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true
      - name: Run benchmarks
        run: cargo bench
      - name: Store benchmark results
        uses: actions/upload-artifact@v2
        with:
          name: benchmark-results
          path: target/criterion
</code></pre>
<h3 id="benchmarking-async-code"><a class="header" href="#benchmarking-async-code">Benchmarking Async Code</a></h3>
<p>Benchmarking asynchronous code requires special handling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use criterion::{black_box, criterion_group, criterion_main, Criterion};
use tokio::runtime::Runtime;

async fn async_function(n: u64) -&gt; u64 {
    // Simulate some async work
    tokio::time::sleep(std::time::Duration::from_millis(1)).await;
    n * 2
}

fn bench_async(c: &amp;mut Criterion) {
    let rt = Runtime::new().unwrap();

    c.bench_function(&quot;async function&quot;, |b| {
        b.to_async(&amp;rt).iter(|| async_function(black_box(42)))
    });
}

criterion_group!(benches, bench_async);
criterion_main!(benches);
<span class="boring">}</span></code></pre></pre>
<p>This creates a Tokio runtime and uses criterion's async benchmarking support to measure async functions.</p>
<h3 id="combining-testing-and-benchmarking"><a class="header" href="#combining-testing-and-benchmarking">Combining Testing and Benchmarking</a></h3>
<p>A comprehensive approach combines testing and benchmarking:</p>
<ol>
<li><strong>Write tests to verify correctness</strong></li>
<li><strong>Write benchmarks to measure performance</strong></li>
<li><strong>Use property tests to explore the behavior space</strong></li>
<li><strong>Use benchmarks to compare alternative implementations</strong></li>
</ol>
<p>For example, when implementing a sorting algorithm:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// First, test correctness
#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;

    #[test]
    fn test_specific_cases() {
        assert_eq!(my_sort(&amp;mut [3, 1, 2]), &amp;mut [1, 2, 3]);
        assert_eq!(my_sort(&amp;mut []), &amp;mut []);
    }

    proptest! {
        #[test]
        fn test_sort_properties(mut v in prop::collection::vec(0..100i32, 0..100)) {
            let mut v_clone = v.clone();
            v_clone.sort();

            my_sort(&amp;mut v);
            prop_assert_eq!(v, v_clone);
        }
    }
}

// Then, benchmark performance
fn bench_sorting(c: &amp;mut Criterion) {
    let mut group = c.benchmark_group(&quot;sorting&quot;);

    group.bench_function(&quot;my_sort&quot;, |b| {
        b.iter_batched(
            || {
                let mut data: Vec&lt;i32&gt; = (0..1000).collect();
                data.shuffle(&amp;mut rand::thread_rng());
                data
            },
            |mut data| {
                my_sort(&amp;mut data);
                data
            },
            criterion::BatchSize::SmallInput,
        )
    });

    group.bench_function(&quot;std_sort&quot;, |b| {
        b.iter_batched(
            || {
                let mut data: Vec&lt;i32&gt; = (0..1000).collect();
                data.shuffle(&amp;mut rand::thread_rng());
                data
            },
            |mut data| {
                data.sort();
                data
            },
            criterion::BatchSize::SmallInput,
        )
    });

    group.finish();
}
<span class="boring">}</span></code></pre></pre>
<p>This approach ensures your implementation is both correct and efficient.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this chapter, we've explored Rust's comprehensive testing ecosystem, from basic unit tests to advanced property-based testing and benchmarking. We've learned:</p>
<ul>
<li>How to write unit tests using Rust's built-in testing framework</li>
<li>Strategies for organizing tests in growing codebases</li>
<li>How to write integration tests to verify that components work together</li>
<li>The power of documentation tests to keep examples accurate and up-to-date</li>
<li>Techniques for mocking dependencies in tests</li>
<li>How property-based testing can find edge cases you might not have thought of</li>
<li>Methods for benchmarking and measuring performance with criterion</li>
</ul>
<p>Testing is a fundamental aspect of Rust development, and the language's first-class support for testing reflects its emphasis on reliability and correctness. By incorporating these testing practices into your workflow, you'll write more robust, maintainable Rust code with fewer bugs and better performance.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<h3 id="exercise-1-unit-test-practice"><a class="header" href="#exercise-1-unit-test-practice">Exercise 1: Unit Test Practice</a></h3>
<p>Create a library crate with functions for basic operations on a <code>User</code> struct. Write comprehensive unit tests for each function, covering:</p>
<ul>
<li>Normal cases</li>
<li>Edge cases</li>
<li>Error handling</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example structure to start with
pub struct User {
    id: u64,
    name: String,
    email: String,
    active: bool,
}

// Implement these functions with proper error handling
pub fn create_user(name: &amp;str, email: &amp;str) -&gt; Result&lt;User, String&gt; {
    // Implementation
}

pub fn validate_email(email: &amp;str) -&gt; bool {
    // Implementation
}

pub fn deactivate_user(user: &amp;mut User) {
    // Implementation
}

// Then write tests for each function
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-2-integration-testing"><a class="header" href="#exercise-2-integration-testing">Exercise 2: Integration Testing</a></h3>
<p>Expand the library from Exercise 1 to include a <code>UserRepository</code> trait with two implementations:</p>
<ol>
<li>An in-memory implementation for testing</li>
<li>A file-based implementation for real usage</li>
</ol>
<p>Write integration tests that verify both implementations work correctly with the same test cases.</p>
<h3 id="exercise-3-property-based-testing"><a class="header" href="#exercise-3-property-based-testing">Exercise 3: Property-Based Testing</a></h3>
<p>Using proptest, write property-based tests for a function that parses and validates a configuration file format. Define properties such as:</p>
<ul>
<li>If a configuration is valid, serializing and deserializing it should give the same result</li>
<li>Certain fields must be within specific ranges</li>
<li>Required fields must be present</li>
</ul>
<h3 id="exercise-4-benchmarking-different-algorithms"><a class="header" href="#exercise-4-benchmarking-different-algorithms">Exercise 4: Benchmarking Different Algorithms</a></h3>
<p>Implement two different algorithms for finding the nth Fibonacci number:</p>
<ol>
<li>Recursive implementation</li>
<li>Iterative implementation</li>
</ol>
<p>Write benchmarks using criterion to compare their performance with different input sizes. Create a nice visualization of the results.</p>
<h3 id="exercise-5-test-driven-development-project"><a class="header" href="#exercise-5-test-driven-development-project">Exercise 5: Test-Driven Development Project</a></h3>
<p>Using Test-Driven Development, build a simple command-line todo application. For each feature:</p>
<ol>
<li>Write tests first</li>
<li>Implement the minimal code to pass the tests</li>
<li>Refactor while keeping tests passing</li>
</ol>
<p>Features to implement:</p>
<ul>
<li>Adding items</li>
<li>Marking items as complete</li>
<li>Listing items (all, active, completed)</li>
<li>Deleting items</li>
<li>Saving and loading from a file</li>
</ul>
<p>This exercise will help you experience the full TDD workflow while building a practical application.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapters/27-unsafe.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapters/29-cli.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapters/27-unsafe.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapters/29-cli.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
