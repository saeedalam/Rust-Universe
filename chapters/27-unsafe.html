<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unsafe Rust - Rust Universe: Fearless Systems Engineering</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to learning the Rust programming language from fundamentals to mastery.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Universe: Fearless Systems Engineering</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/saeedalam/rust-universe" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/saeedalam/rust-universe/edit/main/src/chapters/27-unsafe.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-27-unsafe-rust"><a class="header" href="#chapter-27-unsafe-rust">Chapter 27: Unsafe Rust</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>In previous chapters, we’ve explored Rust’s rich type system, ownership model, and safety guarantees. We’ve seen how Rust’s compiler enforces memory safety, prevents data races, and eliminates many classes of bugs at compile time. However, there are situations where Rust’s strict rules become limiting—when you need to interface with C libraries, implement low-level system components, or optimize critical performance bottlenecks.</p>
<p>This is where <strong>unsafe Rust</strong> comes in. Unsafe code gives you additional capabilities that the safe subset of Rust prohibits, letting you bypass some of the compiler’s safety checks when necessary. With this power comes responsibility: when you use <code>unsafe</code>, you’re telling the compiler, “Trust me, I know what I’m doing.”</p>
<p>In this chapter, we’ll explore:</p>
<ul>
<li>Why unsafe code exists and when to use it</li>
<li>The unsafe superpowers and their implications</li>
<li>How to write, audit, and test unsafe code</li>
<li>Techniques for building safe abstractions around unsafe code</li>
<li>Common patterns and best practices</li>
</ul>
<p>Remember, unsafe code doesn’t mean incorrect or dangerous code—it means code where safety is verified by the programmer rather than the compiler. Learning to use unsafe Rust correctly is an important skill for systems programmers and anyone building performance-critical applications.</p>
<p>Let’s dive in and explore the uncharted territories of unsafe Rust.</p>
<h2 id="when-and-why-to-use-unsafe"><a class="header" href="#when-and-why-to-use-unsafe">When and Why to Use Unsafe</a></h2>
<p>Unsafe Rust exists for practical reasons. While Rust’s safety guarantees are powerful, they come with limitations. Sometimes, you need capabilities that safe Rust cannot provide, or the compiler’s strict rules prevent you from implementing certain patterns efficiently.</p>
<h3 id="the-unsafe-superpowers"><a class="header" href="#the-unsafe-superpowers">The Unsafe Superpowers</a></h3>
<p>When you use the <code>unsafe</code> keyword, you gain access to four “superpowers” that are otherwise unavailable:</p>
<ol>
<li><strong>Dereferencing raw pointers</strong>: You can directly access memory through raw pointers (<code>*const T</code> and <code>*mut T</code>).</li>
<li><strong>Calling unsafe functions</strong>: You can call functions marked with the <code>unsafe</code> keyword.</li>
<li><strong>Implementing unsafe traits</strong>: You can implement traits marked as <code>unsafe</code>.</li>
<li><strong>Accessing or modifying mutable static variables</strong>: You can work with global mutable state.</li>
<li><strong>Accessing fields of unions</strong>: You can read from or write to fields of unions.</li>
</ol>
<p>These capabilities are powerful but bypass Rust’s safety checks, which is why they require the <code>unsafe</code> keyword.</p>
<h3 id="legitimate-use-cases-for-unsafe-code"><a class="header" href="#legitimate-use-cases-for-unsafe-code">Legitimate Use Cases for Unsafe Code</a></h3>
<p>Here are some scenarios where unsafe code is necessary or appropriate:</p>
<h4 id="1-foreign-function-interface-ffi"><a class="header" href="#1-foreign-function-interface-ffi">1. Foreign Function Interface (FFI)</a></h4>
<p>When interfacing with code written in other languages like C or C++, you’ll need unsafe code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "C" {
    // Declaration of a C function
    fn c_function(arg: i32) -&gt; i32;
}

fn call_c_code() -&gt; i32 {
    // Calling a foreign function is unsafe
    unsafe {
        c_function(42)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>FFI is one of the most common reasons for using unsafe code, as it allows Rust programs to utilize existing libraries and operating system APIs.</p>
<h4 id="2-low-level-system-programming"><a class="header" href="#2-low-level-system-programming">2. Low-Level System Programming</a></h4>
<p>Some low-level operations simply can’t be expressed in safe Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Getting a raw pointer to a memory-mapped device register
let device_register: *mut u32 = 0x4000_1000 as *mut u32;

// Writing to the register
unsafe {
    *device_register = 0x1;
}
<span class="boring">}</span></code></pre></pre>
<p>Device drivers, operating system kernels, and embedded systems often require direct manipulation of memory addresses.</p>
<h4 id="3-performance-critical-code"><a class="header" href="#3-performance-critical-code">3. Performance-Critical Code</a></h4>
<p>In rare cases, you might need unsafe code to implement performance optimizations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn copy_memory(src: &amp;[u8], dst: &amp;mut [u8]) {
    assert!(dst.len() &gt;= src.len());

    unsafe {
        std::ptr::copy_nonoverlapping(
            src.as_ptr(),
            dst.as_mut_ptr(),
            src.len()
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, we’re using <code>copy_nonoverlapping</code> for a potentially faster memory copy than what would be achieved with a simple loop.</p>
<h4 id="4-implementing-data-structures-with-complex-invariants"><a class="header" href="#4-implementing-data-structures-with-complex-invariants">4. Implementing Data Structures with Complex Invariants</a></h4>
<p>Some advanced data structures have invariants that cannot be expressed through Rust’s type system alone:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CustomVec&lt;T&gt; {
    ptr: *mut T,
    capacity: usize,
    length: usize,
}

impl&lt;T&gt; CustomVec&lt;T&gt; {
    // Various methods using unsafe code to manage the buffer
}
<span class="boring">}</span></code></pre></pre>
<p>Implementing custom collections like vectors, linked lists, or trees often requires unsafe code to manage memory efficiently.</p>
<h4 id="5-using-platform-specific-features"><a class="header" href="#5-using-platform-specific-features">5. Using Platform-Specific Features</a></h4>
<p>Some platform-specific optimizations or intrinsics are only available through unsafe code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_arch = "x86_64")]
use std::arch::x86_64::*;

// Using SIMD instructions for vectorized computation
fn sum_f32_simd(data: &amp;[f32]) -&gt; f32 {
    // Safety: we're checking that SIMD is supported
    if is_x86_feature_detected!("avx2") {
        return unsafe { sum_f32_simd_avx2(data) };
    }

    // Fallback implementation
    data.iter().sum()
}

#[target_feature(enable = "avx2")]
unsafe fn sum_f32_simd_avx2(data: &amp;[f32]) -&gt; f32 {
    // SIMD implementation using AVX2 instructions
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="when-not-to-use-unsafe"><a class="header" href="#when-not-to-use-unsafe">When Not to Use Unsafe</a></h3>
<p>Unsafe code should be a last resort, not a first choice. Avoid unsafe code when:</p>
<ol>
<li><strong>You’re just trying to bypass the borrow checker</strong>: Restructuring your code is usually a better solution than using unsafe.</li>
<li><strong>You’re new to Rust</strong>: Build proficiency with safe Rust first before venturing into unsafe territory.</li>
<li><strong>The performance gains are minimal</strong>: Don’t sacrifice safety for small optimizations.</li>
<li><strong>There’s a safe alternative</strong>: Many standard library functions provide safe abstractions over unsafe code.</li>
</ol>
<h3 id="the-safety-contract"><a class="header" href="#the-safety-contract">The Safety Contract</a></h3>
<p>When you write unsafe code, you’re entering into a contract with the compiler. You’re promising that your code:</p>
<ol>
<li><strong>Won’t cause undefined behavior</strong>: This includes memory safety violations, data races, and other forms of undefined behavior.</li>
<li><strong>Maintains all invariants</strong>: Any invariants assumed by safe code must be upheld.</li>
<li><strong>Respects the safety contracts of any unsafe functions you call</strong>: You must read and follow the documentation for any unsafe functions you use.</li>
</ol>
<p>Breaking this contract means your program might exhibit undefined behavior, even in seemingly unrelated parts of your code that are safe.</p>
<h3 id="minimizing-unsafe-code"><a class="header" href="#minimizing-unsafe-code">Minimizing Unsafe Code</a></h3>
<p>A good practice is to minimize the scope of unsafe code and encapsulate it within safe abstractions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Unsafe implementation with a safe public API
pub fn safe_function(data: &amp;mut [u8]) {
    // Safe wrapper around unsafe code
    unsafe {
        // Only the minimum necessary code goes here
        perform_unsafe_operation(data);
    }
}

// The unsafe implementation details
unsafe fn perform_unsafe_operation(data: &amp;mut [u8]) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>By following this pattern, most of your codebase can remain safe while still benefiting from the capabilities of unsafe code where necessary.</p>
<p>In the next sections, we’ll dive deeper into each of the unsafe superpowers, exploring how to use them correctly and build safe abstractions around them.</p>
<h2 id="raw-pointers"><a class="header" href="#raw-pointers">Raw Pointers</a></h2>
<p>Raw pointers in Rust provide direct, unrestricted access to memory. Unlike references (<code>&amp;T</code> and <code>&amp;mut T</code>), raw pointers bypass Rust’s borrowing rules and safety checks. They’re similar to pointers in C and C++, with all the power and danger that entails.</p>
<h3 id="types-of-raw-pointers"><a class="header" href="#types-of-raw-pointers">Types of Raw Pointers</a></h3>
<p>Rust has two types of raw pointers:</p>
<ol>
<li><strong>Immutable raw pointers</strong>: <code>*const T</code> - Conceptually similar to <code>const T*</code> in C++</li>
<li><strong>Mutable raw pointers</strong>: <code>*mut T</code> - Conceptually similar to <code>T*</code> in C++</li>
</ol>
<p>Here’s how to create raw pointers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn raw_pointer_basics() {
    let value = 42;

    // Creating raw pointers is safe
    let ptr1: *const i32 = &amp;value as *const i32;  // From an immutable reference
    let mut mutable = 100;
    let ptr2: *mut i32 = &amp;mut mutable as *mut i32;  // From a mutable reference

    // Creating null or arbitrary pointers is also allowed
    let null_ptr: *const i32 = std::ptr::null();
    let addr_ptr: *mut u8 = 0xABCDEF as *mut u8;  // Arbitrary address (likely invalid)

    // Convert between pointer types
    let ptr3 = ptr2 as *const i32;  // *mut T to *const T

    // Printing pointers
    println!("Pointer value: {:p}", ptr1);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="properties-of-raw-pointers"><a class="header" href="#properties-of-raw-pointers">Properties of Raw Pointers</a></h3>
<p>Raw pointers have several characteristics that distinguish them from references:</p>
<ol>
<li><strong>No automatic dereferencing</strong>: Unlike references, raw pointers don’t automatically dereference with the dot operator.</li>
<li><strong>No lifetime constraints</strong>: Raw pointers don’t have lifetimes, so they can outlive the data they point to.</li>
<li><strong>No borrowing rules</strong>: You can have multiple mutable raw pointers to the same data.</li>
<li><strong>No null safety</strong>: Raw pointers can be null or point to invalid memory.</li>
<li><strong>No bounds checking</strong>: Array access through raw pointers doesn’t check bounds.</li>
</ol>
<p>These properties make raw pointers powerful but dangerous.</p>
<h3 id="creating-raw-pointers"><a class="header" href="#creating-raw-pointers">Creating Raw Pointers</a></h3>
<p>Creating raw pointers is safe; it’s only dereferencing them that requires <code>unsafe</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn creating_raw_pointers() {
    // From references
    let x = 10;
    let y = &amp;x as *const i32;  // Immutable raw pointer

    let mut z = 20;
    let w = &amp;mut z as *mut i32;  // Mutable raw pointer

    // From an array
    let arr = [1, 2, 3, 4, 5];
    let arr_ptr = arr.as_ptr();  // *const i32 to the first element

    // From a Vec
    let vec = vec![10, 20, 30];
    let vec_ptr = vec.as_ptr();  // *const i32 to the first element

    // From Box
    let boxed = Box::new(100);
    let box_ptr = Box::into_raw(boxed);  // *mut i32, ownership transferred to the pointer

    // From a string
    let s = "hello".to_string();
    let str_ptr = s.as_ptr();  // *const u8 to the first byte

    // Creating a raw pointer to a specific address (extremely unsafe!)
    let addr = 0x1000 as *mut i32;  // Points to address 0x1000
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pointer-arithmetic"><a class="header" href="#pointer-arithmetic">Pointer Arithmetic</a></h3>
<p>Unlike references, raw pointers support arithmetic operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pointer_arithmetic() {
    let arr = [1, 2, 3, 4, 5];
    let ptr = arr.as_ptr();

    unsafe {
        // Access elements using pointer arithmetic
        println!("Element 0: {}", *ptr);
        println!("Element 1: {}", *ptr.add(1));
        println!("Element 2: {}", *ptr.add(2));

        // Alternative syntax using offset
        println!("Element 3: {}", *ptr.offset(3));

        // You can also subtract
        let end_ptr = ptr.add(4);
        println!("Element 3 from end: {}", *end_ptr.sub(1));

        // Calculate distance between pointers
        let distance = end_ptr.offset_from(ptr);  // Returns 4
        println!("Distance: {}", distance);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Pointer arithmetic is done in terms of elements, not bytes. If <code>ptr</code> is a <code>*const i32</code>, then <code>ptr.add(1)</code> advances by 4 bytes (the size of <code>i32</code>).</p>
<h3 id="safety-considerations-with-raw-pointers"><a class="header" href="#safety-considerations-with-raw-pointers">Safety Considerations with Raw Pointers</a></h3>
<p>Creating raw pointers is safe, but many operations with them are not:</p>
<ol>
<li><strong>Dereferencing</strong>: Reading or writing through a raw pointer requires <code>unsafe</code>.</li>
<li><strong>Pointer arithmetic</strong>: Computing an invalid address through pointer arithmetic can lead to undefined behavior when dereferenced.</li>
<li><strong>Lifetime issues</strong>: The pointed-to data might no longer exist when you dereference the pointer.</li>
<li><strong>Alignment</strong>: Misaligned pointers can cause hardware exceptions on some platforms.</li>
</ol>
<p>Let’s examine how to safely handle raw pointers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn safe_pointer_handling() {
    let data = [1, 2, 3, 4];
    let ptr = data.as_ptr();

    // Check for null before dereferencing
    if !ptr.is_null() {
        unsafe {
            println!("Value: {}", *ptr);
        }
    }

    // Bound checking (must be done manually)
    let len = data.len();
    unsafe {
        for i in 0..len {  // Stay within bounds
            println!("data[{}] = {}", i, *ptr.add(i));
        }
    }

    // Converting back to references with explicit lifetime
    let slice = unsafe { std::slice::from_raw_parts(ptr, len) };
    println!("Slice: {:?}", slice);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="when-to-use-raw-pointers"><a class="header" href="#when-to-use-raw-pointers">When to Use Raw Pointers</a></h3>
<p>Despite their dangers, raw pointers have legitimate uses:</p>
<ol>
<li><strong>FFI</strong>: Interfacing with C libraries that use pointers.</li>
<li><strong>Advanced data structures</strong>: Implementing custom collections with specific memory layouts.</li>
<li><strong>Memory-mapped I/O</strong>: Accessing hardware registers or memory-mapped files.</li>
<li><strong>Performance-critical code</strong>: Avoiding bounds checks in thoroughly tested inner loops.</li>
<li><strong>Unsafe abstractions</strong>: Building safe abstractions around unsafe operations.</li>
</ol>
<p>Here’s a simple example of using raw pointers to implement a memory-efficient option type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CompactOption&lt;T&gt; {
    // The LSB is used as the "is_some" flag
    // The actual pointer is shifted left by 1
    value: usize,
    _phantom: std::marker::PhantomData&lt;T&gt;,
}

impl&lt;T&gt; CompactOption&lt;T&gt; {
    fn none() -&gt; Self {
        CompactOption {
            value: 0,
            _phantom: std::marker::PhantomData,
        }
    }

    fn some(value: T) -&gt; Self {
        let boxed = Box::new(value);
        let ptr = Box::into_raw(boxed) as usize;
        assert!(ptr % 2 == 0, "Pointer must be aligned");

        CompactOption {
            value: ptr | 1, // Set the LSB to 1 to indicate "some"
            _phantom: std::marker::PhantomData,
        }
    }

    fn is_some(&amp;self) -&gt; bool {
        (self.value &amp; 1) == 1
    }

    fn is_none(&amp;self) -&gt; bool {
        self.value == 0
    }

    fn unwrap(&amp;self) -&gt; &amp;T {
        assert!(self.is_some(), "Called unwrap on a None value");

        unsafe {
            let ptr = (self.value &amp; !1) as *const T;
            &amp;*ptr
        }
    }
}

impl&lt;T&gt; Drop for CompactOption&lt;T&gt; {
    fn drop(&amp;mut self) {
        if self.is_some() {
            unsafe {
                let ptr = (self.value &amp; !1) as *mut T;
                let _ = Box::from_raw(ptr); // Reclaim ownership for proper cleanup
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This example uses the least significant bit of the pointer as a flag, a technique used in some optimized data structures.</p>
<h3 id="comparing-raw-pointers"><a class="header" href="#comparing-raw-pointers">Comparing Raw Pointers</a></h3>
<p>Comparing raw pointers works like comparing integers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compare_pointers() {
    let arr = [1, 2, 3, 4, 5];
    let ptr1 = arr.as_ptr();
    let ptr2 = unsafe { ptr1.add(2) };

    // Compare pointers
    if ptr1 &lt; ptr2 {
        println!("ptr1 comes before ptr2");
    }

    // Check equality
    if ptr1 == arr.as_ptr() {
        println!("These pointers are equal");
    }

    // Memory addresses as integers
    println!("Address: {:p}", ptr1);
    let addr = ptr1 as usize;
    println!("As integer: 0x{:x}", addr);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="dereferencing-raw-pointers"><a class="header" href="#dereferencing-raw-pointers">Dereferencing Raw Pointers</a></h2>
<p>The ability to dereference raw pointers is one of the primary reasons to use unsafe code in Rust. Dereferencing a raw pointer means accessing the value it points to, which requires an <code>unsafe</code> block because the compiler cannot guarantee that the operation is safe.</p>
<h3 id="basic-dereferencing"><a class="header" href="#basic-dereferencing">Basic Dereferencing</a></h3>
<p>To dereference a raw pointer, you use the <code>*</code> operator inside an <code>unsafe</code> block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn basic_dereferencing() {
    let value = 42;
    let ptr = &amp;value as *const i32;

    // Reading through a raw pointer
    unsafe {
        println!("Value: {}", *ptr);  // Prints: Value: 42
    }

    // Writing through a mutable raw pointer
    let mut mutable = 100;
    let mut_ptr = &amp;mut mutable as *mut i32;

    unsafe {
        *mut_ptr = 200;  // Modify the value
    }

    println!("Modified value: {}", mutable);  // Prints: Modified value: 200
}
<span class="boring">}</span></code></pre></pre>
<h3 id="why-dereferencing-requires-unsafe"><a class="header" href="#why-dereferencing-requires-unsafe">Why Dereferencing Requires Unsafe</a></h3>
<p>Dereferencing raw pointers requires <code>unsafe</code> because it bypasses several of Rust’s safety guarantees:</p>
<ol>
<li><strong>Memory safety</strong>: The pointer might be null, dangling, or point to unallocated memory.</li>
<li><strong>Data races</strong>: Multiple threads might access the same memory location concurrently.</li>
<li><strong>Aliasing rules</strong>: There might be both mutable and immutable pointers to the same memory.</li>
<li><strong>Alignment</strong>: The pointer might not be properly aligned for the target type.</li>
</ol>
<p>When you use <code>unsafe</code>, you’re telling the compiler that you’ve verified these conditions manually.</p>
<h3 id="dereferencing-null-or-invalid-pointers"><a class="header" href="#dereferencing-null-or-invalid-pointers">Dereferencing Null or Invalid Pointers</a></h3>
<p>Dereferencing a null or invalid pointer causes undefined behavior:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn undefined_behavior() {
    let null_ptr: *const i32 = std::ptr::null();

    unsafe {
        // DON'T DO THIS! This causes undefined behavior
        // let value = *null_ptr;
    }

    // Creating a pointer to memory that's been freed
    let mut value = Box::new(42);
    let dangling = &amp;mut *value as *mut i32;
    drop(value);  // Free the memory

    unsafe {
        // DON'T DO THIS! This is a use-after-free error
        // *dangling = 100;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="safe-patterns-for-dereferencing"><a class="header" href="#safe-patterns-for-dereferencing">Safe Patterns for Dereferencing</a></h3>
<p>Here are some patterns to make dereferencing safer:</p>
<h4 id="1-null-checking"><a class="header" href="#1-null-checking">1. Null Checking</a></h4>
<p>Always check if a pointer is null before dereferencing it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn safe_null_check(ptr: *const i32) -&gt; Option&lt;i32&gt; {
    if ptr.is_null() {
        None
    } else {
        unsafe { Some(*ptr) }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-bound-checking-for-arrays"><a class="header" href="#2-bound-checking-for-arrays">2. Bound Checking for Arrays</a></h4>
<p>When working with arrays, check bounds manually:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn safe_array_access(ptr: *const i32, index: usize, len: usize) -&gt; Option&lt;i32&gt; {
    if ptr.is_null() || index &gt;= len {
        None
    } else {
        unsafe { Some(*ptr.add(index)) }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-converting-back-to-references"><a class="header" href="#3-converting-back-to-references">3. Converting Back to References</a></h4>
<p>When possible, convert raw pointers back to references with explicit lifetimes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ptr_to_ref&lt;'a&gt;(ptr: *const i32) -&gt; Option&lt;&amp;'a i32&gt; {
    if ptr.is_null() {
        None
    } else {
        unsafe { Some(&amp;*ptr) }
    }
}

fn ptr_to_slice&lt;'a&gt;(ptr: *const i32, len: usize) -&gt; Option&lt;&amp;'a [i32]&gt; {
    if ptr.is_null() {
        None
    } else {
        unsafe { Some(std::slice::from_raw_parts(ptr, len)) }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="4-using-the-as_ref-method"><a class="header" href="#4-using-the-as_ref-method">4. Using the <code>as_ref</code> Method</a></h4>
<p>Raw pointers have an <code>as_ref</code> method that safely converts them to an <code>Option&lt;&amp;T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn using_as_ref() {
    let value = 42;
    let ptr = &amp;value as *const i32;

    // Safe conversion to Option&lt;&amp;T&gt;
    match ptr.as_ref() {
        Some(reference) =&gt; println!("Value: {}", reference),
        None =&gt; println!("Null pointer"),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="dereferencing-pointers-to-compound-types"><a class="header" href="#dereferencing-pointers-to-compound-types">Dereferencing Pointers to Compound Types</a></h3>
<p>When working with pointers to structs or arrays, you need to be careful about alignment and memory layout:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

fn compound_types() {
    let point = Point { x: 10, y: 20 };
    let ptr = &amp;point as *const Point;

    unsafe {
        // Access the whole struct
        println!("Point: ({}, {})", (*ptr).x, (*ptr).y);

        // Field access can be simplified
        println!("X: {}", (*ptr).x);
        println!("Y: {}", (*ptr).y);

        // Or even more concisely
        println!("X: {}", ptr.as_ref().unwrap().x);
    }

    // Arrays and slices
    let array = [1, 2, 3, 4, 5];
    let arr_ptr = array.as_ptr();

    unsafe {
        // Create a slice from a pointer and length
        let slice = std::slice::from_raw_parts(arr_ptr, array.len());
        println!("Slice: {:?}", slice);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-read-and-write-methods"><a class="header" href="#the-read-and-write-methods">The <code>read</code> and <code>write</code> Methods</a></h3>
<p>For more controlled access, you can use the <code>read</code> and <code>write</code> methods on raw pointers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_write_methods() {
    let value = 42;
    let ptr = &amp;value as *const i32;

    unsafe {
        // Read the value
        let read_value = ptr.read();
        println!("Read value: {}", read_value);
    }

    let mut mutable = 100;
    let mut_ptr = &amp;mut mutable as *mut i32;

    unsafe {
        // Write a value
        mut_ptr.write(200);
        println!("After write: {}", mutable);  // Prints: After write: 200
    }
}
<span class="boring">}</span></code></pre></pre>
<p>These methods are particularly useful when:</p>
<ol>
<li>You want to avoid direct dereferencing, which might create temporaries.</li>
<li>You’re working with potentially unaligned data.</li>
<li>You need to copy a value without running the destructor at the source.</li>
</ol>
<h3 id="volatile-reads-and-writes"><a class="header" href="#volatile-reads-and-writes">Volatile Reads and Writes</a></h3>
<p>For memory-mapped I/O or when working with hardware, you might need volatile operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn volatile_operations() {
    let mut value = 42;
    let ptr = &amp;mut value as *mut i32;

    unsafe {
        // Volatile read
        let read_value = std::ptr::read_volatile(ptr);
        println!("Volatile read: {}", read_value);

        // Volatile write
        std::ptr::write_volatile(ptr, 100);
        println!("After volatile write: {}", value);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Volatile operations tell the compiler not to optimize away the read or write, which is essential when the memory might be changed by external factors (like hardware).</p>
<h3 id="unaligned-access"><a class="header" href="#unaligned-access">Unaligned Access</a></h3>
<p>Accessing unaligned memory can cause hardware exceptions on some platforms:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn unaligned_access() {
    // Create an unaligned pointer (for demonstration only)
    let data = [0u8; 8];
    let ptr = data.as_ptr() as *const u8;

    // Cast to a type that requires alignment
    let unaligned_ptr = (ptr.wrapping_add(1)) as *const u64;

    unsafe {
        // DON'T DO THIS on platforms that require alignment!
        // let value = *unaligned_ptr;

        // Instead, use read_unaligned
        let value = unaligned_ptr.read_unaligned();
        println!("Unaligned read: {}", value);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="common-pitfalls-when-dereferencing-raw-pointers"><a class="header" href="#common-pitfalls-when-dereferencing-raw-pointers">Common Pitfalls When Dereferencing Raw Pointers</a></h3>
<p>Here are some common mistakes to avoid:</p>
<h4 id="1-forgetting-to-check-for-null"><a class="header" href="#1-forgetting-to-check-for-null">1. Forgetting to Check for Null</a></h4>
<p>Always check if a pointer is null before dereferencing it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_data(ptr: *const i32) {
    // BAD: Doesn't check for null
    unsafe {
        let value = *ptr;  // Undefined behavior if ptr is null
    }

    // GOOD: Checks for null
    if !ptr.is_null() {
        unsafe {
            let value = *ptr;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-use-after-free"><a class="header" href="#2-use-after-free">2. Use-After-Free</a></h4>
<p>Be careful not to use pointers after the memory they point to has been freed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_after_free() {
    let mut heap_value = Box::new(42);
    let raw_ptr = &amp;mut *heap_value as *mut i32;

    drop(heap_value);  // Free the memory

    // BAD: The memory has been freed
    unsafe {
        // *raw_ptr = 100;  // Undefined behavior
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-invalidated-pointers-due-to-reallocation"><a class="header" href="#3-invalidated-pointers-due-to-reallocation">3. Invalidated Pointers Due to Reallocation</a></h4>
<p>Growing a vector or other collection can reallocate memory and invalidate pointers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn invalidated_pointers() {
    let mut vec = vec![1, 2, 3];
    let ptr = vec.as_ptr();

    vec.push(4);  // Might reallocate

    // BAD: ptr might be invalid now
    unsafe {
        // println!("Value: {}", *ptr);  // Potentially undefined behavior
    }

    // GOOD: Get a fresh pointer after modification
    let new_ptr = vec.as_ptr();
    unsafe {
        println!("Value: {}", *new_ptr);  // Safe
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="4-incorrect-type-casting"><a class="header" href="#4-incorrect-type-casting">4. Incorrect Type Casting</a></h4>
<p>Be careful when casting pointers to different types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn incorrect_casting() {
    let value: i32 = 42;
    let ptr = &amp;value as *const i32;

    // BAD: Incorrect type cast
    let float_ptr = ptr as *const f32;

    unsafe {
        // Undefined behavior: reinterpreting i32 as f32
        // let float_value = *float_ptr;
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="5-overrunning-bounds"><a class="header" href="#5-overrunning-bounds">5. Overrunning Bounds</a></h4>
<p>Always ensure you stay within bounds when using pointer arithmetic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn overrunning_bounds() {
    let array = [1, 2, 3];
    let ptr = array.as_ptr();

    // BAD: Accessing beyond the array bounds
    unsafe {
        // let value = *ptr.add(5);  // Undefined behavior
    }

    // GOOD: Stay within bounds
    let len = array.len();
    for i in 0..len {
        unsafe {
            println!("Value at index {}: {}", i, *ptr.add(i));
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In the next section, we’ll explore how raw pointers enable mutable aliasing, a capability that breaks Rust’s strict borrowing rules but is sometimes necessary for advanced data structures and algorithms.</p>
<h2 id="mutable-aliasing-with-raw-pointers"><a class="header" href="#mutable-aliasing-with-raw-pointers">Mutable Aliasing with Raw Pointers</a></h2>
<p>One of the most significant restrictions in safe Rust is the prohibition against having multiple mutable references to the same memory location—a rule that prevents data races at compile time. However, sometimes advanced data structures and algorithms require this capability, which is where raw pointers come in.</p>
<h3 id="understanding-rusts-aliasing-rules"><a class="header" href="#understanding-rusts-aliasing-rules">Understanding Rust’s Aliasing Rules</a></h3>
<p>In safe Rust, you can have either:</p>
<ol>
<li>One mutable reference (<code>&amp;mut T</code>), or</li>
<li>Any number of immutable references (<code>&amp;T</code>)</li>
</ol>
<p>But never both at the same time. This is enforced by the borrow checker at compile time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn aliasing_in_safe_rust() {
    let mut value = 42;

    // This is allowed: one mutable reference
    let mutable_ref = &amp;mut value;
    *mutable_ref = 100;

    // This would fail to compile:
    // let another_ref = &amp;value;
    // println!("Value: {}", *another_ref);

    // After the mutable borrow ends, we can have immutable references
    println!("Value: {}", value);

    // Now we can have multiple immutable references
    let ref1 = &amp;value;
    let ref2 = &amp;value;
    println!("References: {} {}", *ref1, *ref2);

    // But we can no longer have a mutable reference
    // let another_mut_ref = &amp;mut value;  // Error!
}
<span class="boring">}</span></code></pre></pre>
<h3 id="breaking-the-aliasing-rules-with-raw-pointers"><a class="header" href="#breaking-the-aliasing-rules-with-raw-pointers">Breaking the Aliasing Rules with Raw Pointers</a></h3>
<p>Raw pointers aren’t subject to the borrow checker’s rules, allowing you to create multiple mutable pointers to the same memory:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mutable_aliasing_with_raw_pointers() {
    let mut value = 42;

    // Create two mutable raw pointers to the same memory
    let ptr1 = &amp;mut value as *mut i32;
    let ptr2 = &amp;mut value as *mut i32;

    unsafe {
        // Modify through the first pointer
        *ptr1 = 100;
        println!("After ptr1 modification: {}", value);  // 100

        // Modify through the second pointer
        *ptr2 = 200;
        println!("After ptr2 modification: {}", value);  // 200
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="mixing-references-and-raw-pointers"><a class="header" href="#mixing-references-and-raw-pointers">Mixing References and Raw Pointers</a></h3>
<p>You can create raw pointers from references, but you need to be careful about the original borrowing rules:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mixing_references_and_pointers() {
    let mut value = 42;

    // Create a mutable reference
    let ref_mut = &amp;mut value;

    // Create a raw pointer from the reference
    let raw_ptr = ref_mut as *mut i32;

    // This would violate Rust's borrowing rules:
    // println!("Original value: {}", value);

    // Using the raw pointer
    unsafe {
        *raw_ptr = 100;
    }

    // Now we can use the value again
    println!("Modified value: {}", value);  // 100
}
<span class="boring">}</span></code></pre></pre>
<h3 id="legitimate-use-cases-for-mutable-aliasing"><a class="header" href="#legitimate-use-cases-for-mutable-aliasing">Legitimate Use Cases for Mutable Aliasing</a></h3>
<p>While dangerous, mutable aliasing has legitimate uses:</p>
<h4 id="1-implementing-data-structures-with-cycles"><a class="header" href="#1-implementing-data-structures-with-cycles">1. Implementing Data Structures with Cycles</a></h4>
<p>Doubly linked lists, graphs, and other cyclic data structures require nodes to reference each other:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Node {
    value: i32,
    next: Option&lt;*mut Node&gt;,
    prev: Option&lt;*mut Node&gt;,
}

impl Node {
    fn new(value: i32) -&gt; Box&lt;Self&gt; {
        Box::new(Node {
            value,
            next: None,
            prev: None,
        })
    }
}

fn create_doubly_linked_list() {
    // Create nodes on the heap
    let mut head = Node::new(1);
    let mut middle = Node::new(2);
    let mut tail = Node::new(3);

    // Get raw pointers to the nodes
    let head_ptr = &amp;mut *head as *mut Node;
    let middle_ptr = &amp;mut *middle as *mut Node;
    let tail_ptr = &amp;mut *tail as *mut Node;

    // Connect the nodes
    unsafe {
        (*head_ptr).next = Some(middle_ptr);
        (*middle_ptr).prev = Some(head_ptr);
        (*middle_ptr).next = Some(tail_ptr);
        (*tail_ptr).prev = Some(middle_ptr);
    }

    // Navigate the list
    unsafe {
        let mut current = head_ptr;
        while let Some(next_ptr) = (*current).next {
            println!("Value: {}", (*current).value);
            current = next_ptr;
        }
        println!("Value: {}", (*current).value);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-interior-mutability-patterns"><a class="header" href="#2-interior-mutability-patterns">2. Interior Mutability Patterns</a></h4>
<p>Some interior mutability patterns, like <code>RefCell</code>, use raw pointers under the hood to enable dynamic borrowing checks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simplified RefCell-like implementation
struct MyRefCell&lt;T&gt; {
    value: T,
    borrow_state: std::cell::Cell&lt;isize&gt;,
}

impl&lt;T&gt; MyRefCell&lt;T&gt; {
    fn new(value: T) -&gt; Self {
        MyRefCell {
            value,
            borrow_state: std::cell::Cell::new(0),
        }
    }

    fn borrow(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        let state = self.borrow_state.get();
        if state &lt; 0 {
            // Already mutably borrowed
            return None;
        }
        self.borrow_state.set(state + 1);

        // Use raw pointer to create a reference with an appropriate lifetime
        Some(unsafe { &amp;*(&amp;self.value as *const T) })
    }

    fn borrow_mut(&amp;self) -&gt; Option&lt;&amp;mut T&gt; {
        let state = self.borrow_state.get();
        if state != 0 {
            // Already borrowed
            return None;
        }
        self.borrow_state.set(-1);

        // Use raw pointer to create a mutable reference
        Some(unsafe { &amp;mut *(&amp;self.value as *const T as *mut T) })
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-self-referential-structures"><a class="header" href="#3-self-referential-structures">3. Self-Referential Structures</a></h4>
<p>Structures that contain pointers to their own fields:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SelfReferential {
    data: String,
    // Pointer to a location within data
    slice_ptr: *const u8,
    slice_len: usize,
}

impl SelfReferential {
    fn new(text: &amp;str, substr: &amp;str) -&gt; Option&lt;Self&gt; {
        let data = text.to_string();

        // Find the substring
        if let Some(start_idx) = text.find(substr) {
            let slice_ptr = unsafe { data.as_ptr().add(start_idx) };
            let slice_len = substr.len();

            Some(SelfReferential {
                data,
                slice_ptr,
                slice_len,
            })
        } else {
            None
        }
    }

    fn get_substring(&amp;self) -&gt; &amp;str {
        unsafe {
            let slice = std::slice::from_raw_parts(self.slice_ptr, self.slice_len);
            std::str::from_utf8_unchecked(slice)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="4-performance-critical-algorithms"><a class="header" href="#4-performance-critical-algorithms">4. Performance-Critical Algorithms</a></h4>
<p>Some algorithms become more efficient with mutable aliasing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn swap_elements(a: &amp;mut [i32], i: usize, j: usize) {
    if i == j || i &gt;= a.len() || j &gt;= a.len() {
        return;
    }

    // Get raw pointers to avoid borrow checker issues when indexes might overlap
    let ptr_i = &amp;mut a[i] as *mut i32;
    let ptr_j = &amp;mut a[j] as *mut i32;

    unsafe {
        let temp = *ptr_i;
        *ptr_i = *ptr_j;
        *ptr_j = temp;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="dangers-of-mutable-aliasing"><a class="header" href="#dangers-of-mutable-aliasing">Dangers of Mutable Aliasing</a></h3>
<p>While powerful, mutable aliasing introduces several risks:</p>
<h4 id="1-data-races"><a class="header" href="#1-data-races">1. Data Races</a></h4>
<p>In multithreaded code, mutable aliasing can lead to data races:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn data_race_example() {
    let mut value = 42;
    let ptr = &amp;mut value as *mut i32;

    // DON'T DO THIS: Potential data race
    std::thread::spawn(move || {
        unsafe {
            *ptr = 100;  // Concurrent access from another thread
        }
    });

    // Main thread still has access to `value`
    value = 200;  // Could race with the modification in the spawned thread
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-breaking-invariants"><a class="header" href="#2-breaking-invariants">2. Breaking Invariants</a></h4>
<p>Mutable aliasing can break invariants that safe code relies on:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn breaking_invariants() {
    let mut vec = vec![1, 2, 3];

    // Get a raw pointer to the first element
    let first_elem_ptr = vec.as_mut_ptr();

    unsafe {
        // DON'T DO THIS: Modifying the vector while holding a pointer to its elements
        vec.push(4);  // This might reallocate, invalidating first_elem_ptr

        // Using the pointer after reallocation is undefined behavior
        // *first_elem_ptr = 100;
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-iterator-invalidation"><a class="header" href="#3-iterator-invalidation">3. Iterator Invalidation</a></h4>
<p>Modifying a collection while iterating over it can lead to undefined behavior:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn iterator_invalidation() {
    let mut vec = vec![1, 2, 3, 4, 5];

    // DON'T DO THIS: Iterator invalidation
    let mut sum = 0;
    for &amp;item in &amp;vec {
        sum += item;

        unsafe {
            // Modifying the vector while iterating over it
            // let ptr = vec.as_mut_ptr();
            // *ptr = 0;  // This could invalidate the iterator
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="safe-abstractions-for-mutable-aliasing"><a class="header" href="#safe-abstractions-for-mutable-aliasing">Safe Abstractions for Mutable Aliasing</a></h3>
<p>Instead of using raw pointers directly, consider these safer alternatives:</p>
<h4 id="1-interior-mutability-types"><a class="header" href="#1-interior-mutability-types">1. Interior Mutability Types</a></h4>
<p>Rust’s standard library provides types that enable safe interior mutability:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::{Cell, RefCell};
use std::rc::Rc;

fn safe_interior_mutability() {
    // Cell for Copy types
    let cell = Cell::new(42);
    let value1 = cell.get();
    cell.set(100);
    let value2 = cell.get();
    println!("Values: {} {}", value1, value2);  // 42 100

    // RefCell for non-Copy types
    let ref_cell = RefCell::new(vec![1, 2, 3]);
    {
        let mut borrowed = ref_cell.borrow_mut();
        borrowed.push(4);
    }

    let borrowed = ref_cell.borrow();
    println!("Vector: {:?}", borrowed);  // [1, 2, 3, 4]

    // Rc&lt;RefCell&lt;T&gt;&gt; for shared mutable data
    let shared = Rc::new(RefCell::new(String::from("Hello")));
    let clone1 = shared.clone();
    let clone2 = shared.clone();

    clone1.borrow_mut().push_str(", ");
    clone2.borrow_mut().push_str("World!");

    println!("Shared string: {}", shared.borrow());  // Hello, World!
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-indexes-instead-of-pointers"><a class="header" href="#2-indexes-instead-of-pointers">2. Indexes Instead of Pointers</a></h4>
<p>Use indexes into arrays or vectors instead of raw pointers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct NodeIndex(usize);

struct Graph {
    nodes: Vec&lt;Node&gt;,
}

struct Node {
    value: i32,
    edges: Vec&lt;NodeIndex&gt;,
}

impl Graph {
    fn add_node(&amp;mut self, value: i32) -&gt; NodeIndex {
        let index = self.nodes.len();
        self.nodes.push(Node {
            value,
            edges: Vec::new(),
        });
        NodeIndex(index)
    }

    fn add_edge(&amp;mut self, from: NodeIndex, to: NodeIndex) {
        if from.0 &lt; self.nodes.len() &amp;&amp; to.0 &lt; self.nodes.len() {
            self.nodes[from.0].edges.push(to);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-split-borrows"><a class="header" href="#3-split-borrows">3. Split Borrows</a></h4>
<p>Split data structures to borrow different parts independently:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn split_borrows() {
    let mut data = vec![1, 2, 3, 4, 5];

    // Split the slice into non-overlapping parts
    let (left, right) = data.split_at_mut(2);

    // Now we can modify both parts independently
    left[0] = 10;
    right[0] = 20;

    println!("Data: {:?}", data);  // [10, 2, 20, 4, 5]
}
<span class="boring">}</span></code></pre></pre>
<h4 id="4-controlled-sharing-with-unsafecell"><a class="header" href="#4-controlled-sharing-with-unsafecell">4. Controlled Sharing with <code>UnsafeCell</code></a></h4>
<p>For implementing custom interior mutability types, use <code>UnsafeCell</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::UnsafeCell;

struct SharedCounter {
    value: UnsafeCell&lt;i32&gt;,
}

// This type is safe to share between threads
unsafe impl Sync for SharedCounter {}

impl SharedCounter {
    fn new(value: i32) -&gt; Self {
        SharedCounter {
            value: UnsafeCell::new(value),
        }
    }

    fn increment(&amp;self) {
        unsafe {
            let ptr = self.value.get();
            *ptr += 1;
        }
    }

    fn get(&amp;self) -&gt; i32 {
        unsafe { *self.value.get() }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="best-practices-for-mutable-aliasing"><a class="header" href="#best-practices-for-mutable-aliasing">Best Practices for Mutable Aliasing</a></h3>
<p>When you must use mutable aliasing, follow these best practices:</p>
<ol>
<li><strong>Minimize scope</strong>: Keep the unsafe block as small as possible.</li>
<li><strong>Document assumptions</strong>: Clearly document the conditions that make your code safe.</li>
<li><strong>Add runtime checks</strong>: Add assertions to catch potential issues in debug builds.</li>
<li><strong>Prefer safer alternatives</strong>: Use standard library types like <code>Cell</code> and <code>RefCell</code> when possible.</li>
<li><strong>Avoid concurrent access</strong>: Ensure mutable aliasing doesn’t cross thread boundaries without proper synchronization.</li>
<li><strong>Test thoroughly</strong>: Write extensive tests for code that uses mutable aliasing.</li>
</ol>
<p>In the next section, we’ll explore another unsafe capability: calling unsafe functions.</p>
<h2 id="calling-unsafe-functions"><a class="header" href="#calling-unsafe-functions">Calling Unsafe Functions</a></h2>
<p>Unsafe functions in Rust are those that make certain safety guarantees conditional on the caller, rather than being enforced by the compiler. Calling an unsafe function requires an <code>unsafe</code> block, signaling that the programmer has verified these preconditions.</p>
<h3 id="understanding-unsafe-functions"><a class="header" href="#understanding-unsafe-functions">Understanding Unsafe Functions</a></h3>
<p>Unsafe functions in Rust are marked with the <code>unsafe</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust">// An unsafe function that dereferences a raw pointer
unsafe fn get_value(ptr: *const i32) -&gt; i32 {
    *ptr  // Dereferencing a raw pointer requires unsafe
}

fn main() {
    let value = 42;
    let ptr = &amp;value as *const i32;

    // Calling an unsafe function requires an unsafe block
    unsafe {
        let result = get_value(ptr);
        println!("Result: {}", result);  // 42
    }
}</code></pre></pre>
<h3 id="why-functions-are-marked-unsafe"><a class="header" href="#why-functions-are-marked-unsafe">Why Functions Are Marked Unsafe</a></h3>
<p>Functions are marked as <code>unsafe</code> when they:</p>
<ol>
<li><strong>Have preconditions not checked by the compiler</strong>: The caller must ensure certain conditions are met.</li>
<li><strong>Perform operations that could violate memory safety</strong>: Like dereferencing raw pointers or accessing mutable statics.</li>
<li><strong>Make assumptions about data representation</strong>: Like interpreting bytes as a specific type.</li>
<li><strong>Call other unsafe functions</strong>: And inherit their safety requirements.</li>
</ol>
<p>Here’s an example of a function with preconditions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This function requires that:
// 1. `ptr` is not null
// 2. `ptr` points to valid memory for a T
// 3. `ptr` is properly aligned for T
// 4. The memory is not concurrently modified by another thread
unsafe fn as_ref_unchecked&lt;T&gt;(ptr: *const T) -&gt; &amp;T {
    &amp;*ptr
}
<span class="boring">}</span></code></pre></pre>
<h3 id="types-of-unsafe-functions"><a class="header" href="#types-of-unsafe-functions">Types of Unsafe Functions</a></h3>
<h4 id="1-standard-library-unsafe-functions"><a class="header" href="#1-standard-library-unsafe-functions">1. Standard Library Unsafe Functions</a></h4>
<p>The Rust standard library provides many unsafe functions for low-level operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn standard_library_unsafe_examples() {
    let mut data = vec![1, 2, 3, 4, 5];

    unsafe {
        // Get a mutable reference to an element without bounds checking
        let third = data.get_unchecked_mut(2);
        *third = 100;

        // Create a slice from a pointer and length without validating the range
        let ptr = data.as_ptr();
        let slice = std::slice::from_raw_parts(ptr, 3);
        println!("Slice: {:?}", slice);  // [1, 2, 100]

        // Convert a string slice without validating UTF-8
        let bytes = &amp;[72, 101, 108, 108, 111];  // "Hello" in ASCII
        let hello = std::str::from_utf8_unchecked(bytes);
        println!("String: {}", hello);  // Hello
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-custom-unsafe-functions"><a class="header" href="#2-custom-unsafe-functions">2. Custom Unsafe Functions</a></h4>
<p>You can define your own unsafe functions for operations that require special care:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An unsafe function that reinterprets bytes as a different type
unsafe fn transmute_bytes&lt;T, U&gt;(input: &amp;T) -&gt; U
where
    T: Sized,
    U: Sized,
    U: Copy,
{
    assert_eq!(std::mem::size_of::&lt;T&gt;(), std::mem::size_of::&lt;U&gt;());
    let ptr = input as *const T as *const U;
    *ptr
}

fn transmute_example() {
    let value: u32 = 0x01020304;

    unsafe {
        // Reinterpret u32 as [u8; 4]
        let bytes: [u8; 4] = transmute_bytes(&amp;value);
        println!("Bytes: {:?}", bytes);  // [4, 3, 2, 1] on little-endian systems
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-ffi-functions"><a class="header" href="#3-ffi-functions">3. FFI Functions</a></h4>
<p>Functions from foreign languages are inherently unsafe because Rust can’t verify their safety:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Declaration of a C function
extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn call_c_function() {
    let input = -42;

    // Calling a foreign function requires unsafe
    let result = unsafe { abs(input) };
    println!("Absolute value: {}", result);  // 42
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-safety-contract-1"><a class="header" href="#the-safety-contract-1">The Safety Contract</a></h3>
<p>When you mark a function as <code>unsafe</code>, you’re establishing a contract with its callers:</p>
<ol>
<li><strong>Document preconditions</strong>: Clearly state what conditions must be satisfied for the function to be safe.</li>
<li><strong>Specify invariants</strong>: Document what the function expects and guarantees about the state of the program.</li>
<li><strong>Detail the consequences</strong>: Explain what could go wrong if the preconditions aren’t met.</li>
</ol>
<p>Here’s an example of well-documented unsafe function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Creates a slice from a raw pointer and a length.
///
/// # Safety
///
/// The caller must ensure that:
/// - `ptr` points to a valid memory region containing at least `len` consecutive
///   properly initialized values of type `T`.
/// - The memory referenced by `ptr` must be valid for the duration of the returned slice.
/// - `ptr` must be properly aligned for type `T`.
/// - The memory referenced by `ptr` must not be mutated for the duration of the slice.
///
/// Failure to meet these conditions may result in undefined behavior.
unsafe fn create_slice&lt;'a, T&gt;(ptr: *const T, len: usize) -&gt; &amp;'a [T] {
    std::slice::from_raw_parts(ptr, len)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="calling-unsafe-functions-safely"><a class="header" href="#calling-unsafe-functions-safely">Calling Unsafe Functions Safely</a></h3>
<p>When calling unsafe functions, follow these guidelines:</p>
<h4 id="1-verify-preconditions"><a class="header" href="#1-verify-preconditions">1. Verify Preconditions</a></h4>
<p>Always ensure all preconditions are met before calling an unsafe function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn safe_wrapper(data: Option&lt;&amp;[i32]&gt;) -&gt; Option&lt;i32&gt; {
    let slice = data?;

    if slice.is_empty() {
        return None;
    }

    // All preconditions verified, safe to call the unsafe function
    Some(unsafe { *slice.as_ptr() })
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-create-safe-wrappers"><a class="header" href="#2-create-safe-wrappers">2. Create Safe Wrappers</a></h4>
<p>Encapsulate unsafe function calls in safe abstractions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A safe wrapper around an unsafe function
fn get_first&lt;T: Copy&gt;(slice: &amp;[T]) -&gt; Option&lt;T&gt; {
    if slice.is_empty() {
        None
    } else {
        // Safe because we've checked that the slice is not empty
        Some(unsafe { *slice.as_ptr() })
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-use-helper-functions"><a class="header" href="#3-use-helper-functions">3. Use Helper Functions</a></h4>
<p>Break down complex unsafe operations into smaller, well-defined helper functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_memory_mapped_file(path: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, std::io::Error&gt; {
    use std::fs::File;
    use std::io::{Error, ErrorKind};
    use std::os::unix::io::AsRawFd;

    let file = File::open(path)?;
    let size = file.metadata()?.len() as usize;

    if size == 0 {
        return Ok(Vec::new());
    }

    // Map the file into memory
    let ptr = unsafe { map_file(&amp;file, size)? };

    // Create a safe copy of the mapped memory
    let mut buffer = Vec::with_capacity(size);
    unsafe {
        buffer.set_len(size);
        std::ptr::copy_nonoverlapping(ptr, buffer.as_mut_ptr(), size);
        unmap_file(ptr, size)?;
    }

    Ok(buffer)
}

// Helper function for memory mapping
unsafe fn map_file(file: &amp;File, size: usize) -&gt; Result&lt;*mut u8, std::io::Error&gt; {
    use std::ptr;
    use libc::{mmap, PROT_READ, MAP_PRIVATE, MAP_FAILED};

    let addr = mmap(
        ptr::null_mut(),
        size,
        PROT_READ,
        MAP_PRIVATE,
        file.as_raw_fd(),
        0,
    );

    if addr == MAP_FAILED {
        Err(std::io::Error::last_os_error())
    } else {
        Ok(addr as *mut u8)
    }
}

// Helper function for unmapping
unsafe fn unmap_file(ptr: *mut u8, size: usize) -&gt; Result&lt;(), std::io::Error&gt; {
    use libc::munmap;

    if munmap(ptr as *mut libc::c_void, size) == -1 {
        Err(std::io::Error::last_os_error())
    } else {
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="common-standard-library-unsafe-functions"><a class="header" href="#common-standard-library-unsafe-functions">Common Standard Library Unsafe Functions</a></h3>
<p>Let’s explore some commonly used unsafe functions from the standard library:</p>
<h4 id="memory-operations"><a class="header" href="#memory-operations">Memory Operations</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn memory_operations_example() {
    let mut data = [0u8; 8];
    let source = [1, 2, 3, 4];

    unsafe {
        // Copy non-overlapping memory regions
        std::ptr::copy_nonoverlapping(
            source.as_ptr(),
            data.as_mut_ptr(),
            source.len()
        );

        // Copy potentially overlapping memory regions
        std::ptr::copy(
            data.as_ptr().add(2),
            data.as_mut_ptr().add(4),
            2
        );

        // Fill memory with a value
        std::ptr::write_bytes(
            data.as_mut_ptr(),
            0xFF,
            2
        );
    }

    println!("Data: {:?}", data);  // [255, 255, 3, 4, 3, 4, 0, 0]
}
<span class="boring">}</span></code></pre></pre>
<h4 id="initialization-control"><a class="header" href="#initialization-control">Initialization Control</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialization_control() {
    // Create an uninitialized array
    let mut data: [u8; 1024] = unsafe { std::mem::MaybeUninit::uninit().assume_init() };

    // Initialize only a portion
    for i in 0..10 {
        data[i] = i as u8;
    }

    // Only use the initialized portion
    let initialized_slice = &amp;data[0..10];
    println!("Initialized: {:?}", initialized_slice);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="type-punning"><a class="header" href="#type-punning">Type Punning</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn type_punning() {
    let value: f32 = 3.14;

    // Reinterpret as u32
    let bits = unsafe { std::mem::transmute::&lt;f32, u32&gt;(value) };
    println!("Float bits: 0x{:x}", bits);

    // A safer alternative using to_bits
    let bits_safe = value.to_bits();
    println!("Float bits (safe): 0x{:x}", bits_safe);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="extending-lifetimes"><a class="header" href="#extending-lifetimes">Extending Lifetimes</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn extend_lifetime() {
    let mut data = String::from("hello");

    // Create a reference with 'static lifetime (DANGEROUS!)
    let static_ref: &amp;'static str = unsafe {
        // DON'T DO THIS! Just for demonstration
        std::mem::transmute::&lt;&amp;str, &amp;'static str&gt;(&amp;data)
    };

    // This could lead to use-after-free if data is dropped
    // while static_ref is still in use
    println!("Extended reference: {}", static_ref);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="creating-custom-unsafe-functions"><a class="header" href="#creating-custom-unsafe-functions">Creating Custom Unsafe Functions</a></h3>
<p>When creating your own unsafe functions, follow these best practices:</p>
<h4 id="1-only-mark-functions-as-unsafe-when-necessary"><a class="header" href="#1-only-mark-functions-as-unsafe-when-necessary">1. Only Mark Functions as Unsafe When Necessary</a></h4>
<p>Don’t use <code>unsafe</code> just to bypass the borrow checker; only mark functions as unsafe if they have genuine safety preconditions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: This function has clear safety requirements
unsafe fn as_bytes_mut&lt;T&gt;(value: &amp;mut T) -&gt; &amp;mut [u8] {
    let size = std::mem::size_of::&lt;T&gt;();
    std::slice::from_raw_parts_mut(
        value as *mut T as *mut u8,
        size
    )
}

// Bad: This doesn't need to be unsafe
unsafe fn add_one(x: i32) -&gt; i32 {
    x + 1  // No unsafe operations or preconditions
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-document-safety-requirements"><a class="header" href="#2-document-safety-requirements">2. Document Safety Requirements</a></h4>
<p>Always document what callers need to ensure for safety:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Reads a value of type T from the provided address.
///
/// # Safety
///
/// The caller must ensure:
/// - `addr` is properly aligned for T
/// - `addr` points to an initialized value of type T
/// - The memory at `addr` is not being concurrently modified
unsafe fn read_from_addr&lt;T: Copy&gt;(addr: usize) -&gt; T {
    *(addr as *const T)
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-consider-safe-alternatives"><a class="header" href="#3-consider-safe-alternatives">3. Consider Safe Alternatives</a></h4>
<p>Before creating an unsafe function, consider if there’s a safe way to achieve the same goal:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of this unsafe function:
unsafe fn get_first_unchecked&lt;T&gt;(slice: &amp;[T]) -&gt; &amp;T {
    &amp;*slice.as_ptr()
}

// Provide a safe version:
fn get_first&lt;T&gt;(slice: &amp;[T]) -&gt; Option&lt;&amp;T&gt; {
    slice.first()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="common-pitfalls-with-unsafe-functions"><a class="header" href="#common-pitfalls-with-unsafe-functions">Common Pitfalls with Unsafe Functions</a></h3>
<p>Here are some common mistakes to avoid:</p>
<h4 id="1-assuming-functions-are-safe"><a class="header" href="#1-assuming-functions-are-safe">1. Assuming Functions Are Safe</a></h4>
<p>Don’t assume a function is safe just because it doesn’t have an explicit <code>unsafe</code> marker:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn assuming_safety() {
    let ptr: *const i32 = std::ptr::null();

    // BAD: This could be undefined behavior if ptr is invalid
    unsafe {
        let val = ptr.offset(3);  // offset doesn't check if ptr is valid
    }

    // GOOD: Check validity first
    if !ptr.is_null() {
        unsafe {
            let val = ptr.offset(3);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-ignoring-returned-values"><a class="header" href="#2-ignoring-returned-values">2. Ignoring Returned Values</a></h4>
<p>Some unsafe functions return values that should be checked:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ignoring_returns() {
    use std::alloc::{alloc, dealloc, Layout};

    // Get a layout for 4 bytes with alignment of 4
    let layout = Layout::from_size_align(4, 4).unwrap();

    unsafe {
        // BAD: Not checking if allocation succeeded
        let ptr = alloc(layout);

        // GOOD: Check for allocation failure
        if ptr.is_null() {
            panic!("Allocation failed");
        }

        // Use the memory...

        // Clean up
        dealloc(ptr, layout);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-not-handling-panics"><a class="header" href="#3-not-handling-panics">3. Not Handling Panics</a></h4>
<p>If your unsafe function can panic, consider the safety implications:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: This function could panic, leaving the state inconsistent
unsafe fn initialize_buffer(buf: &amp;mut [u8], values: &amp;[u8]) {
    // This will panic if values.len() &gt; buf.len()
    for i in 0..values.len() {
        buf[i] = values[i];
    }
}

// GOOD: Handle potential panic conditions
unsafe fn initialize_buffer_safe(buf: &amp;mut [u8], values: &amp;[u8]) -&gt; Result&lt;(), &amp;'static str&gt; {
    if values.len() &gt; buf.len() {
        return Err("Values too large for buffer");
    }

    for i in 0..values.len() {
        buf[i] = values[i];
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h4 id="4-returning-dangling-references"><a class="header" href="#4-returning-dangling-references">4. Returning Dangling References</a></h4>
<p>Ensure references returned from unsafe functions have appropriate lifetimes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: Returns a reference to a temporary value
unsafe fn dangling_reference&lt;'a&gt;() -&gt; &amp;'a i32 {
    let value = 42;
    &amp;value  // This reference becomes invalid when the function returns
}

// GOOD: Properly ties the reference lifetime to an input
unsafe fn valid_reference&lt;'a&gt;(data: &amp;'a [u8]) -&gt; &amp;'a i32 {
    assert!(data.len() &gt;= std::mem::size_of::&lt;i32&gt;());
    &amp;*(data.as_ptr() as *const i32)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="soundness-in-unsafe-code"><a class="header" href="#soundness-in-unsafe-code">Soundness in Unsafe Code</a></h3>
<p>A function is considered “sound” if it maintains Rust’s safety guarantees when used according to its public API. This is crucial for unsafe functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// UNSOUND: This can cause undefined behavior even when used "correctly"
unsafe fn unsound_function(slice: &amp;[u8]) -&gt; &amp;[u16] {
    // This is unsound because it doesn't check alignment and might create
    // an unaligned reference to u16, which can cause UB on some platforms
    std::slice::from_raw_parts(
        slice.as_ptr() as *const u16,
        slice.len() / 2
    )
}

// SOUND: This adds the necessary checks
unsafe fn sound_function(slice: &amp;[u8]) -&gt; Option&lt;&amp;[u16]&gt; {
    // Check length
    if slice.len() % 2 != 0 {
        return None;
    }

    // Check alignment
    if (slice.as_ptr() as usize) % std::mem::align_of::&lt;u16&gt;() != 0 {
        return None;
    }

    Some(std::slice::from_raw_parts(
        slice.as_ptr() as *const u16,
        slice.len() / 2
    ))
}
<span class="boring">}</span></code></pre></pre>
<p>In the next section, we’ll explore FFI (Foreign Function Interface), which allows Rust to interact with code written in other languages like C.</p>
<h2 id="ffi-and-external-code"><a class="header" href="#ffi-and-external-code">FFI and External Code</a></h2>
<p>One of the most common uses of unsafe code is interacting with code written in other languages, particularly C and C++. Rust’s Foreign Function Interface (FFI) allows you to call foreign code and expose Rust functions to be called from other languages.</p>
<h3 id="calling-c-functions-from-rust"><a class="header" href="#calling-c-functions-from-rust">Calling C Functions from Rust</a></h3>
<p>To call C functions from Rust, you declare them using the <code>extern</code> block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Declare C functions from the standard library
#[link(name = "c")]
extern "C" {
    fn strlen(s: *const libc::c_char) -&gt; libc::size_t;
    fn printf(format: *const libc::c_char, ...) -&gt; libc::c_int;
}

fn call_c_functions() {
    let c_string = std::ffi::CString::new("Hello from C!").unwrap();

    unsafe {
        // Call strlen to get the length of the string
        let length = strlen(c_string.as_ptr());
        println!("String length: {}", length);  // 13

        // Call printf to print a message
        printf(b"C says: %s\n\0".as_ptr() as *const libc::c_char, c_string.as_ptr());
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="working-with-c-types"><a class="header" href="#working-with-c-types">Working with C Types</a></h3>
<p>Rust provides several types to work with C data:</p>
<h4 id="c-strings"><a class="header" href="#c-strings">C Strings</a></h4>
<p>C strings are null-terminated, unlike Rust’s UTF-8 strings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ffi::{CString, CStr};
use std::os::raw::c_char;

fn c_string_examples() {
    // Create a C string from a Rust string
    let rust_str = "Hello, world!";
    let c_string = CString::new(rust_str).unwrap();

    // Get a pointer to pass to C functions
    let ptr = c_string.as_ptr();

    // Create a C string from a raw pointer (usually from a C function)
    unsafe {
        // Assume ptr is from a C function and is null-terminated
        let c_str = CStr::from_ptr(ptr);

        // Convert to a Rust String
        let rust_string = c_str.to_string_lossy().into_owned();
        println!("Converted back: {}", rust_string);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="structs-and-unions"><a class="header" href="#structs-and-unions">Structs and Unions</a></h4>
<p>Structs and unions can be shared between Rust and C:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A struct layout compatible with C
#[repr(C)]
struct Point {
    x: f64,
    y: f64,
}

// A union layout compatible with C
#[repr(C)]
union IntOrFloat {
    i: i32,
    f: f32,
}

extern "C" {
    fn process_point(p: Point) -&gt; f64;
    fn process_union(u: IntOrFloat) -&gt; i32;
}

fn use_c_compatible_types() {
    let point = Point { x: 1.0, y: 2.0 };

    unsafe {
        let distance = process_point(point);
        println!("Distance: {}", distance);

        let u = IntOrFloat { i: 42 };
        let result = process_union(u);
        println!("Result: {}", result);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-management-across-ffi-boundaries"><a class="header" href="#memory-management-across-ffi-boundaries">Memory Management Across FFI Boundaries</a></h3>
<p>When working with FFI, you need to be careful about memory management:</p>
<h4 id="ownership-transfer"><a class="header" href="#ownership-transfer">Ownership Transfer</a></h4>
<p>When transferring ownership of memory between Rust and C:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Allocate memory in Rust and transfer to C
extern "C" {
    fn c_function_that_frees(ptr: *mut libc::c_void);
}

fn transfer_to_c() {
    // Allocate in Rust
    let data = Box::new(42);

    // Convert to a raw pointer and forget ownership
    let ptr = Box::into_raw(data);

    unsafe {
        // C function takes ownership and frees the memory
        c_function_that_frees(ptr as *mut libc::c_void);
    }

    // Don't use `ptr` after this point!
}

// Receive memory allocated by C
extern "C" {
    fn c_function_that_allocates() -&gt; *mut libc::c_void;
}

fn receive_from_c() {
    unsafe {
        // Get memory from C
        let ptr = c_function_that_allocates();

        if ptr.is_null() {
            println!("Allocation failed");
            return;
        }

        // Convert to a Box to manage the memory in Rust
        let boxed = Box::from_raw(ptr as *mut i32);

        // Now Rust owns the memory and will free it when boxed is dropped
        println!("Value: {}", *boxed);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="callbacks-from-c-to-rust"><a class="header" href="#callbacks-from-c-to-rust">Callbacks from C to Rust</a></h3>
<p>C functions often take function pointers as callbacks. Here’s how to provide Rust functions as callbacks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::os::raw::{c_int, c_void};

// Define the callback type
type Callback = extern "C" fn(value: c_int) -&gt; c_int;

// A Rust function with C calling convention
extern "C" fn rust_callback(value: c_int) -&gt; c_int {
    println!("Callback called with value: {}", value);
    value * 2
}

// C function that takes a callback
extern "C" {
    fn register_callback(cb: Callback);
    fn call_registered_callback(value: c_int) -&gt; c_int;
}

fn use_callbacks() {
    unsafe {
        // Register our Rust function as a callback
        register_callback(rust_callback);

        // Trigger the callback from C
        let result = call_registered_callback(42);
        println!("Result: {}", result);  // 84
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exposing-rust-functions-to-c"><a class="header" href="#exposing-rust-functions-to-c">Exposing Rust Functions to C</a></h3>
<p>You can also make Rust functions callable from C:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Export a Rust function with C calling convention
#[no_mangle]
pub extern "C" fn rust_function(value: libc::c_int) -&gt; libc::c_int {
    // Rust implementation
    value * 2
}
<span class="boring">}</span></code></pre></pre>
<p>Key points for exporting Rust functions:</p>
<ol>
<li><strong>Use <code>#[no_mangle]</code></strong>: Prevents name mangling, ensuring the function name in the compiled library matches the one you declared.</li>
<li><strong>Use <code>extern "C"</code></strong>: Specifies the C calling convention.</li>
<li><strong>Use C-compatible types</strong>: Use types from <code>std::os::raw</code> or <code>libc</code> for parameters and return values.</li>
</ol>
<h3 id="building-a-c-api-in-rust"><a class="header" href="#building-a-c-api-in-rust">Building a C API in Rust</a></h3>
<p>Here’s a simplified example of building a C-compatible API in Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define C-compatible types
#[repr(C)]
pub struct RustObject {
    value: i32,
    name: *mut libc::c_char,
}

// Constructor
#[no_mangle]
pub extern "C" fn rust_object_new(value: i32, name: *const libc::c_char) -&gt; *mut RustObject {
    let name_cstr = unsafe {
        if name.is_null() {
            return std::ptr::null_mut();
        }
        std::ffi::CStr::from_ptr(name)
    };

    let name_str = match name_cstr.to_str() {
        Ok(s) =&gt; s,
        Err(_) =&gt; return std::ptr::null_mut(),
    };

    let name_owned = match std::ffi::CString::new(name_str) {
        Ok(s) =&gt; s,
        Err(_) =&gt; return std::ptr::null_mut(),
    };

    let obj = Box::new(RustObject {
        value,
        name: name_owned.into_raw(),
    });

    Box::into_raw(obj)
}

// Destructor
#[no_mangle]
pub extern "C" fn rust_object_free(obj: *mut RustObject) {
    if !obj.is_null() {
        unsafe {
            // Reconstruct the CString to free the name memory
            let _ = std::ffi::CString::from_raw((*obj).name);
            // Reconstruct the Box to free the object
            let _ = Box::from_raw(obj);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-c-libraries-with-rust"><a class="header" href="#using-c-libraries-with-rust">Using C Libraries with Rust</a></h3>
<p>To use a C library in Rust, you typically need:</p>
<ol>
<li><strong>Bindings</strong>: Rust definitions of the C library’s types and functions</li>
<li><strong>Build configuration</strong>: Instructions for linking against the C library</li>
</ol>
<p>Here’s a simplified example using the <code>libgit2</code> C library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In Cargo.toml:
// [dependencies]
// libgit2-sys = "0.12"

use libgit2_sys::*;
use std::ffi::CString;
use std::ptr;

fn use_libgit2() -&gt; Result&lt;(), String&gt; {
    unsafe {
        // Initialize the library
        let result = git_libgit2_init();
        if result &lt; 0 {
            return Err("Failed to initialize libgit2".to_string());
        }

        // Open a repository
        let repo_path = CString::new("/path/to/repo").unwrap();
        let mut repo: *mut git_repository = ptr::null_mut();

        let result = git_repository_open(&amp;mut repo, repo_path.as_ptr());
        if result &lt; 0 {
            git_libgit2_shutdown();
            return Err("Failed to open repository".to_string());
        }

        // Use the repository...

        // Clean up
        git_repository_free(repo);
        git_libgit2_shutdown();
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="generating-bindings-with-bindgen"><a class="header" href="#generating-bindings-with-bindgen">Generating Bindings with bindgen</a></h3>
<p>Manual bindings can be tedious. The <code>bindgen</code> tool can generate Rust bindings from C header files:</p>
<pre><pre class="playground"><code class="language-rust">// In build.rs:
extern crate bindgen;

use std::env;
use std::path::PathBuf;

fn main() {
    // Tell cargo to link against the library
    println!("cargo:rustc-link-lib=mylib");

    // Generate bindings
    let bindings = bindgen::Builder::default()
        .header("include/mylib.h")
        .generate()
        .expect("Unable to generate bindings");

    // Write the bindings to an output file
    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Couldn't write bindings!");
}</code></pre></pre>
<p>In the next section, we’ll explore how to implement safe abstractions over unsafe code, a key practice for building robust Rust libraries.</p>
<h2 id="implementing-safe-abstractions-over-unsafe-code"><a class="header" href="#implementing-safe-abstractions-over-unsafe-code">Implementing Safe Abstractions Over Unsafe Code</a></h2>
<p>One of the most important principles in Rust is that unsafe code should be encapsulated within safe abstractions. This approach allows us to build libraries that are both safe to use and efficient at their core.</p>
<h3 id="the-principle-of-safe-abstraction"><a class="header" href="#the-principle-of-safe-abstraction">The Principle of Safe Abstraction</a></h3>
<p>A safe abstraction over unsafe code follows these principles:</p>
<ol>
<li><strong>Unsafety is contained</strong>: Unsafe code is hidden inside functions that have safe interfaces.</li>
<li><strong>Invariants are maintained</strong>: The abstraction ensures that any safety conditions required by the unsafe code are always met.</li>
<li><strong>API is impossible to misuse</strong>: Users cannot trigger undefined behavior through the public API.</li>
</ol>
<h3 id="examples-of-safe-abstractions-in-the-standard-library"><a class="header" href="#examples-of-safe-abstractions-in-the-standard-library">Examples of Safe Abstractions in the Standard Library</a></h3>
<p>The Rust standard library contains many examples of safe abstractions over unsafe code:</p>
<h4 id="vec"><a class="header" href="#vec">Vec<T></a></h4>
<p>The <code>Vec&lt;T&gt;</code> type uses unsafe code internally to manage memory efficiently, but presents a safe API:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simplified version of Vec's internals
pub struct Vec&lt;T&gt; {
    ptr: *mut T,
    cap: usize,
    len: usize,
}

impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn push(&amp;mut self, item: T) {
        // Safety check: ensure capacity
        if self.len == self.cap {
            self.grow();
        }

        unsafe {
            // This is safe because:
            // 1. We've checked that len &lt; cap
            // 2. We have exclusive access via &amp;mut self
            std::ptr::write(self.ptr.add(self.len), item);
            self.len += 1;
        }
    }

    // ... other methods ...
}

impl&lt;T&gt; Drop for Vec&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            // Drop all elements
            for i in 0..self.len {
                std::ptr::drop_in_place(self.ptr.add(i));
            }

            // Deallocate memory
            if self.cap &gt; 0 {
                let layout = std::alloc::Layout::array::&lt;T&gt;(self.cap).unwrap();
                std::alloc::dealloc(self.ptr as *mut u8, layout);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="string"><a class="header" href="#string">String</a></h4>
<p>Similarly, <code>String</code> uses unsafe code internally to handle UTF-8 validation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl String {
    pub fn push_str(&amp;mut self, string: &amp;str) {
        self.vec.extend_from_slice(string.as_bytes());
    }

    pub fn as_str(&amp;self) -&gt; &amp;str {
        unsafe {
            // This is safe because:
            // 1. We've validated the UTF-8 when creating the String
            // 2. We never insert invalid UTF-8 bytes
            std::str::from_utf8_unchecked(&amp;self.vec)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="building-your-own-safe-abstractions"><a class="header" href="#building-your-own-safe-abstractions">Building Your Own Safe Abstractions</a></h3>
<p>Let’s explore how to build safe abstractions with a few examples:</p>
<h4 id="example-1-a-safe-api-for-memory-mapping"><a class="header" href="#example-1-a-safe-api-for-memory-mapping">Example 1: A Safe API for Memory Mapping</a></h4>
<p>Here’s a safe wrapper for memory-mapped files:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MemoryMappedFile {
    ptr: *mut u8,
    size: usize,
}

impl MemoryMappedFile {
    pub fn new(path: &amp;str) -&gt; Result&lt;Self, std::io::Error&gt; {
        use std::fs::File;
        use std::os::unix::io::AsRawFd;

        let file = File::open(path)?;
        let size = file.metadata()?.len() as usize;

        if size == 0 {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidInput,
                "Cannot memory map an empty file"
            ));
        }

        // Unsafe operation wrapped in a safe function
        let ptr = unsafe {
            let ptr = libc::mmap(
                std::ptr::null_mut(),
                size,
                libc::PROT_READ,
                libc::MAP_PRIVATE,
                file.as_raw_fd(),
                0,
            );

            if ptr == libc::MAP_FAILED {
                return Err(std::io::Error::last_os_error());
            }

            ptr as *mut u8
        };

        Ok(MemoryMappedFile { ptr, size })
    }

    pub fn as_slice(&amp;self) -&gt; &amp;[u8] {
        unsafe {
            // This is safe because:
            // 1. The pointer is valid (checked in new())
            // 2. The memory is properly aligned for u8
            // 3. The memory is initialized (from the file)
            // 4. The lifetime is tied to &amp;self
            std::slice::from_raw_parts(self.ptr, self.size)
        }
    }
}

impl Drop for MemoryMappedFile {
    fn drop(&amp;mut self) {
        unsafe {
            libc::munmap(self.ptr as *mut libc::c_void, self.size);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="example-2-a-type-safe-array-view"><a class="header" href="#example-2-a-type-safe-array-view">Example 2: A Type-Safe Array View</a></h4>
<p>Here’s a safe abstraction for viewing arrays of different types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ArrayView&lt;'a, T&gt; {
    data: &amp;'a [u8],
    _phantom: std::marker::PhantomData&lt;T&gt;,
}

impl&lt;'a, T&gt; ArrayView&lt;'a, T&gt; {
    pub fn new(data: &amp;'a [u8]) -&gt; Option&lt;Self&gt; {
        // Check if the data can hold at least one T
        if data.len() &lt; std::mem::size_of::&lt;T&gt;() {
            return None;
        }

        // Check alignment
        if (data.as_ptr() as usize) % std::mem::align_of::&lt;T&gt;() != 0 {
            return None;
        }

        // Check if data length is a multiple of T's size
        if data.len() % std::mem::size_of::&lt;T&gt;() != 0 {
            return None;
        }

        Some(ArrayView {
            data,
            _phantom: std::marker::PhantomData,
        })
    }

    pub fn len(&amp;self) -&gt; usize {
        self.data.len() / std::mem::size_of::&lt;T&gt;()
    }

    pub fn get(&amp;self, index: usize) -&gt; Option&lt;&amp;T&gt; {
        if index &gt;= self.len() {
            return None;
        }

        unsafe {
            // This is safe because:
            // 1. We've checked the alignment in new()
            // 2. We've checked the index is in bounds
            // 3. The lifetime is tied to &amp;self
            let ptr = self.data.as_ptr() as *const T;
            Some(&amp;*ptr.add(index))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="techniques-for-building-safe-abstractions"><a class="header" href="#techniques-for-building-safe-abstractions">Techniques for Building Safe Abstractions</a></h3>
<p>Here are some key techniques for building safe abstractions:</p>
<h4 id="1-make-invalid-states-unrepresentable"><a class="header" href="#1-make-invalid-states-unrepresentable">1. Make Invalid States Unrepresentable</a></h4>
<p>Design your API so that invalid states cannot be represented:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: User could set len &gt; cap, causing undefined behavior
pub struct UnsafeVec&lt;T&gt; {
    pub ptr: *mut T,
    pub cap: usize,
    pub len: usize,
}

// GOOD: Users cannot directly modify internal fields
pub struct SafeVec&lt;T&gt; {
    ptr: *mut T,
    cap: usize,
    len: usize,
}

impl&lt;T&gt; SafeVec&lt;T&gt; {
    pub fn len(&amp;self) -&gt; usize {
        self.len
    }

    pub fn capacity(&amp;self) -&gt; usize {
        self.cap
    }

    pub fn push(&amp;mut self, item: T) {
        // Safety checks and implementation...
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-use-types-to-enforce-invariants"><a class="header" href="#2-use-types-to-enforce-invariants">2. Use Types to Enforce Invariants</a></h4>
<p>Leverage Rust’s type system to enforce invariants:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A non-null pointer type
pub struct NonNull&lt;T&gt; {
    ptr: *mut T,
}

impl&lt;T&gt; NonNull&lt;T&gt; {
    pub fn new(ptr: *mut T) -&gt; Option&lt;Self&gt; {
        if ptr.is_null() {
            None
        } else {
            Some(NonNull { ptr })
        }
    }

    pub fn as_ptr(&amp;self) -&gt; *mut T {
        self.ptr
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-document-safety-requirements"><a class="header" href="#3-document-safety-requirements">3. Document Safety Requirements</a></h4>
<p>Clearly document the safety requirements for any unsafe function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Creates a slice from a raw pointer and length.
///
/// # Safety
///
/// The caller must ensure:
/// 1. `ptr` is valid for reads of `len * size_of::&lt;T&gt;()` bytes
/// 2. `ptr` is properly aligned for `T`
/// 3. The memory referenced by `ptr` is initialized
/// 4. The memory referenced by `ptr` is not mutated during the lifetime of the returned slice
unsafe fn raw_slice&lt;'a, T&gt;(ptr: *const T, len: usize) -&gt; &amp;'a [T] {
    std::slice::from_raw_parts(ptr, len)
}
<span class="boring">}</span></code></pre></pre>
<h4 id="4-comprehensive-testing"><a class="header" href="#4-comprehensive-testing">4. Comprehensive Testing</a></h4>
<p>Test your safe abstractions thoroughly, including edge cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_array_view_alignment() {
    // Create an unaligned buffer
    let mut data = vec![0u8; 100];
    let unaligned_ptr = data.as_mut_ptr().wrapping_add(1);
    let unaligned_len = 99;
    let unaligned_slice = unsafe {
        std::slice::from_raw_parts(unaligned_ptr, unaligned_len)
    };

    // This should return None due to misalignment for u32
    let view: Option&lt;ArrayView&lt;u32&gt;&gt; = ArrayView::new(unaligned_slice);
    assert!(view.is_none());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="common-patterns-for-safe-abstractions"><a class="header" href="#common-patterns-for-safe-abstractions">Common Patterns for Safe Abstractions</a></h3>
<p>Several common patterns emerge when building safe abstractions:</p>
<h4 id="the-newtype-pattern"><a class="header" href="#the-newtype-pattern">The Newtype Pattern</a></h4>
<p>Wrap a primitive type to enforce invariants:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A type that guarantees its value is non-zero
pub struct NonZeroU32(u32);

impl NonZeroU32 {
    pub fn new(value: u32) -&gt; Option&lt;Self&gt; {
        if value == 0 {
            None
        } else {
            Some(NonZeroU32(value))
        }
    }

    pub fn get(&amp;self) -&gt; u32 {
        self.0
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="the-builder-pattern"><a class="header" href="#the-builder-pattern">The Builder Pattern</a></h4>
<p>Use a builder to ensure objects are properly initialized:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ComplexObject {
    // Fields...
}

pub struct ComplexObjectBuilder {
    // Builder fields...
}

impl ComplexObjectBuilder {
    pub fn new() -&gt; Self {
        // Initialize with defaults...
        ComplexObjectBuilder { /* ... */ }
    }

    pub fn set_field1(&amp;mut self, value: i32) -&gt; &amp;mut Self {
        // Set field...
        self
    }

    pub fn set_field2(&amp;mut self, value: String) -&gt; &amp;mut Self {
        // Set field...
        self
    }

    pub fn build(self) -&gt; Result&lt;ComplexObject, &amp;'static str&gt; {
        // Validate all fields...
        // Return error if invalid...

        // Create object if valid
        Ok(ComplexObject { /* ... */ })
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="the-raii-pattern"><a class="header" href="#the-raii-pattern">The RAII Pattern</a></h4>
<p>Use the RAII (Resource Acquisition Is Initialization) pattern to manage resources:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MutexGuard&lt;'a, T&gt; {
    lock: &amp;'a Mutex&lt;T&gt;,
    data: *mut T,
}

impl&lt;'a, T&gt; MutexGuard&lt;'a, T&gt; {
    fn new(lock: &amp;'a Mutex&lt;T&gt;) -&gt; Self {
        unsafe {
            // Acquire the lock...
            let data = /* get pointer to data */;
            MutexGuard { lock, data }
        }
    }
}

impl&lt;'a, T&gt; std::ops::Deref for MutexGuard&lt;'a, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        unsafe { &amp;*self.data }
    }
}

impl&lt;'a, T&gt; std::ops::DerefMut for MutexGuard&lt;'a, T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        unsafe { &amp;mut *self.data }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="auditing-your-safe-abstractions"><a class="header" href="#auditing-your-safe-abstractions">Auditing Your Safe Abstractions</a></h3>
<p>Periodically audit your safe abstractions to ensure they remain sound:</p>
<ol>
<li><strong>Review the unsafe code</strong>: Make sure all preconditions are checked.</li>
<li><strong>Check thread safety</strong>: Ensure your abstraction is safe in multithreaded contexts.</li>
<li><strong>Consider panic safety</strong>: What happens if code panics while holding resources?</li>
<li><strong>Look for edge cases</strong>: Test with extreme values, empty collections, etc.</li>
<li><strong>Update after compiler changes</strong>: New compiler optimizations might affect assumptions.</li>
</ol>
<h3 id="remember-the-safety-contract"><a class="header" href="#remember-the-safety-contract">Remember the Safety Contract</a></h3>
<p>When building safe abstractions, you’re entering into a contract with users of your API:</p>
<ol>
<li><strong>Your code won’t cause undefined behavior when used correctly</strong></li>
<li><strong>Your API makes it hard or impossible to use incorrectly</strong></li>
<li><strong>Your documentation clearly explains any requirements or limitations</strong></li>
</ol>
<p>By following these principles, you can create APIs that are both safe and efficient, leveraging unsafe code for performance while protecting users from its dangers.</p>
<p>In the next section, we’ll explore undefined behavior and how to avoid it in your unsafe code.</p>
<h2 id="undefined-behavior-and-how-to-avoid-it"><a class="header" href="#undefined-behavior-and-how-to-avoid-it">Undefined Behavior and How to Avoid It</a></h2>
<p>Undefined behavior (UB) is one of the most dangerous aspects of unsafe Rust. Unlike safe Rust, which prevents undefined behavior at compile time, unsafe Rust shifts this responsibility to the programmer.</p>
<h3 id="what-is-undefined-behavior"><a class="header" href="#what-is-undefined-behavior">What Is Undefined Behavior?</a></h3>
<p>Undefined behavior is a condition that occurs when a program performs an operation whose behavior is not specified by the language. When undefined behavior occurs:</p>
<ol>
<li>The program may crash</li>
<li>The program may produce incorrect results</li>
<li>The program may appear to work correctly</li>
<li>The program’s behavior may change with different compiler versions or optimization levels</li>
<li>The program may do something completely unexpected</li>
</ol>
<p>What makes undefined behavior particularly dangerous is that it can appear to work correctly in testing but fail catastrophically in production.</p>
<h3 id="common-sources-of-undefined-behavior"><a class="header" href="#common-sources-of-undefined-behavior">Common Sources of Undefined Behavior</a></h3>
<h4 id="1-dereferencing-null-or-invalid-pointers"><a class="header" href="#1-dereferencing-null-or-invalid-pointers">1. Dereferencing Null or Invalid Pointers</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn null_pointer_dereference() {
    let ptr: *const i32 = std::ptr::null();

    unsafe {
        // UNDEFINED BEHAVIOR: Dereferencing null pointer
        let value = *ptr;
    }
}

fn use_after_free() {
    let boxed = Box::new(42);
    let ptr = Box::into_raw(boxed);

    // Free the memory
    unsafe {
        drop(Box::from_raw(ptr));
    }

    // UNDEFINED BEHAVIOR: Use after free
    unsafe {
        println!("Value: {}", *ptr);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-data-races"><a class="header" href="#2-data-races">2. Data Races</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::sync::Arc;

fn data_race() {
    let mut value = 42;
    let ptr = &amp;mut value as *mut i32;

    let handle = thread::spawn(move || {
        // Thread accesses the value through a raw pointer
        unsafe {
            *ptr = 100;
        }
    });

    // UNDEFINED BEHAVIOR: Main thread accesses while another thread modifies
    value += 1;

    handle.join().unwrap();
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-invalid-alignment"><a class="header" href="#3-invalid-alignment">3. Invalid Alignment</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn invalid_alignment() {
    let data = [0u8; 8];

    // Create a misaligned pointer
    let misaligned_ptr = (data.as_ptr() as usize + 1) as *const u32;

    unsafe {
        // UNDEFINED BEHAVIOR: Misaligned memory access
        let value = *misaligned_ptr;
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="4-violating-rusts-aliasing-rules"><a class="header" href="#4-violating-rusts-aliasing-rules">4. Violating Rust’s Aliasing Rules</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn aliasing_violation() {
    let mut value = 42;

    // Create a mutable reference
    let ref_mut = &amp;mut value;

    // Create a raw pointer and cast to mutable
    let raw_ptr = &amp;value as *const i32 as *mut i32;

    unsafe {
        // UNDEFINED BEHAVIOR: Modifying through raw pointer while mutable reference exists
        *raw_ptr = 100;
    }

    // Use the mutable reference
    *ref_mut += 1;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="5-uninitialized-memory"><a class="header" href="#5-uninitialized-memory">5. Uninitialized Memory</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn uninitialized_memory() {
    let mut value: i32;

    // UNDEFINED BEHAVIOR: Reading uninitialized memory
    unsafe {
        println!("Uninitialized: {}", value);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="6-out-of-bounds-memory-access"><a class="header" href="#6-out-of-bounds-memory-access">6. Out-of-Bounds Memory Access</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn out_of_bounds() {
    let array = [1, 2, 3, 4, 5];
    let ptr = array.as_ptr();

    unsafe {
        // UNDEFINED BEHAVIOR: Accessing beyond array bounds
        let value = *ptr.add(10);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="7-invalid-utf-8"><a class="header" href="#7-invalid-utf-8">7. Invalid UTF-8</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn invalid_utf8() {
    let bytes = [0xFF, 0xFF];  // Invalid UTF-8

    unsafe {
        // UNDEFINED BEHAVIOR: Creating &amp;str from invalid UTF-8
        let s = std::str::from_utf8_unchecked(&amp;bytes);
        println!("String: {}", s);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="detecting-undefined-behavior"><a class="header" href="#detecting-undefined-behavior">Detecting Undefined Behavior</a></h3>
<p>Detecting undefined behavior can be challenging because it might not manifest as an obvious error. Here are some tools and techniques to help:</p>
<h4 id="1-address-sanitizer-asan"><a class="header" href="#1-address-sanitizer-asan">1. Address Sanitizer (ASan)</a></h4>
<p>ASan is a memory error detector that can find issues like use-after-free and buffer overflows:</p>
<pre><code class="language-bash"># Compile with Address Sanitizer
RUSTFLAGS="-Z sanitizer=address" cargo run --target x86_64-unknown-linux-gnu
</code></pre>
<h4 id="2-memory-sanitizer-msan"><a class="header" href="#2-memory-sanitizer-msan">2. Memory Sanitizer (MSan)</a></h4>
<p>MSan detects uninitialized memory reads:</p>
<pre><code class="language-bash"># Compile with Memory Sanitizer
RUSTFLAGS="-Z sanitizer=memory" cargo run --target x86_64-unknown-linux-gnu
</code></pre>
<h4 id="3-thread-sanitizer-tsan"><a class="header" href="#3-thread-sanitizer-tsan">3. Thread Sanitizer (TSan)</a></h4>
<p>TSan helps detect data races:</p>
<pre><code class="language-bash"># Compile with Thread Sanitizer
RUSTFLAGS="-Z sanitizer=thread" cargo run --target x86_64-unknown-linux-gnu
</code></pre>
<h4 id="4-miri-interpreter"><a class="header" href="#4-miri-interpreter">4. Miri Interpreter</a></h4>
<p>Miri is an interpreter for Rust’s mid-level intermediate representation (MIR) that can detect various forms of undefined behavior:</p>
<pre><code class="language-bash"># Install Miri
rustup component add miri
# Run tests with Miri
cargo miri test
</code></pre>
<h4 id="5-debugging-with-assertions"><a class="header" href="#5-debugging-with-assertions">5. Debugging with Assertions</a></h4>
<p>Add assertions to check preconditions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn risky_operation(ptr: *const i32, len: usize) -&gt; i32 {
    debug_assert!(!ptr.is_null(), "Null pointer in risky_operation");
    debug_assert!(len &gt; 0, "Zero length in risky_operation");

    // Rest of the function...
    *ptr
}
<span class="boring">}</span></code></pre></pre>
<h3 id="preventing-undefined-behavior"><a class="header" href="#preventing-undefined-behavior">Preventing Undefined Behavior</a></h3>
<p>Here are strategies to prevent undefined behavior in unsafe code:</p>
<h4 id="1-minimize-unsafe-code"><a class="header" href="#1-minimize-unsafe-code">1. Minimize Unsafe Code</a></h4>
<p>The simplest way to avoid undefined behavior is to minimize unsafe code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of this:
fn get_first_unsafe&lt;T&gt;(slice: &amp;[T]) -&gt; Option&lt;&amp;T&gt; {
    if slice.is_empty() {
        None
    } else {
        unsafe { Some(&amp;*slice.as_ptr()) }
    }
}

// Use safe Rust:
fn get_first&lt;T&gt;(slice: &amp;[T]) -&gt; Option&lt;&amp;T&gt; {
    slice.first()
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-add-runtime-checks"><a class="header" href="#2-add-runtime-checks">2. Add Runtime Checks</a></h4>
<p>Add runtime checks to verify preconditions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn safe_array_access&lt;T&gt;(array: &amp;[T], index: usize) -&gt; Option&lt;&amp;T&gt; {
    if index &lt; array.len() {
        // Safe: index is in bounds
        Some(&amp;array[index])
    } else {
        None
    }
}

// Unsafe version with checks
unsafe fn unchecked_array_access&lt;T&gt;(array: &amp;[T], index: usize) -&gt; &amp;T {
    debug_assert!(index &lt; array.len(), "Index out of bounds");
    &amp;*array.as_ptr().add(index)
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-use-safe-abstractions"><a class="header" href="#3-use-safe-abstractions">3. Use Safe Abstractions</a></h4>
<p>Wrap unsafe code in safe abstractions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Safe abstraction for aligned memory
pub struct AlignedBuffer&lt;T&gt; {
    ptr: *mut T,
    len: usize,
}

impl&lt;T&gt; AlignedBuffer&lt;T&gt; {
    pub fn new(len: usize) -&gt; Self {
        let layout = std::alloc::Layout::array::&lt;T&gt;(len).unwrap();
        let ptr = unsafe { std::alloc::alloc(layout) as *mut T };

        if ptr.is_null() {
            std::alloc::handle_alloc_error(layout);
        }

        AlignedBuffer { ptr, len }
    }

    pub fn as_slice(&amp;self) -&gt; &amp;[T] {
        unsafe { std::slice::from_raw_parts(self.ptr, self.len) }
    }

    pub fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T] {
        unsafe { std::slice::from_raw_parts_mut(self.ptr, self.len) }
    }
}

impl&lt;T&gt; Drop for AlignedBuffer&lt;T&gt; {
    fn drop(&amp;mut self) {
        let layout = std::alloc::Layout::array::&lt;T&gt;(self.len).unwrap();
        unsafe {
            std::alloc::dealloc(self.ptr as *mut u8, layout);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="4-use-the-standard-librarys-safe-functions"><a class="header" href="#4-use-the-standard-librarys-safe-functions">4. Use the Standard Library’s Safe Functions</a></h4>
<p>Prefer safe functions from the standard library when available:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of unsafe string conversion:
let bytes = "Hello".as_bytes();
let unsafe_str = unsafe { std::str::from_utf8_unchecked(bytes) };

// Use the safe version:
let safe_str = std::str::from_utf8(bytes).unwrap();
<span class="boring">}</span></code></pre></pre>
<h4 id="5-understand-and-follow-rusts-memory-model"><a class="header" href="#5-understand-and-follow-rusts-memory-model">5. Understand and Follow Rust’s Memory Model</a></h4>
<p>Familiarize yourself with Rust’s memory and aliasing rules:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn correct_aliasing() {
    let mut data = [1, 2, 3, 4, 5];

    // Split the slice into non-overlapping parts
    let (left, right) = data.split_at_mut(2);

    // Now we can safely modify both parts independently
    left[0] = 10;
    right[0] = 20;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="case-study-fixing-undefined-behavior"><a class="header" href="#case-study-fixing-undefined-behavior">Case Study: Fixing Undefined Behavior</a></h3>
<p>Let’s examine a case of undefined behavior and how to fix it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Original function with UB
fn copy_memory(src: &amp;[u8], dst: &amp;mut [u8]) {
    assert!(dst.len() &gt;= src.len());

    unsafe {
        // UB if src and dst overlap in certain ways
        std::ptr::copy_nonoverlapping(
            src.as_ptr(),
            dst.as_mut_ptr(),
            src.len()
        );
    }
}

// Fixed version
fn copy_memory_fixed(src: &amp;[u8], dst: &amp;mut [u8]) {
    assert!(dst.len() &gt;= src.len());

    // Check for overlapping memory regions
    let src_start = src.as_ptr() as usize;
    let src_end = src_start + src.len();
    let dst_start = dst.as_mut_ptr() as usize;
    let dst_end = dst_start + dst.len();

    if (src_start &lt;= dst_start &amp;&amp; dst_start &lt; src_end) ||
       (src_start &lt;= dst_end &amp;&amp; dst_end &lt; src_end) {
        // Memory regions overlap, use a safe copying method
        for i in 0..src.len() {
            dst[i] = src[i];
        }
    } else {
        // No overlap, safe to use copy_nonoverlapping
        unsafe {
            std::ptr::copy_nonoverlapping(
                src.as_ptr(),
                dst.as_mut_ptr(),
                src.len()
            );
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="understanding-the-compilers-assumptions"><a class="header" href="#understanding-the-compilers-assumptions">Understanding the Compiler’s Assumptions</a></h3>
<p>Modern compilers make optimizations based on assumptions about the absence of undefined behavior. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compiler_assumption() {
    let x = 0;
    let ptr = &amp;x as *const i32;

    // Compiler may assume this branch is never taken
    if unsafe { *ptr } != 0 {
        // Because x is 0, and the pointer points to x,
        // dereferencing it must yield 0 in the absence of UB
        println!("This won't be reached in practice");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>When you write unsafe code, remember that the compiler is free to make these assumptions and optimize accordingly. Violating these assumptions through undefined behavior can lead to surprising and difficult-to-debug issues.</p>
<h3 id="defensive-programming-with-unsafe-code"><a class="header" href="#defensive-programming-with-unsafe-code">Defensive Programming with Unsafe Code</a></h3>
<p>Practice defensive programming when writing unsafe code:</p>
<ol>
<li><strong>Document assumptions</strong>: Clearly document what conditions must be true for your unsafe code to be safe.</li>
<li><strong>Add debug assertions</strong>: Use <code>debug_assert!</code> to check preconditions in debug builds.</li>
<li><strong>Use the principle of least privilege</strong>: Give unsafe code the minimum capabilities it needs.</li>
<li><strong>Test edge cases</strong>: Explicitly test edge cases and boundary conditions.</li>
<li><strong>Review thoroughly</strong>: Have others review your unsafe code for potential issues.</li>
</ol>
<p>By understanding the sources of undefined behavior and actively working to prevent it, you can write unsafe Rust code that is reliable and maintainable.</p>
<h2 id="unsafe-patterns-and-best-practices"><a class="header" href="#unsafe-patterns-and-best-practices">Unsafe Patterns and Best Practices</a></h2>
<p>Now that we’ve explored the basics of unsafe Rust and how to avoid undefined behavior, let’s look at common patterns and best practices for working with unsafe code.</p>
<h3 id="common-unsafe-patterns"><a class="header" href="#common-unsafe-patterns">Common Unsafe Patterns</a></h3>
<h4 id="1-the-checked-unsafe-pattern"><a class="header" href="#1-the-checked-unsafe-pattern">1. The Checked Unsafe Pattern</a></h4>
<p>This pattern involves checking preconditions before performing unsafe operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn checked_unsafe_example&lt;T&gt;(slice: &amp;[T], index: usize) -&gt; Option&lt;&amp;T&gt; {
    if index &gt;= slice.len() {
        // Out of bounds, return None
        return None;
    }

    // All preconditions checked, safe to use unsafe
    unsafe {
        Some(&amp;*slice.as_ptr().add(index))
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-the-raii-wrapper-pattern"><a class="header" href="#2-the-raii-wrapper-pattern">2. The RAII Wrapper Pattern</a></h4>
<p>Wrap unsafe resources in a type that handles cleanup in its <code>Drop</code> implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MappedMemory {
    ptr: *mut u8,
    size: usize,
}

impl MappedMemory {
    fn new(size: usize) -&gt; Result&lt;Self, std::io::Error&gt; {
        // Allocate memory using mmap or similar
        let ptr = unsafe {
            // Call to mmap or similar
            std::ptr::null_mut() // Placeholder
        };

        if ptr.is_null() {
            return Err(std::io::Error::last_os_error());
        }

        Ok(MappedMemory { ptr, size })
    }

    fn as_slice(&amp;self) -&gt; &amp;[u8] {
        unsafe {
            std::slice::from_raw_parts(self.ptr, self.size)
        }
    }

    fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [u8] {
        unsafe {
            std::slice::from_raw_parts_mut(self.ptr, self.size)
        }
    }
}

impl Drop for MappedMemory {
    fn drop(&amp;mut self) {
        unsafe {
            // Free the memory (e.g., call munmap)
            // ...
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-the-interior-mutability-pattern"><a class="header" href="#3-the-interior-mutability-pattern">3. The Interior Mutability Pattern</a></h4>
<p>Use <code>UnsafeCell</code> to implement interior mutability:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::UnsafeCell;

struct MyCell&lt;T&gt; {
    value: UnsafeCell&lt;T&gt;,
}

impl&lt;T&gt; MyCell&lt;T&gt; {
    fn new(value: T) -&gt; Self {
        MyCell {
            value: UnsafeCell::new(value),
        }
    }

    fn get(&amp;self) -&gt; &amp;T {
        unsafe { &amp;*self.value.get() }
    }

    fn set(&amp;self, value: T) {
        unsafe {
            *self.value.get() = value;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="4-the-transmute-pattern"><a class="header" href="#4-the-transmute-pattern">4. The Transmute Pattern</a></h4>
<p>Use <code>transmute</code> to reinterpret types with identical memory layouts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn transmute_example() {
    let array: [u8; 4] = [0x01, 0x02, 0x03, 0x04];

    // Transmute from [u8; 4] to u32
    let value: u32 = unsafe {
        // Check that sizes match
        assert_eq!(std::mem::size_of::&lt;[u8; 4]&gt;(), std::mem::size_of::&lt;u32&gt;());
        std::mem::transmute(array)
    };

    println!("Value: {}", value);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="5-the-ffi-boundary-pattern"><a class="header" href="#5-the-ffi-boundary-pattern">5. The FFI Boundary Pattern</a></h4>
<p>Create a clear boundary between FFI code and safe Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FFI declarations
#[link(name = "my_c_lib")]
extern "C" {
    fn c_function(input: *const libc::c_char) -&gt; libc::c_int;
}

// Safe wrapper
fn safe_wrapper(input: &amp;str) -&gt; Result&lt;i32, String&gt; {
    // Convert Rust string to C string
    let c_string = match std::ffi::CString::new(input) {
        Ok(s) =&gt; s,
        Err(_) =&gt; return Err("String contains null bytes".to_string()),
    };

    // Call unsafe C function
    let result = unsafe { c_function(c_string.as_ptr()) };

    // Check for errors
    if result &lt; 0 {
        Err("C function returned an error".to_string())
    } else {
        Ok(result)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="best-practices-for-unsafe-code"><a class="header" href="#best-practices-for-unsafe-code">Best Practices for Unsafe Code</a></h3>
<p>Let’s explore best practices to make your unsafe code more maintainable and reliable:</p>
<h4 id="1-minimize-the-scope-of-unsafe-blocks"><a class="header" href="#1-minimize-the-scope-of-unsafe-blocks">1. Minimize the Scope of Unsafe Blocks</a></h4>
<p>Keep unsafe blocks as small as possible:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: Large unsafe block
unsafe fn process_data(data: &amp;[u8]) -&gt; u32 {
    // Many operations, some of which don't need to be unsafe
    let mut sum = 0;
    for i in 0..data.len() {
        sum += data[i] as u32;
    }
    sum
}

// GOOD: Minimal unsafe block
fn process_data_better(data: &amp;[u8]) -&gt; u32 {
    // Only the specific unsafe operation is in the unsafe block
    let special_value = unsafe { get_special_value() };

    // Regular safe code
    let mut sum = special_value;
    for byte in data {
        sum += *byte as u32;
    }
    sum
}

// Only this function needs to be unsafe
unsafe fn get_special_value() -&gt; u32 {
    // Some unsafe operation
    42
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-document-unsafe-code-thoroughly"><a class="header" href="#2-document-unsafe-code-thoroughly">2. Document Unsafe Code Thoroughly</a></h4>
<p>Always document your unsafe code with clear safety requirements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Creates a slice from a raw pointer and a length.
///
/// # Safety
///
/// The caller must ensure:
/// 1. `ptr` is valid for reads of `len * size_of::&lt;T&gt;()` bytes
/// 2. `ptr` is properly aligned for `T`
/// 3. The memory referenced by `ptr` is initialized
/// 4. The memory referenced by `ptr` is not mutated during the lifetime of the returned slice
unsafe fn raw_slice&lt;'a, T&gt;(ptr: *const T, len: usize) -&gt; &amp;'a [T] {
    std::slice::from_raw_parts(ptr, len)
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-add-debug-assertions"><a class="header" href="#3-add-debug-assertions">3. Add Debug Assertions</a></h4>
<p>Use debug assertions to check preconditions in debug builds:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn risky_function(ptr: *mut i32, len: usize) {
    debug_assert!(!ptr.is_null(), "Null pointer passed to risky_function");
    debug_assert!(len &gt; 0, "Zero length passed to risky_function");
    debug_assert!(len &lt;= 1000, "Excessive length passed to risky_function");

    // Actual implementation
    for i in 0..len {
        *ptr.add(i) = i as i32;
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="4-create-safe-abstractions"><a class="header" href="#4-create-safe-abstractions">4. Create Safe Abstractions</a></h4>
<p>Always prefer to expose a safe interface over unsafe code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Unsafe implementation details
mod internal {
    pub unsafe fn do_something_unsafe(ptr: *mut u8, len: usize) {
        // Unsafe implementation
    }
}

// Safe public API
pub fn do_something(data: &amp;mut [u8]) {
    unsafe {
        internal::do_something_unsafe(data.as_mut_ptr(), data.len());
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="5-write-comprehensive-tests"><a class="header" href="#5-write-comprehensive-tests">5. Write Comprehensive Tests</a></h4>
<p>Test your unsafe code thoroughly, especially edge cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_empty_slice() {
        let empty: [i32; 0] = [];
        let result = process_slice(&amp;empty);
        assert_eq!(result, 0);
    }

    #[test]
    fn test_large_slice() {
        let large = vec![42; 10000];
        let result = process_slice(&amp;large);
        assert_eq!(result, 420000);
    }

    #[test]
    fn test_edge_cases() {
        // Test various edge cases
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="6-use-safer-alternatives-when-available"><a class="header" href="#6-use-safer-alternatives-when-available">6. Use Safer Alternatives When Available</a></h4>
<p>Often, there are safer alternatives to direct unsafe code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of:
unsafe fn get_unchecked_value&lt;T&gt;(slice: &amp;[T], index: usize) -&gt; &amp;T {
    &amp;*slice.as_ptr().add(index)
}

// Use:
fn get_unchecked_value_safe&lt;T&gt;(slice: &amp;[T], index: usize) -&gt; Option&lt;&amp;T&gt; {
    slice.get(index)
}

// Or if performance is critical:
fn get_unchecked_value_checked&lt;T&gt;(slice: &amp;[T], index: usize) -&gt; &amp;T {
    assert!(index &lt; slice.len(), "Index out of bounds");
    unsafe { slice.get_unchecked(index) }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="7-audit-unsafe-code-regularly"><a class="header" href="#7-audit-unsafe-code-regularly">7. Audit Unsafe Code Regularly</a></h4>
<p>Review your unsafe code regularly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Mark code that needs regular review
#[allow(clippy::all)]
// ^-- Also consider adding a comment explaining why this code needs special attention
unsafe fn critical_function() {
    // Implementation that needs regular audit
}
<span class="boring">}</span></code></pre></pre>
<h3 id="advanced-unsafe-patterns"><a class="header" href="#advanced-unsafe-patterns">Advanced Unsafe Patterns</a></h3>
<p>Let’s explore some more advanced patterns used in real-world Rust code:</p>
<h4 id="1-the-almost-safe-pattern"><a class="header" href="#1-the-almost-safe-pattern">1. The “Almost Safe” Pattern</a></h4>
<p>Create a type that’s almost safe but requires one unsafe operation to use:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AlmostSafe&lt;T&gt; {
    ptr: *mut T,
    len: usize,
    _marker: std::marker::PhantomData&lt;T&gt;,
}

impl&lt;T&gt; AlmostSafe&lt;T&gt; {
    pub fn new(len: usize) -&gt; Self {
        let layout = std::alloc::Layout::array::&lt;T&gt;(len).unwrap();
        let ptr = unsafe { std::alloc::alloc(layout) as *mut T };

        if ptr.is_null() {
            std::alloc::handle_alloc_error(layout);
        }

        AlmostSafe {
            ptr,
            len,
            _marker: std::marker::PhantomData,
        }
    }

    // This requires unsafe because the caller must initialize the memory
    pub unsafe fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T] {
        std::slice::from_raw_parts_mut(self.ptr, self.len)
    }

    // This is safe once the memory has been initialized
    pub fn as_slice(&amp;self) -&gt; &amp;[T] {
        unsafe { std::slice::from_raw_parts(self.ptr, self.len) }
    }
}

impl&lt;T&gt; Drop for AlmostSafe&lt;T&gt; {
    fn drop(&amp;mut self) {
        let layout = std::alloc::Layout::array::&lt;T&gt;(self.len).unwrap();
        unsafe {
            // No need to drop T values because we're just a buffer
            std::alloc::dealloc(self.ptr as *mut u8, layout);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-the-tagged-union-pattern"><a class="header" href="#2-the-tagged-union-pattern">2. The Tagged Union Pattern</a></h4>
<p>Implement a memory-efficient tagged union:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct TaggedUnion&lt;T, U&gt; {
    tag: bool,
    // Using a union for the data
    data: DataUnion&lt;T, U&gt;,
}

#[repr(C)]
union DataUnion&lt;T, U&gt; {
    t: std::mem::ManuallyDrop&lt;T&gt;,
    u: std::mem::ManuallyDrop&lt;U&gt;,
}

impl&lt;T, U&gt; TaggedUnion&lt;T, U&gt; {
    pub fn new_t(value: T) -&gt; Self {
        TaggedUnion {
            tag: true,
            data: DataUnion {
                t: std::mem::ManuallyDrop::new(value),
            },
        }
    }

    pub fn new_u(value: U) -&gt; Self {
        TaggedUnion {
            tag: false,
            data: DataUnion {
                u: std::mem::ManuallyDrop::new(value),
            },
        }
    }

    pub fn is_t(&amp;self) -&gt; bool {
        self.tag
    }

    pub fn get_t(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        if self.tag {
            unsafe { Some(&amp;*std::mem::ManuallyDrop::into_inner(&amp;self.data.t)) }
        } else {
            None
        }
    }

    pub fn get_u(&amp;self) -&gt; Option&lt;&amp;U&gt; {
        if !self.tag {
            unsafe { Some(&amp;*std::mem::ManuallyDrop::into_inner(&amp;self.data.u)) }
        } else {
            None
        }
    }
}

impl&lt;T, U&gt; Drop for TaggedUnion&lt;T, U&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            if self.tag {
                std::mem::ManuallyDrop::drop(&amp;mut self.data.t);
            } else {
                std::mem::ManuallyDrop::drop(&amp;mut self.data.u);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-the-opaque-type-pattern"><a class="header" href="#3-the-opaque-type-pattern">3. The Opaque Type Pattern</a></h4>
<p>Hide implementation details behind an opaque type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Public interface
pub struct OpaqueType {
    // Private fields
    _private: (),
}

// Actual implementation with unsafe code
struct RealImplementation {
    ptr: *mut u8,
    len: usize,
}

// Public safe API
impl OpaqueType {
    pub fn new() -&gt; Self {
        let real = RealImplementation {
            ptr: std::ptr::null_mut(),
            len: 0,
        };

        // Store the real implementation somewhere (e.g., in a static or thread-local)
        // ...

        OpaqueType { _private: () }
    }

    pub fn do_something(&amp;self) -&gt; Result&lt;(), String&gt; {
        // Retrieve the real implementation
        // ...

        // Call the unsafe implementation safely
        Ok(())
    }
}

// Drop implementation to clean up resources
impl Drop for OpaqueType {
    fn drop(&amp;mut self) {
        // Clean up the real implementation
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="industry-best-practices-for-unsafe-rust"><a class="header" href="#industry-best-practices-for-unsafe-rust">Industry Best Practices for Unsafe Rust</a></h3>
<p>These are practices followed by experienced Rust developers in industry:</p>
<ol>
<li><strong>Hide unsafe implementation details</strong>: Keep unsafe code in private functions or modules.</li>
<li><strong>Make errors impossible</strong>: Design your API so that misuse is a compile-time error.</li>
<li><strong>Prefer safe alternatives</strong>: Use <code>get_unchecked</code> instead of raw pointer arithmetic when possible.</li>
<li><strong>Comment profusely</strong>: Explain why the unsafe code is safe, not just what it does.</li>
<li><strong>Use the <code>unsafe_op_in_unsafe_fn</code> lint</strong>: Consider enabling the <code>unsafe_op_in_unsafe_fn</code> lint to catch unsafe operations in unsafe functions that aren’t explicitly wrapped in an <code>unsafe</code> block.</li>
<li><strong>Enforce invariants with types</strong>: Use the type system to enforce as many invariants as possible.</li>
<li><strong>Follow the “defensive programming” approach</strong>: Assume that anything that can go wrong will go wrong.</li>
<li><strong>Conduct thorough code reviews</strong>: Have experienced Rust developers review your unsafe code.</li>
</ol>
<p>By following these patterns and best practices, you can write unsafe Rust code that is both efficient and maintainable.</p>
<h2 id="auditing-unsafe-code"><a class="header" href="#auditing-unsafe-code">Auditing Unsafe Code</a></h2>
<p>Auditing unsafe code is a critical step in ensuring the safety and correctness of Rust programs. In this section, we’ll explore techniques and best practices for auditing unsafe code.</p>
<h3 id="why-audit-unsafe-code"><a class="header" href="#why-audit-unsafe-code">Why Audit Unsafe Code?</a></h3>
<p>Unsafe code bypasses Rust’s safety guarantees, making it susceptible to:</p>
<ol>
<li>Memory safety issues</li>
<li>Data races</li>
<li>Undefined behavior</li>
<li>Security vulnerabilities</li>
</ol>
<p>Regular auditing helps identify and fix these issues before they cause problems.</p>
<h3 id="when-to-audit-unsafe-code"><a class="header" href="#when-to-audit-unsafe-code">When to Audit Unsafe Code</a></h3>
<p>You should audit unsafe code:</p>
<ol>
<li><strong>Before releasing</strong>: Review all unsafe code before releasing your software.</li>
<li><strong>After significant changes</strong>: Re-audit after making significant changes to unsafe code or its dependencies.</li>
<li><strong>Periodically</strong>: Conduct regular audits, especially for security-critical code.</li>
<li><strong>When upgrading dependencies</strong>: Changes in dependencies might affect assumptions in your unsafe code.</li>
<li><strong>When the compiler is upgraded</strong>: New compiler optimizations might expose latent issues.</li>
</ol>
<h3 id="auditing-techniques"><a class="header" href="#auditing-techniques">Auditing Techniques</a></h3>
<h4 id="1-manual-code-review"><a class="header" href="#1-manual-code-review">1. Manual Code Review</a></h4>
<p>The most basic but essential technique is a thorough manual review:</p>
<ol>
<li><strong>Start with safety documentation</strong>: Read the safety documentation for each unsafe function.</li>
<li><strong>Verify preconditions</strong>: Check that all safety preconditions are enforced.</li>
<li><strong>Trace ownership and lifetimes</strong>: Follow how references and raw pointers are created and used.</li>
<li><strong>Check for edge cases</strong>: Pay special attention to edge cases like empty collections, maximum values, etc.</li>
<li><strong>Review Drop implementations</strong>: Ensure resources are properly cleaned up.</li>
</ol>
<p>Example checklist for reviewing an unsafe function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn example_function(ptr: *mut T, len: usize) {
    // Checklist:
    // ✓ Is ptr checked for null?
    // ✓ Is len checked for zero or excessive values?
    // ✓ Are alignment requirements verified?
    // ✓ Is the memory properly initialized?
    // ✓ Are all accesses within bounds?
    // ✓ Are there any potential race conditions?
    // ✓ Is cleanup properly handled, even in error cases?
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-using-static-analysis-tools"><a class="header" href="#2-using-static-analysis-tools">2. Using Static Analysis Tools</a></h4>
<p>Several tools can help identify issues in unsafe code:</p>
<ol>
<li>
<p><strong>Clippy</strong>: Enable all unsafe-related lints:</p>
<pre><code class="language-bash">cargo clippy -- -W clippy::all -W clippy::pedantic -W clippy::nursery
</code></pre>
</li>
<li>
<p><strong>Rust Analyzer</strong>: Use Rust Analyzer’s diagnostics in your IDE.</p>
</li>
<li>
<p><strong>MIRI (Mid-level Intermediate Representation Interpreter)</strong>: Run tests with MIRI to detect undefined behavior:</p>
<pre><code class="language-bash">cargo +nightly miri test
</code></pre>
</li>
<li>
<p><strong>Sanitizers</strong>: Use Address Sanitizer, Memory Sanitizer, and Thread Sanitizer:</p>
<pre><code class="language-bash">RUSTFLAGS="-Z sanitizer=address" cargo test --target x86_64-unknown-linux-gnu
</code></pre>
</li>
</ol>
<h4 id="3-fuzz-testing"><a class="header" href="#3-fuzz-testing">3. Fuzz Testing</a></h4>
<p>Fuzz testing is particularly effective for finding edge cases in unsafe code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example using cargo-fuzz
#[fuzz]
fn fuzz_unsafe_function(data: &amp;[u8]) {
    if data.len() &gt; 0 {
        let result = unsafe_function(data);
        // Add assertions to check that result is valid
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="4-property-based-testing"><a class="header" href="#4-property-based-testing">4. Property-Based Testing</a></h4>
<p>Use property-based testing to verify invariants:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use quickcheck::quickcheck;

    quickcheck! {
        fn test_buffer_operations(operations: Vec&lt;BufferOp&gt;) -&gt; bool {
            let mut buffer = UnsafeBuffer::new(1024);

            for op in operations {
                match op {
                    BufferOp::Write(offset, data) =&gt; {
                        if offset + data.len() &lt;= buffer.len() {
                            unsafe { buffer.write(offset, &amp;data) };
                        }
                    },
                    BufferOp::Read(offset, len) =&gt; {
                        if offset + len &lt;= buffer.len() {
                            let _ = unsafe { buffer.read(offset, len) };
                        }
                    },
                    // Other operations...
                }
            }

            // Verify invariants are maintained
            true
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="5-code-annotation-and-documentation"><a class="header" href="#5-code-annotation-and-documentation">5. Code Annotation and Documentation</a></h4>
<p>Document safety requirements and assumptions explicitly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// # Safety
///
/// The caller must ensure:
/// - `ptr` is valid for reads of `len` elements
/// - `ptr` is properly aligned for `T`
/// - The memory is initialized
/// - The lifetime `'a` does not exceed the lifetime of the memory pointed to by `ptr`
///
/// # Panics
///
/// This function will panic if `len` is greater than `isize::MAX`.
///
/// # Examples
///
/// ```
/// # use my_crate::create_slice;
/// let data = [1, 2, 3, 4, 5];
/// unsafe {
///     let slice = create_slice(&amp;data[0], data.len());
///     assert_eq!(slice, &amp;[1, 2, 3, 4, 5]);
/// }
/// ```
pub unsafe fn create_slice&lt;'a, T&gt;(ptr: *const T, len: usize) -&gt; &amp;'a [T] {
    assert!(len &lt;= isize::MAX as usize, "Length exceeds isize::MAX");
    std::slice::from_raw_parts(ptr, len)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="common-issues-to-look-for"><a class="header" href="#common-issues-to-look-for">Common Issues to Look For</a></h3>
<p>When auditing unsafe code, watch for these common issues:</p>
<h4 id="1-memory-safety-issues"><a class="header" href="#1-memory-safety-issues">1. Memory Safety Issues</a></h4>
<ul>
<li><strong>Use-after-free</strong>: Using memory after it has been freed</li>
<li><strong>Double-free</strong>: Freeing memory more than once</li>
<li><strong>Memory leaks</strong>: Failing to free memory</li>
<li><strong>Buffer overflows</strong>: Accessing memory beyond allocated bounds</li>
<li><strong>Uninitialized memory</strong>: Reading uninitialized memory</li>
</ul>
<h4 id="2-concurrency-issues"><a class="header" href="#2-concurrency-issues">2. Concurrency Issues</a></h4>
<ul>
<li><strong>Data races</strong>: Concurrent access to shared memory without synchronization</li>
<li><strong>Deadlocks</strong>: Threads waiting for each other indefinitely</li>
<li><strong>Ordering issues</strong>: Incorrect memory ordering in atomic operations</li>
</ul>
<h4 id="3-undefined-behavior"><a class="header" href="#3-undefined-behavior">3. Undefined Behavior</a></h4>
<ul>
<li><strong>Invalid pointers</strong>: Using null, dangling, or misaligned pointers</li>
<li><strong>Type punning</strong>: Incorrect reinterpretation of memory</li>
<li><strong>Violating aliasing rules</strong>: Breaking Rust’s aliasing guarantees</li>
</ul>
<h4 id="4-api-safety-issues"><a class="header" href="#4-api-safety-issues">4. API Safety Issues</a></h4>
<ul>
<li><strong>Incomplete safety documentation</strong>: Missing safety requirements</li>
<li><strong>Hidden unsafe requirements</strong>: Requiring unsafe behavior from safe functions</li>
<li><strong>Leaking implementation details</strong>: Exposing internal unsafe details</li>
</ul>
<h3 id="case-study-auditing-a-custom-allocator"><a class="header" href="#case-study-auditing-a-custom-allocator">Case Study: Auditing a Custom Allocator</a></h3>
<p>Let’s examine how to audit a custom allocator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CustomAllocator {
    // Implementation details...
}

impl CustomAllocator {
    pub fn new() -&gt; Self {
        // Initialize allocator...
        CustomAllocator { /* ... */ }
    }

    pub fn allocate(&amp;self, layout: Layout) -&gt; Result&lt;*mut u8, AllocError&gt; {
        // AUDIT: Check if layout size and alignment are valid
        if layout.size() == 0 || !layout.align().is_power_of_two() {
            return Err(AllocError);
        }

        // AUDIT: Check for potential integer overflow
        let size = layout.size().checked_add(layout.align() - 1)
            .ok_or(AllocError)?;

        // AUDIT: Perform allocation
        unsafe {
            // Allocation implementation...
            let ptr = /* ... */;

            // AUDIT: Check for null pointer (allocation failure)
            if ptr.is_null() {
                return Err(AllocError);
            }

            // AUDIT: Ensure proper alignment
            let aligned_ptr = /* ... */;

            Ok(aligned_ptr)
        }
    }

    pub fn deallocate(&amp;self, ptr: *mut u8, layout: Layout) {
        // AUDIT: Check if ptr is null
        if ptr.is_null() {
            return;
        }

        // AUDIT: Check if layout is valid
        if layout.size() == 0 {
            return;
        }

        unsafe {
            // AUDIT: Ensure we're deallocating a pointer that was allocated by us

            // AUDIT: Perform deallocation
            // ...
        }
    }
}

// AUDIT: Implement Drop to clean up resources
impl Drop for CustomAllocator {
    fn drop(&amp;mut self) {
        // AUDIT: Clean up any remaining resources
        unsafe {
            // ...
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="creating-an-audit-trail"><a class="header" href="#creating-an-audit-trail">Creating an Audit Trail</a></h3>
<p>Document your audit process:</p>
<ol>
<li><strong>Create an audit log</strong>: Document when audits occurred and what was found.</li>
<li><strong>Track unsafe code</strong>: Maintain a registry of all unsafe code in your project.</li>
<li><strong>Document audit decisions</strong>: Record why certain unsafe patterns were deemed acceptable.</li>
<li><strong>Create test cases</strong>: Add test cases that verify the correctness of unsafe code.</li>
</ol>
<p>Example audit log entry:</p>
<pre><code class="language-markdown"># Unsafe Code Audit Log

## 2023-04-15: Initial audit of custom allocator

Auditor: Jane Smith

### Findings

1. Missing null pointer check in `deallocate`
   - Fixed in commit abc123
2. Potential integer overflow in size calculation
   - Added checked addition in commit def456
3. No verification that deallocated pointers were allocated by us
   - Added tracking mechanism in commit ghi789

### Verified invariants

1. Alignment requirements are properly enforced
2. Memory is properly initialized before use
3. No memory leaks in normal operation
</code></pre>
<p>By regularly auditing your unsafe code and maintaining a detailed audit trail, you can significantly reduce the risks associated with unsafe Rust.</p>
<h2 id="security-implications"><a class="header" href="#security-implications">Security Implications</a></h2>
<p>Unsafe Rust has significant security implications that developers should understand. While Rust’s safety guarantees make it an excellent choice for security-critical software, unsafe code can introduce vulnerabilities if not handled properly.</p>
<h3 id="common-security-vulnerabilities-in-unsafe-code"><a class="header" href="#common-security-vulnerabilities-in-unsafe-code">Common Security Vulnerabilities in Unsafe Code</a></h3>
<h4 id="1-memory-safety-vulnerabilities"><a class="header" href="#1-memory-safety-vulnerabilities">1. Memory Safety Vulnerabilities</a></h4>
<p>Memory safety vulnerabilities are among the most serious security issues that can arise from unsafe Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn memory_safety_vulnerability() {
    let mut buffer = [0u8; 8];

    // Vulnerability: No bounds checking
    unsafe fn vulnerable_copy(src: &amp;[u8], dst: *mut u8) {
        for i in 0..src.len() {
            // No bounds checking on dst
            *dst.add(i) = src[i];
        }
    }

    let malicious_data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];  // Larger than buffer

    unsafe {
        // Buffer overflow vulnerability
        vulnerable_copy(&amp;malicious_data, buffer.as_mut_ptr());
    }

    // Buffer has been overflowed, potentially corrupting adjacent memory
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-time-of-check-to-time-of-use-toctou-vulnerabilities"><a class="header" href="#2-time-of-check-to-time-of-use-toctou-vulnerabilities">2. Time-of-Check to Time-of-Use (TOCTOU) Vulnerabilities</a></h4>
<p>TOCTOU vulnerabilities occur when there’s a gap between checking a condition and using a resource:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn toctou_vulnerability() {
    let file_path = "/tmp/sensitive_file";

    // Check permissions
    if check_user_permissions(file_path) {
        // Between the check and use, the file could be replaced with a symbolic link
        // to a sensitive file the user shouldn't access

        // Use the file
        unsafe {
            let file_handle = open_file(file_path);
            // Process file...
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-uninitialized-memory-disclosure"><a class="header" href="#3-uninitialized-memory-disclosure">3. Uninitialized Memory Disclosure</a></h4>
<p>Leaking uninitialized memory can expose sensitive data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn uninitialized_memory_disclosure() {
    // Create an uninitialized buffer
    let mut buffer: [u8; 1024] = unsafe { std::mem::MaybeUninit::uninit().assume_init() };

    // Only initialize part of the buffer
    for i in 0..512 {
        buffer[i] = i as u8;
    }

    // Vulnerability: Sending the entire buffer, including uninitialized portion
    send_to_network(&amp;buffer);  // Might leak sensitive data from memory
}
<span class="boring">}</span></code></pre></pre>
<h4 id="4-integer-overflow-leading-to-buffer-overflow"><a class="header" href="#4-integer-overflow-leading-to-buffer-overflow">4. Integer Overflow Leading to Buffer Overflow</a></h4>
<p>Integer overflows can lead to buffer overflows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn integer_overflow_vulnerability(size: usize) {
    // Vulnerability: Potential integer overflow
    let buffer_size = size + 8;  // Could overflow

    // Allocate buffer
    let buffer = unsafe {
        let layout = std::alloc::Layout::from_size_align(buffer_size, 8).unwrap();
        std::alloc::alloc(layout)
    };

    // Use buffer...
}
<span class="boring">}</span></code></pre></pre>
<h4 id="5-use-after-free-vulnerabilities"><a class="header" href="#5-use-after-free-vulnerabilities">5. Use-After-Free Vulnerabilities</a></h4>
<p>Use-after-free vulnerabilities can lead to code execution:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_after_free_vulnerability() {
    let mut data = Box::new(42);
    let ptr = &amp;mut *data as *mut i32;

    // Free the memory
    drop(data);

    // Some other operation that might allocate memory in the same spot
    let _new_allocation = Box::new([0; 100]);

    // Vulnerability: Using the pointer after the memory has been freed
    unsafe {
        *ptr = 100;  // This could modify the _new_allocation data
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="mitigating-security-risks"><a class="header" href="#mitigating-security-risks">Mitigating Security Risks</a></h3>
<p>Here are strategies to mitigate security risks in unsafe Rust:</p>
<h4 id="1-minimize-unsafe-code-1"><a class="header" href="#1-minimize-unsafe-code-1">1. Minimize Unsafe Code</a></h4>
<p>The less unsafe code you have, the lower the security risk:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: Unnecessarily large unsafe block
unsafe fn unsafe_function() {
    // A lot of code that doesn't need to be unsafe
    let mut sum = 0;
    for i in 0..100 {
        sum += i;
    }

    // Only this part needs to be unsafe
    let ptr = std::ptr::null_mut();
    if !ptr.is_null() {
        *ptr = sum;
    }
}

// GOOD: Minimize unsafe code
fn safe_function() {
    // Most code is safe
    let mut sum = 0;
    for i in 0..100 {
        sum += i;
    }

    // Only this part is unsafe
    unsafe {
        let ptr = std::ptr::null_mut();
        if !ptr.is_null() {
            *ptr = sum;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="2-add-runtime-checks-1"><a class="header" href="#2-add-runtime-checks-1">2. Add Runtime Checks</a></h4>
<p>Add runtime checks to prevent security vulnerabilities:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn secure_copy(src: &amp;[u8], dst: &amp;mut [u8]) -&gt; Result&lt;(), &amp;'static str&gt; {
    // Check for buffer overflow
    if src.len() &gt; dst.len() {
        return Err("Source buffer too large for destination");
    }

    // Safe copy
    dst[0..src.len()].copy_from_slice(src);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h4 id="3-use-safe-abstractions-1"><a class="header" href="#3-use-safe-abstractions-1">3. Use Safe Abstractions</a></h4>
<p>Create safe abstractions around unsafe code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Safe abstraction for a fixed-size buffer
pub struct SafeBuffer&lt;const N: usize&gt; {
    data: [u8; N],
}

impl&lt;const N: usize&gt; SafeBuffer&lt;N&gt; {
    pub fn new() -&gt; Self {
        SafeBuffer { data: [0; N] }
    }

    pub fn copy_from(&amp;mut self, src: &amp;[u8]) -&gt; Result&lt;(), &amp;'static str&gt; {
        if src.len() &gt; N {
            return Err("Source buffer too large");
        }

        self.data[0..src.len()].copy_from_slice(src);
        Ok(())
    }

    pub fn as_slice(&amp;self) -&gt; &amp;[u8] {
        &amp;self.data
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="4-validate-external-input"><a class="header" href="#4-validate-external-input">4. Validate External Input</a></h4>
<p>Always validate external input before using it with unsafe code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_user_input(input: &amp;str) -&gt; Result&lt;(), String&gt; {
    // Validate input
    if input.len() &gt; 1024 {
        return Err("Input too large".to_string());
    }

    // Check for malicious patterns
    if input.contains("../") {
        return Err("Invalid input pattern".to_string());
    }

    // Convert to bytes
    let bytes = input.as_bytes();

    // Now safe to use with unsafe code
    unsafe {
        // Process bytes...
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h4 id="5-use-memory-safety-tools"><a class="header" href="#5-use-memory-safety-tools">5. Use Memory Safety Tools</a></h4>
<p>Use tools to detect memory safety issues:</p>
<pre><code class="language-bash"># Run with Address Sanitizer
RUSTFLAGS="-Z sanitizer=address" cargo run --target x86_64-unknown-linux-gnu

# Run with Memory Sanitizer
RUSTFLAGS="-Z sanitizer=memory" cargo run --target x86_64-unknown-linux-gnu

# Run with Thread Sanitizer
RUSTFLAGS="-Z sanitizer=thread" cargo run --target x86_64-unknown-linux-gnu
</code></pre>
<h3 id="security-in-ffi-code"><a class="header" href="#security-in-ffi-code">Security in FFI Code</a></h3>
<p>Foreign Function Interface (FFI) code is particularly vulnerable to security issues:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FFI declaration
extern "C" {
    fn vulnerable_c_function(input: *const libc::c_char);
}

// Insecure FFI usage
fn insecure_ffi(input: &amp;str) {
    let c_string = std::ffi::CString::new(input).unwrap();
    unsafe {
        vulnerable_c_function(c_string.as_ptr());
    }
}

// Secure FFI usage
fn secure_ffi(input: &amp;str) -&gt; Result&lt;(), &amp;'static str&gt; {
    // Validate input
    if input.len() &gt; 1024 {
        return Err("Input too large");
    }

    // Check for null bytes
    if input.contains('\0') {
        return Err("Input contains null bytes");
    }

    // Convert to C string
    let c_string = match std::ffi::CString::new(input) {
        Ok(s) =&gt; s,
        Err(_) =&gt; return Err("Failed to create C string"),
    };

    // Call C function
    unsafe {
        vulnerable_c_function(c_string.as_ptr());
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="security-review-checklist"><a class="header" href="#security-review-checklist">Security Review Checklist</a></h3>
<p>When reviewing unsafe code for security, consider these questions:</p>
<ol>
<li><strong>Input Validation</strong>: Is all external input validated before being used with unsafe code?</li>
<li><strong>Bounds Checking</strong>: Are there proper bounds checks to prevent buffer overflows?</li>
<li><strong>Integer Overflows</strong>: Are integer operations checked for overflow?</li>
<li><strong>Memory Management</strong>: Is memory properly allocated and freed?</li>
<li><strong>Concurrency</strong>: Is the code safe in a multithreaded context?</li>
<li><strong>Error Handling</strong>: Is error handling robust, especially in cleanup code?</li>
<li><strong>Dependencies</strong>: Are all dependencies trusted and up-to-date?</li>
<li><strong>Documentation</strong>: Are safety requirements clearly documented?</li>
</ol>
<h3 id="real-world-security-vulnerabilities"><a class="header" href="#real-world-security-vulnerabilities">Real-World Security Vulnerabilities</a></h3>
<p>Several real-world security vulnerabilities have been found in unsafe Rust code:</p>
<ol>
<li><strong>Memory safety bugs in Firefox’s Rust code</strong>: Mozilla has found and fixed several memory safety issues in Firefox’s Rust components.</li>
<li><strong>Vulnerabilities in popular crates</strong>: Security vulnerabilities have been discovered in widely-used Rust crates, often in their unsafe code.</li>
<li><strong>FFI-related vulnerabilities</strong>: Many vulnerabilities occur at the boundary between Rust and C/C++ code.</li>
</ol>
<p>By understanding these security implications and following best practices, you can write unsafe Rust code that is both efficient and secure.</p>
<h2 id="practical-project-safe-wrapper-for-c-library"><a class="header" href="#practical-project-safe-wrapper-for-c-library">Practical Project: Safe Wrapper for C Library</a></h2>
<p>Let’s put our knowledge of unsafe Rust into practice by building a safe wrapper around a C image processing library. This project will demonstrate how to:</p>
<ol>
<li>Interface with C code using FFI</li>
<li>Create safe abstractions over unsafe code</li>
<li>Handle resources properly</li>
<li>Maintain memory safety</li>
</ol>
<h3 id="the-c-library"><a class="header" href="#the-c-library">The C Library</a></h3>
<p>Imagine we have a simple C image processing library with the following interface:</p>
<pre><code class="language-c">// image_lib.h

typedef struct {
    unsigned char* data;
    size_t width;
    size_t height;
    size_t channels;
} Image;

// Create a new image
Image* image_create(size_t width, size_t height, size_t channels);

// Load an image from a file
Image* image_load(const char* filename);

// Save an image to a file
int image_save(const Image* image, const char* filename);

// Apply a blur filter to an image
void image_blur(Image* image, float sigma);

// Apply a grayscale filter to an image
void image_grayscale(Image* image);

// Resize an image
Image* image_resize(const Image* image, size_t new_width, size_t new_height);

// Free an image
void image_free(Image* image);
</code></pre>
<h3 id="step-1-creating-the-ffi-bindings"><a class="header" href="#step-1-creating-the-ffi-bindings">Step 1: Creating the FFI Bindings</a></h3>
<p>First, we’ll create the raw FFI bindings to the C library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lib.rs

use std::os::raw::{c_char, c_float, c_int};

#[repr(C)]
pub struct RawImage {
    data: *mut u8,
    width: usize,
    height: usize,
    channels: usize,
}

extern "C" {
    fn image_create(width: usize, height: usize, channels: usize) -&gt; *mut RawImage;
    fn image_load(filename: *const c_char) -&gt; *mut RawImage;
    fn image_save(image: *const RawImage, filename: *const c_char) -&gt; c_int;
    fn image_blur(image: *mut RawImage, sigma: c_float);
    fn image_grayscale(image: *mut RawImage);
    fn image_resize(image: *const RawImage, new_width: usize, new_height: usize) -&gt; *mut RawImage;
    fn image_free(image: *mut RawImage);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="step-2-creating-a-safe-wrapper"><a class="header" href="#step-2-creating-a-safe-wrapper">Step 2: Creating a Safe Wrapper</a></h3>
<p>Now, we’ll create a safe wrapper around the unsafe FFI bindings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lib.rs (continued)

use std::ffi::{CString, NulError};
use std::path::Path;
use std::ptr::NonNull;

#[derive(Debug)]
pub enum ImageError {
    InvalidPath,
    NulError(NulError),
    LoadError,
    SaveError,
    CreationError,
    ResizeError,
}

impl From&lt;NulError&gt; for ImageError {
    fn from(err: NulError) -&gt; Self {
        ImageError::NulError(err)
    }
}

pub struct Image {
    // Use NonNull to indicate the pointer is never null
    inner: NonNull&lt;RawImage&gt;,
}

impl Image {
    /// Create a new blank image
    pub fn new(width: usize, height: usize, channels: usize) -&gt; Result&lt;Self, ImageError&gt; {
        // Check for valid dimensions
        if width == 0 || height == 0 || channels == 0 || channels &gt; 4 {
            return Err(ImageError::CreationError);
        }

        // Call the C function to create the image
        let ptr = unsafe { image_create(width, height, channels) };

        // Convert to NonNull and check for null
        let inner = NonNull::new(ptr).ok_or(ImageError::CreationError)?;

        Ok(Image { inner })
    }

    /// Load an image from a file
    pub fn load&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;Self, ImageError&gt; {
        // Convert path to CString
        let path_str = path.as_ref().to_str().ok_or(ImageError::InvalidPath)?;
        let c_path = CString::new(path_str)?;

        // Call the C function to load the image
        let ptr = unsafe { image_load(c_path.as_ptr()) };

        // Convert to NonNull and check for null
        let inner = NonNull::new(ptr).ok_or(ImageError::LoadError)?;

        Ok(Image { inner })
    }

    /// Save the image to a file
    pub fn save&lt;P: AsRef&lt;Path&gt;&gt;(&amp;self, path: P) -&gt; Result&lt;(), ImageError&gt; {
        // Convert path to CString
        let path_str = path.as_ref().to_str().ok_or(ImageError::InvalidPath)?;
        let c_path = CString::new(path_str)?;

        // Call the C function to save the image
        let result = unsafe { image_save(self.inner.as_ptr(), c_path.as_ptr()) };

        // Check for errors
        if result != 0 {
            return Err(ImageError::SaveError);
        }

        Ok(())
    }

    /// Apply a blur filter to the image
    pub fn blur(&amp;mut self, sigma: f32) {
        // Validate sigma
        let sigma = if sigma &lt; 0.1 { 0.1 } else { sigma };

        // Call the C function to blur the image
        unsafe {
            image_blur(self.inner.as_ptr(), sigma);
        }
    }

    /// Convert the image to grayscale
    pub fn grayscale(&amp;mut self) {
        // Call the C function to convert to grayscale
        unsafe {
            image_grayscale(self.inner.as_ptr());
        }
    }

    /// Resize the image
    pub fn resize(&amp;self, new_width: usize, new_height: usize) -&gt; Result&lt;Self, ImageError&gt; {
        // Check for valid dimensions
        if new_width == 0 || new_height == 0 {
            return Err(ImageError::ResizeError);
        }

        // Call the C function to resize the image
        let ptr = unsafe { image_resize(self.inner.as_ptr(), new_width, new_height) };

        // Convert to NonNull and check for null
        let inner = NonNull::new(ptr).ok_or(ImageError::ResizeError)?;

        Ok(Image { inner })
    }

    /// Get the width of the image
    pub fn width(&amp;self) -&gt; usize {
        unsafe { (*self.inner.as_ptr()).width }
    }

    /// Get the height of the image
    pub fn height(&amp;self) -&gt; usize {
        unsafe { (*self.inner.as_ptr()).height }
    }

    /// Get the number of channels in the image
    pub fn channels(&amp;self) -&gt; usize {
        unsafe { (*self.inner.as_ptr()).channels }
    }

    /// Get a reference to the image data
    pub fn data(&amp;self) -&gt; &amp;[u8] {
        unsafe {
            let raw = self.inner.as_ref();
            std::slice::from_raw_parts(raw.data, raw.width * raw.height * raw.channels)
        }
    }

    /// Get a mutable reference to the image data
    pub fn data_mut(&amp;mut self) -&gt; &amp;mut [u8] {
        unsafe {
            let raw = self.inner.as_ref();
            std::slice::from_raw_parts_mut(raw.data, raw.width * raw.height * raw.channels)
        }
    }
}

// Implement Drop to automatically free the image when it goes out of scope
impl Drop for Image {
    fn drop(&amp;mut self) {
        unsafe {
            image_free(self.inner.as_ptr());
        }
    }
}

// Implement Send and Sync for thread safety
// This is safe because the C library guarantees thread safety for its functions
unsafe impl Send for Image {}
unsafe impl Sync for Image {}
<span class="boring">}</span></code></pre></pre>
<h3 id="step-3-adding-higher-level-functionality"><a class="header" href="#step-3-adding-higher-level-functionality">Step 3: Adding Higher-Level Functionality</a></h3>
<p>Let’s add some higher-level functionality to our wrapper:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lib.rs (continued)

impl Image {
    /// Invert the colors of the image
    pub fn invert(&amp;mut self) {
        // Get a mutable reference to the image data
        let data = self.data_mut();

        // Invert each pixel
        for pixel in data.iter_mut() {
            *pixel = 255 - *pixel;
        }
    }

    /// Crop the image
    pub fn crop(&amp;self, x: usize, y: usize, width: usize, height: usize) -&gt; Result&lt;Self, ImageError&gt; {
        // Validate crop parameters
        if x + width &gt; self.width() || y + height &gt; self.height() {
            return Err(ImageError::ResizeError);
        }

        // Create a new image for the cropped result
        let mut result = Image::new(width, height, self.channels())?;

        // Get references to the source and destination data
        let src_data = self.data();
        let dst_data = result.data_mut();

        // Copy the cropped region
        let src_stride = self.width() * self.channels();
        let dst_stride = width * self.channels();

        for row in 0..height {
            let src_offset = ((y + row) * src_stride) + (x * self.channels());
            let dst_offset = row * dst_stride;

            dst_data[dst_offset..(dst_offset + dst_stride)]
                .copy_from_slice(&amp;src_data[src_offset..(src_offset + dst_stride)]);
        }

        Ok(result)
    }

    /// Apply a custom filter to the image
    pub fn apply_filter&lt;F&gt;(&amp;mut self, filter: F)
    where
        F: Fn(usize, usize, &amp;[u8]) -&gt; [u8; 4],
    {
        let width = self.width();
        let height = self.height();
        let channels = self.channels();

        // Create a temporary buffer for the result
        let mut buffer = vec![0u8; width * height * channels];

        // Apply the filter to each pixel
        let src_data = self.data();

        for y in 0..height {
            for x in 0..width {
                let src_offset = (y * width + x) * channels;
                let pixel_data = &amp;src_data[src_offset..(src_offset + channels)];

                // Apply the filter
                let result = filter(x, y, pixel_data);

                // Copy the result back to the buffer
                let dst_offset = (y * width + x) * channels;
                for c in 0..channels {
                    buffer[dst_offset + c] = result[c];
                }
            }
        }

        // Copy the buffer back to the image
        let dst_data = self.data_mut();
        dst_data.copy_from_slice(&amp;buffer);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="step-4-implementing-example-usage"><a class="header" href="#step-4-implementing-example-usage">Step 4: Implementing Example Usage</a></h3>
<p>Finally, let’s demonstrate how to use our safe wrapper:</p>
<pre><pre class="playground"><code class="language-rust">// main.rs

use image_processing::{Image, ImageError};

fn main() -&gt; Result&lt;(), ImageError&gt; {
    // Load an image
    let mut image = Image::load("input.jpg")?;
    println!("Loaded image: {}x{} with {} channels", image.width(), image.height(), image.channels());

    // Apply blur
    image.blur(1.5);

    // Resize the image
    let resized = image.resize(image.width() / 2, image.height() / 2)?;

    // Apply a custom filter (sepia)
    resized.apply_filter(|_, _, pixel| {
        let r = pixel[0] as f32;
        let g = pixel[1] as f32;
        let b = pixel[2] as f32;

        let new_r = (0.393 * r + 0.769 * g + 0.189 * b).min(255.0) as u8;
        let new_g = (0.349 * r + 0.686 * g + 0.168 * b).min(255.0) as u8;
        let new_b = (0.272 * r + 0.534 * g + 0.131 * b).min(255.0) as u8;

        [new_r, new_g, new_b, 255]
    });

    // Save the result
    resized.save("output.jpg")?;
    println!("Saved processed image to output.jpg");

    Ok(())
}</code></pre></pre>
<h3 id="key-safety-features"><a class="header" href="#key-safety-features">Key Safety Features</a></h3>
<p>Our wrapper implements several key safety features:</p>
<ol>
<li><strong>Resource management</strong>: Uses <code>Drop</code> to automatically free resources.</li>
<li><strong>Error handling</strong>: Returns <code>Result</code> types for operations that can fail.</li>
<li><strong>Input validation</strong>: Validates parameters before passing them to unsafe code.</li>
<li><strong>Memory safety</strong>: Uses <code>NonNull</code> to represent non-null pointers.</li>
<li><strong>Safe abstractions</strong>: Provides a safe interface that hides unsafe details.</li>
<li><strong>Thread safety</strong>: Implements <code>Send</code> and <code>Sync</code> where appropriate.</li>
</ol>
<p>By following these principles, we’ve created a safe Rust interface to an unsafe C library, allowing users to benefit from the performance of the C code without sacrificing safety.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this chapter, we’ve explored the world of unsafe Rust—a powerful but potentially dangerous subset of the language that gives you access to low-level operations while bypassing some of Rust’s safety guarantees.</p>
<p>We’ve learned:</p>
<ul>
<li>
<p><strong>When and why to use unsafe code</strong>: Unsafe code is necessary for operations that cannot be verified by the compiler, like interacting with hardware, implementing data structures with complex aliasing patterns, or interfacing with code written in other languages.</p>
</li>
<li>
<p><strong>Raw pointers</strong>: Unsafe Rust allows you to work with raw pointers (<code>*const T</code> and <code>*mut T</code>), which don’t have the same guarantees as Rust’s references. We explored how to create, dereference, and work with raw pointers safely.</p>
</li>
<li>
<p><strong>Mutable aliasing</strong>: We examined how unsafe code can break Rust’s aliasing rules, allowing multiple mutable references to the same memory—a powerful capability that comes with significant risks.</p>
</li>
<li>
<p><strong>Calling unsafe functions</strong>: We learned how to call functions marked as <code>unsafe</code> and the responsibilities that come with doing so. We explored the contract between the caller and the function, and how to document safety requirements.</p>
</li>
<li>
<p><strong>FFI and external code</strong>: We studied how to interface with code written in other languages like C and C++, including how to handle memory management, data conversion, and callbacks across language boundaries.</p>
</li>
<li>
<p><strong>Safe abstractions over unsafe code</strong>: We learned how to encapsulate unsafe code within safe abstractions, providing users with a safe interface while leveraging the performance of unsafe operations internally.</p>
</li>
<li>
<p><strong>Undefined behavior</strong>: We explored what undefined behavior is, how to detect it, and how to avoid it in your unsafe code.</p>
</li>
<li>
<p><strong>Unsafe patterns and best practices</strong>: We examined common patterns used in unsafe Rust code and best practices for writing maintainable and reliable unsafe code.</p>
</li>
<li>
<p><strong>Auditing unsafe code</strong>: We learned techniques for reviewing and auditing unsafe code to ensure it maintains Rust’s safety guarantees.</p>
</li>
<li>
<p><strong>Security implications</strong>: We studied the security vulnerabilities that can arise from unsafe code and how to mitigate them.</p>
</li>
<li>
<p><strong>Practical applications</strong>: We applied our knowledge to build a safe wrapper around a C library, demonstrating how to use unsafe Rust in a real-world scenario.</p>
</li>
</ul>
<p>Throughout the chapter, we’ve emphasized the importance of being cautious with unsafe code. While unsafe Rust is a powerful tool in your programming arsenal, it should be used sparingly and with care. Always strive to provide safe abstractions over unsafe code, document your safety requirements clearly, and thoroughly test and audit your unsafe code.</p>
<p>Remember the guiding principle: use unsafe code when necessary, but encapsulate it in safe abstractions to maintain Rust’s guarantees for the rest of your codebase.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<h3 id="exercise-1-implement-a-basic-smart-pointer"><a class="header" href="#exercise-1-implement-a-basic-smart-pointer">Exercise 1: Implement a Basic Smart Pointer</a></h3>
<p>Implement a simple <code>Box</code>-like smart pointer that allocates memory on the heap. Your implementation should:</p>
<ol>
<li>Allocate memory using <code>std::alloc</code></li>
<li>Free memory when dropped</li>
<li>Implement <code>Deref</code> and <code>DerefMut</code> for accessing the contained value</li>
<li>Handle zero-sized types correctly</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyBox&lt;T&gt; {
    ptr: *mut T,
    // Add any other fields you need
}

impl&lt;T&gt; MyBox&lt;T&gt; {
    pub fn new(value: T) -&gt; Self {
        // Implement this function
        unimplemented!()
    }
}

impl&lt;T&gt; std::ops::Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        // Implement this function
        unimplemented!()
    }
}

impl&lt;T&gt; std::ops::DerefMut for MyBox&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        // Implement this function
        unimplemented!()
    }
}

impl&lt;T&gt; Drop for MyBox&lt;T&gt; {
    fn drop(&amp;mut self) {
        // Implement this function
        unimplemented!()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-2-create-a-safe-abstraction-for-a-circular-buffer"><a class="header" href="#exercise-2-create-a-safe-abstraction-for-a-circular-buffer">Exercise 2: Create a Safe Abstraction for a Circular Buffer</a></h3>
<p>Implement a circular buffer (ring buffer) using unsafe code, but provide a safe interface. Your implementation should:</p>
<ol>
<li>Allocate a fixed-size buffer</li>
<li>Allow pushing elements to the back of the buffer</li>
<li>Allow popping elements from the front of the buffer</li>
<li>Handle buffer wrapping correctly</li>
<li>Provide methods to check if the buffer is empty or full</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CircularBuffer&lt;T&gt; {
    // Implement this struct
}

impl&lt;T&gt; CircularBuffer&lt;T&gt; {
    pub fn new(capacity: usize) -&gt; Self {
        // Implement this function
        unimplemented!()
    }

    pub fn push(&amp;mut self, value: T) -&gt; Result&lt;(), &amp;'static str&gt; {
        // Implement this function
        unimplemented!()
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        // Implement this function
        unimplemented!()
    }

    pub fn is_empty(&amp;self) -&gt; bool {
        // Implement this function
        unimplemented!()
    }

    pub fn is_full(&amp;self) -&gt; bool {
        // Implement this function
        unimplemented!()
    }
}

impl&lt;T&gt; Drop for CircularBuffer&lt;T&gt; {
    fn drop(&amp;mut self) {
        // Implement this function
        unimplemented!()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-3-implement-a-safe-wrapper-for-c-string-functions"><a class="header" href="#exercise-3-implement-a-safe-wrapper-for-c-string-functions">Exercise 3: Implement a Safe Wrapper for C String Functions</a></h3>
<p>Create a safe Rust wrapper around the following C string functions:</p>
<pre><code class="language-c">// C functions
size_t strlen(const char* s);
char* strcpy(char* dest, const char* src);
char* strcat(char* dest, const char* src);
int strcmp(const char* s1, const char* s2);
</code></pre>
<p>Your wrapper should:</p>
<ol>
<li>Handle null-terminated strings correctly</li>
<li>Check for buffer overflows</li>
<li>Return appropriate Rust types</li>
<li>Handle errors gracefully</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CString {
    // Implement this struct
}

impl CString {
    pub fn new(s: &amp;str) -&gt; Result&lt;Self, &amp;'static str&gt; {
        // Implement this function
        unimplemented!()
    }

    pub fn len(&amp;self) -&gt; usize {
        // Implement this function using strlen
        unimplemented!()
    }

    pub fn copy_from(&amp;mut self, other: &amp;CString) -&gt; Result&lt;(), &amp;'static str&gt; {
        // Implement this function using strcpy
        unimplemented!()
    }

    pub fn append(&amp;mut self, other: &amp;CString) -&gt; Result&lt;(), &amp;'static str&gt; {
        // Implement this function using strcat
        unimplemented!()
    }

    pub fn compare(&amp;self, other: &amp;CString) -&gt; std::cmp::Ordering {
        // Implement this function using strcmp
        unimplemented!()
    }
}

impl Drop for CString {
    fn drop(&amp;mut self) {
        // Implement this function
        unimplemented!()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-4-detect-and-fix-undefined-behavior"><a class="header" href="#exercise-4-detect-and-fix-undefined-behavior">Exercise 4: Detect and Fix Undefined Behavior</a></h3>
<p>Identify and fix the undefined behavior in the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn undefined_behavior_example1() {
    let mut data = [0u8; 10];
    let ptr = data.as_mut_ptr();

    unsafe {
        // Problem 1: Write beyond the bounds of the array
        *ptr.add(20) = 42;
    }
}

fn undefined_behavior_example2() {
    let mut value = 42;
    let ref_mut = &amp;mut value;

    let raw_ptr = ref_mut as *mut i32;

    unsafe {
        // Problem 2: Create another mutable reference while ref_mut is active
        let another_ref = &amp;mut *raw_ptr;
        *another_ref = 100;
    }

    *ref_mut = 200;
}

fn undefined_behavior_example3() {
    let data = Box::new(42);
    let ptr = Box::into_raw(data);

    unsafe {
        // Problem 3: Double free
        let _ = Box::from_raw(ptr);
        let _ = Box::from_raw(ptr);
    }
}

fn undefined_behavior_example4() {
    unsafe {
        // Problem 4: Uninitialized memory
        let mut value: i32;
        println!("{}", value);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-5-audit-an-unsafe-implementation"><a class="header" href="#exercise-5-audit-an-unsafe-implementation">Exercise 5: Audit an Unsafe Implementation</a></h3>
<p>Review the following unsafe implementation of a memory pool allocator. Identify any safety issues, undefined behavior, or other problems, and suggest fixes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MemoryPool {
    buffer: *mut u8,
    chunk_size: usize,
    total_chunks: usize,
    free_list: *mut usize,
}

impl MemoryPool {
    pub fn new(chunk_size: usize, total_chunks: usize) -&gt; Self {
        let buffer_size = chunk_size * total_chunks;
        let buffer = unsafe {
            let layout = std::alloc::Layout::from_size_align(buffer_size, 8)
                .expect("Invalid layout");
            std::alloc::alloc(layout)
        };

        // Initialize free list
        let mut free_list = buffer as *mut usize;
        unsafe {
            for i in 0..total_chunks - 1 {
                let next_chunk = buffer.add((i + 1) * chunk_size) as *mut usize;
                *free_list = next_chunk as usize;
                free_list = next_chunk;
            }
            *free_list = 0; // End of list
        }

        MemoryPool {
            buffer,
            chunk_size,
            total_chunks,
            free_list: buffer as *mut usize,
        }
    }

    pub fn allocate(&amp;mut self) -&gt; *mut u8 {
        unsafe {
            if self.free_list.is_null() {
                return std::ptr::null_mut();
            }

            let chunk = self.free_list as *mut u8;
            self.free_list = *(self.free_list as *const usize) as *mut usize;
            chunk
        }
    }

    pub fn deallocate(&amp;mut self, ptr: *mut u8) {
        unsafe {
            *(ptr as *mut usize) = self.free_list as usize;
            self.free_list = ptr as *mut usize;
        }
    }
}

impl Drop for MemoryPool {
    fn drop(&amp;mut self) {
        unsafe {
            let layout = std::alloc::Layout::from_size_align(
                self.chunk_size * self.total_chunks, 8
            ).expect("Invalid layout");
            std::alloc::dealloc(self.buffer, layout);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Your audit should cover:</p>
<ol>
<li>Memory safety issues</li>
<li>Alignment problems</li>
<li>Initialization concerns</li>
<li>Concurrency issues</li>
<li>API safety</li>
</ol>
<p>Provide a fixed version of the code that addresses the issues you identified.</p>
<p>By completing these exercises, you’ll gain practical experience with unsafe Rust and develop the skills needed to use it effectively and safely in your own projects.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapters/26-macros.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapters/28-testing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapters/26-macros.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapters/28-testing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
