<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Control Flow in Rust - Rust Universe: Fearless Systems Engineering</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="A comprehensive guide to learning the Rust programming language from fundamentals to mastery.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 1: Fundamentals</li><li class="chapter-item expanded "><a href="../chapters/01-about-this-book.html"><strong aria-hidden="true">1.</strong> About This Book</a></li><li class="chapter-item expanded "><a href="../chapters/02-introduction-to-rust.html"><strong aria-hidden="true">2.</strong> Introduction to Rust</a></li><li class="chapter-item expanded "><a href="../chapters/03-getting-started.html"><strong aria-hidden="true">3.</strong> Getting Started with the Rust Toolchain</a></li><li class="chapter-item expanded "><a href="../chapters/04-basic-syntax.html"><strong aria-hidden="true">4.</strong> Basic Syntax and Data Types</a></li><li class="chapter-item expanded "><a href="../chapters/05-control-flow.html" class="active"><strong aria-hidden="true">5.</strong> Control Flow in Rust</a></li><li class="chapter-item expanded "><a href="../chapters/06-functions.html"><strong aria-hidden="true">6.</strong> Functions and Procedures</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 2: Ownership - Rust's Secret Weapon</li><li class="chapter-item expanded "><a href="../chapters/07-understanding-ownership.html"><strong aria-hidden="true">7.</strong> Understanding Ownership</a></li><li class="chapter-item expanded "><a href="../chapters/08-borrowing-references.html"><strong aria-hidden="true">8.</strong> Borrowing and References</a></li><li class="chapter-item expanded "><a href="../chapters/09-strings-slices.html"><strong aria-hidden="true">9.</strong> Working with Strings and Slices</a></li><li class="chapter-item expanded "><a href="../chapters/10-advanced-ownership.html"><strong aria-hidden="true">10.</strong> Advanced Ownership Patterns</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 3: Organizing Code</li><li class="chapter-item expanded "><a href="../chapters/11-structs.html"><strong aria-hidden="true">11.</strong> Structs and Custom Types</a></li><li class="chapter-item expanded "><a href="../chapters/12-enums.html"><strong aria-hidden="true">12.</strong> Enums and Pattern Matching</a></li><li class="chapter-item expanded "><a href="../chapters/13-modules.html"><strong aria-hidden="true">13.</strong> Modules and Organizing Code</a></li><li class="chapter-item expanded "><a href="../chapters/14-collections.html"><strong aria-hidden="true">14.</strong> Collections and Data Structures</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 4: Generic Programming</li><li class="chapter-item expanded "><a href="../chapters/15-generics.html"><strong aria-hidden="true">15.</strong> Introduction to Generics</a></li><li class="chapter-item expanded "><a href="../chapters/16-traits.html"><strong aria-hidden="true">16.</strong> Traits and Polymorphism</a></li><li class="chapter-item expanded "><a href="../chapters/17-advanced-traits.html"><strong aria-hidden="true">17.</strong> Advanced Trait Patterns</a></li><li class="chapter-item expanded "><a href="../chapters/18-lifetimes.html"><strong aria-hidden="true">18.</strong> Understanding Lifetimes</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 5: Error Handling</li><li class="chapter-item expanded "><a href="../chapters/19-panic.html"><strong aria-hidden="true">19.</strong> Panic and Unrecoverable Errors</a></li><li class="chapter-item expanded "><a href="../chapters/20-result-option.html"><strong aria-hidden="true">20.</strong> Result, Option, and Recoverable Errors</a></li><li class="chapter-item expanded "><a href="../chapters/21-error-patterns.html"><strong aria-hidden="true">21.</strong> Error Handling Patterns and Libraries</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 6: Advanced Rust</li><li class="chapter-item expanded "><a href="../chapters/22-iterators.html"><strong aria-hidden="true">22.</strong> Iterators and Functional Programming</a></li><li class="chapter-item expanded "><a href="../chapters/23-closures.html"><strong aria-hidden="true">23.</strong> Closures in Depth</a></li><li class="chapter-item expanded "><a href="../chapters/24-concurrency.html"><strong aria-hidden="true">24.</strong> Concurrency Fundamentals</a></li><li class="chapter-item expanded "><a href="../chapters/25-async.html"><strong aria-hidden="true">25.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="../chapters/26-macros.html"><strong aria-hidden="true">26.</strong> Macros and Metaprogramming</a></li><li class="chapter-item expanded "><a href="../chapters/27-unsafe.html"><strong aria-hidden="true">27.</strong> Unsafe Rust</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 7: Practical Rust</li><li class="chapter-item expanded "><a href="../chapters/28-testing.html"><strong aria-hidden="true">28.</strong> Writing Tests in Rust</a></li><li class="chapter-item expanded "><a href="../chapters/29-cli.html"><strong aria-hidden="true">29.</strong> Command-Line Applications</a></li><li class="chapter-item expanded "><a href="../chapters/30-web.html"><strong aria-hidden="true">30.</strong> Web Development with Rust</a></li><li class="chapter-item expanded "><a href="../chapters/31-database.html"><strong aria-hidden="true">31.</strong> Database Interaction</a></li><li class="chapter-item expanded "><a href="../chapters/32-network.html"><strong aria-hidden="true">32.</strong> Network Programming</a></li><li class="chapter-item expanded "><a href="../chapters/33-systems.html"><strong aria-hidden="true">33.</strong> Systems Programming</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 8: The Rust Ecosystem</li><li class="chapter-item expanded "><a href="../chapters/34-cargo.html"><strong aria-hidden="true">34.</strong> Package Management with Cargo</a></li><li class="chapter-item expanded "><a href="../chapters/35-build-systems.html"><strong aria-hidden="true">35.</strong> Build Systems and Tooling</a></li><li class="chapter-item expanded "><a href="../chapters/36-performance.html"><strong aria-hidden="true">36.</strong> Performance Optimization</a></li><li class="chapter-item expanded "><a href="../chapters/37-interoperability.html"><strong aria-hidden="true">37.</strong> Interoperability with Other Languages</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 9: Modern Rust Applications</li><li class="chapter-item expanded "><a href="../chapters/38-database-building.html"><strong aria-hidden="true">38.</strong> Building a Database</a></li><li class="chapter-item expanded "><a href="../chapters/39-game-development.html"><strong aria-hidden="true">39.</strong> Game Development</a></li><li class="chapter-item expanded "><a href="../chapters/40-cloud-native.html"><strong aria-hidden="true">40.</strong> Cloud Native Rust</a></li><li class="chapter-item expanded "><a href="../chapters/41-distributed-systems.html"><strong aria-hidden="true">41.</strong> Distributed Systems</a></li><li class="chapter-item expanded "><a href="../chapters/42-machine-learning.html"><strong aria-hidden="true">42.</strong> Machine Learning and Data Science</a></li><li class="chapter-item expanded "><a href="../chapters/43-embedded.html"><strong aria-hidden="true">43.</strong> Embedded Systems and IoT</a></li><li class="chapter-item expanded "><a href="../chapters/44-production-ready.html"><strong aria-hidden="true">44.</strong> Production-Ready Rust</a></li><li class="chapter-item expanded affix "><li class="part-title">Section 10: Capstone Projects</li><li class="chapter-item expanded "><a href="../chapters/45-search-engine.html"><strong aria-hidden="true">45.</strong> Building a Search Engine</a></li><li class="chapter-item expanded "><a href="../chapters/46-programming-language.html"><strong aria-hidden="true">46.</strong> Developing a Programming Language</a></li><li class="chapter-item expanded "><a href="../chapters/47-blockchain.html"><strong aria-hidden="true">47.</strong> Creating a Blockchain Application</a></li><li class="chapter-item expanded "><a href="../chapters/48-data-processing.html"><strong aria-hidden="true">48.</strong> Real-Time Data Processing System</a></li><li class="chapter-item expanded "><a href="../chapters/49-wasm-frontend.html"><strong aria-hidden="true">49.</strong> WebAssembly and Frontend Development</a></li><li class="chapter-item expanded "><a href="../chapters/50-advanced-memory.html"><strong aria-hidden="true">50.</strong> Advanced Memory Management</a></li><li class="chapter-item expanded "><a href="../chapters/51-edge-computing.html"><strong aria-hidden="true">51.</strong> Rust for Edge Computing</a></li><li class="chapter-item expanded "><a href="../chapters/52-security.html"><strong aria-hidden="true">52.</strong> Rust Security Patterns and Auditing</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="../appendices/a-idioms-patterns.html"><strong aria-hidden="true">53.</strong> Common Rust Idioms and Patterns</a></li><li class="chapter-item expanded "><a href="../appendices/b-rust-evolution.html"><strong aria-hidden="true">54.</strong> Rust's Evolution: Editions and Features</a></li><li class="chapter-item expanded "><a href="../appendices/c-language-comparison.html"><strong aria-hidden="true">55.</strong> Comparison with Other Languages</a></li><li class="chapter-item expanded "><a href="../appendices/d-recommended-libraries.html"><strong aria-hidden="true">56.</strong> Recommended Libraries and Crates</a></li><li class="chapter-item expanded "><a href="../appendices/e-memory-model.html"><strong aria-hidden="true">57.</strong> Rust's Memory Model In-Depth</a></li><li class="chapter-item expanded "><a href="../appendices/f-community-resources.html"><strong aria-hidden="true">58.</strong> Community Resources and Contribution Guide</a></li><li class="chapter-item expanded "><a href="../appendices/g-debugging.html"><strong aria-hidden="true">59.</strong> Debugging and Troubleshooting Guide</a></li><li class="chapter-item expanded "><a href="../appendices/h-optimization-cookbook.html"><strong aria-hidden="true">60.</strong> Performance Optimization Cookbook</a></li><li class="chapter-item expanded "><a href="../appendices/i-glossary.html"><strong aria-hidden="true">61.</strong> Comprehensive Glossary</a></li><li class="chapter-item expanded "><a href="../appendices/j-learning-paths.html"><strong aria-hidden="true">62.</strong> Learning Paths for Different Backgrounds</a></li><li class="chapter-item expanded "><a href="../appendices/k-interview-questions.html"><strong aria-hidden="true">63.</strong> Interview Questions and Answers</a></li><li class="chapter-item expanded "><a href="../appendices/l-resources.html"><strong aria-hidden="true">64.</strong> Recommended Reading and Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Universe: Fearless Systems Engineering</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/saeedalam/rust-universe" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/saeedalam/rust-universe/edit/main/src/chapters/05-control-flow.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-5-control-flow-in-rust"><a class="header" href="#chapter-5-control-flow-in-rust">Chapter 5: Control Flow in Rust</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Control flow is at the heart of any programming language, determining how a program executes based on conditions and iterations. Rust's approach to control flow combines familiar constructs with powerful, expression-based semantics that set it apart from many other languages.</p>
<p>By the end of this chapter, you'll understand:</p>
<ul>
<li>The critical distinction between expressions and statements in Rust</li>
<li>How conditional logic works in Rust using <code>if</code> and <code>else</code></li>
<li>The various loop constructs available in Rust</li>
<li>How Rust's loops differ from those in other programming languages</li>
<li>Working with ranges to create sequences of values</li>
<li>The powerful pattern matching capabilities of <code>match</code> expressions</li>
<li>How to control program flow with <code>break</code>, <code>continue</code>, and early returns</li>
<li>Using labeled loops for complex nested structures</li>
<li>Applying control flow to handle errors effectively</li>
<li>Building a complete number guessing game that combines these concepts</li>
</ul>
<h2 id="expressions-vs-statements"><a class="header" href="#expressions-vs-statements">Expressions vs Statements</a></h2>
<p>One of the most distinctive features of Rust is its expression-based nature. Understanding the difference between expressions and statements is fundamental to thinking in Rust.</p>
<h3 id="what-are-expressions-and-statements"><a class="header" href="#what-are-expressions-and-statements">What are Expressions and Statements?</a></h3>
<ul>
<li><strong>Expressions</strong> evaluate to a value</li>
<li><strong>Statements</strong> perform an action but don't return a value</li>
</ul>
<p>In many programming languages, this distinction isn't emphasized, but in Rust, it's crucial. Most constructs in Rust are expressions, which allows for more concise and expressive code.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Statement: doesn't return a value
    let y = 6; // The whole let statement doesn't return a value

    // Expression: evaluates to a value
    let x = 5 + 5; // 5 + 5 is an expression that evaluates to 10

    // Block expressions evaluate to the last expression in the block
    let z = {
        let inner = 3;
        inner * 4 // Note: no semicolon here, making it an expression
    };
    println!(&quot;z: {}&quot;, z); // z: 12

    // Adding a semicolon turns an expression into a statement
    let w = {
        let inner = 3;
        inner * 4; // Semicolon added, now returns () (unit type)
        5 // This is the expression that's returned
    };
    println!(&quot;w: {}&quot;, w); // w: 5
}</code></pre></pre>
<p>The lack of a semicolon at the end of a block makes it an expression that evaluates to the value of its last line. This is an important pattern in Rust that we'll see frequently.</p>
<h3 id="expressions-in-function-returns"><a class="header" href="#expressions-in-function-returns">Expressions in Function Returns</a></h3>
<p>Expressions are particularly useful when returning values from functions:</p>
<pre><pre class="playground"><code class="language-rust">// This function returns the value of the final expression
fn expression_return() -&gt; i32 {
    let x = 5;
    x + 1 // No semicolon, so this expression's value is returned
}

// This function uses a return statement
fn statement_return() -&gt; i32 {
    let x = 5;
    return x + 1; // Explicit return statement
}

fn main() {
    println!(&quot;expression_return: {}&quot;, expression_return()); // 6
    println!(&quot;statement_return: {}&quot;, statement_return());   // 6
}</code></pre></pre>
<h3 id="the-unit-type"><a class="header" href="#the-unit-type">The Unit Type</a></h3>
<p>In Rust, the unit type <code>()</code> is used to indicate &quot;no value.&quot; It's similar to <code>void</code> in other languages, but it's an actual type:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Statements have type ()
    let x = (let y = 6); // Error: let statements don't return a value

    // Functions with no return value implicitly return ()
    fn print_hello() {
        println!(&quot;Hello&quot;);
    }

    let result = print_hello(); // result has type ()

    // Explicitly returning unit
    fn explicit_unit() -&gt; () {
        return ();
    }
}</code></pre></pre>
<p>Understanding when you're working with expressions vs. statements will help you write more idiomatic Rust code.</p>
<h2 id="conditional-expressions"><a class="header" href="#conditional-expressions">Conditional Expressions</a></h2>
<p>In Rust, <code>if</code> is an expression, not just a statement. This means it can be used on the right side of a <code>let</code> statement to assign a value based on a condition.</p>
<h3 id="basic-ifelse-syntax"><a class="header" href="#basic-ifelse-syntax">Basic If/Else Syntax</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}</code></pre></pre>
<h3 id="if-as-an-expression"><a class="header" href="#if-as-an-expression">If as an Expression</a></h3>
<p>Because <code>if</code> is an expression, it can return a value:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;

    // if is an expression, so it returns a value
    let number = if condition { 5 } else { 6 };

    println!(&quot;The value of number is: {}&quot;, number); // 5

    // Both branches must return the same type
    // This would not compile:
    // let number = if condition { 5 } else { &quot;six&quot; };
}</code></pre></pre>
<p>When using <code>if</code> as an expression, all branches must return the same type, and every possible condition must be covered. This is enforced by the compiler.</p>
<h3 id="nested-conditions"><a class="header" href="#nested-conditions">Nested Conditions</a></h3>
<p>You can nest conditions within each other:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num = 15;

    let description = if num &lt; 10 {
        &quot;less than 10&quot;
    } else if num &lt; 20 {
        if num % 2 == 0 {
            &quot;between 10 and 20, even&quot;
        } else {
            &quot;between 10 and 20, odd&quot;
        }
    } else {
        &quot;20 or greater&quot;
    };

    println!(&quot;Number is {}&quot;, description); // &quot;between 10 and 20, odd&quot;
}</code></pre></pre>
<h3 id="ternary-like-expressions"><a class="header" href="#ternary-like-expressions">Ternary-like Expressions</a></h3>
<p>Rust doesn't have a traditional ternary operator (<code>condition ? true_case : false_case</code>), but the <code>if-else</code> expression serves the same purpose:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let age = 20;
    let status = if age &gt;= 18 { &quot;adult&quot; } else { &quot;minor&quot; };

    println!(&quot;Status: {}&quot;, status); // &quot;adult&quot;
}</code></pre></pre>
<h2 id="loops"><a class="header" href="#loops">Loops</a></h2>
<p>Rust provides three kinds of loops: <code>loop</code>, <code>while</code>, and <code>for</code>. Each has its own use cases and advantages.</p>
<h3 id="the-loop-expression"><a class="header" href="#the-loop-expression">The Loop Expression</a></h3>
<p>The <code>loop</code> keyword gives us an infinite loop that continues until explicitly broken:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    loop {
        counter += 1;

        if counter == 10 {
            break; // Exit the loop
        }

        if counter % 2 == 0 {
            continue; // Skip to the next iteration
        }

        println!(&quot;counter: {}&quot;, counter);
    }

    println!(&quot;After loop, counter: {}&quot;, counter);
}</code></pre></pre>
<h3 id="loop-as-an-expression"><a class="header" href="#loop-as-an-expression">Loop as an Expression</a></h3>
<p>Like <code>if</code>, <code>loop</code> is also an expression. You can return a value from a loop using <code>break</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2; // Return counter * 2 from the loop
        }
    };

    println!(&quot;Result: {}&quot;, result); // Result: 20
}</code></pre></pre>
<p>This is particularly useful for retry logic or when you need to compute a value through iteration.</p>
<h3 id="while-loops"><a class="header" href="#while-loops">While Loops</a></h3>
<p><code>while</code> loops combine a condition with a loop, running until the condition is no longer true:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{}!&quot;, number);
        number -= 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}</code></pre></pre>
<p>While loops are ideal when you need to continue looping until a specific condition is met.</p>
<h3 id="for-loops"><a class="header" href="#for-loops">For Loops</a></h3>
<p>The <code>for</code> loop is the most commonly used loop in Rust. It's used to iterate over elements of a collection, like an array or range:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Iterating over a range
    for number in 1..4 {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;LIFTOFF!!!&quot;);

    // Iterating over an array
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!(&quot;The value is: {}&quot;, element);
    }

    // Iterating with an index
    for (index, &amp;value) in a.iter().enumerate() {
        println!(&quot;a[{}] = {}&quot;, index, value);
    }
}</code></pre></pre>
<p>For loops in Rust are safe and prevent common errors like off-by-one errors or accessing elements outside of array bounds.</p>
<h2 id="how-rusts-loops-differ-from-other-languages"><a class="header" href="#how-rusts-loops-differ-from-other-languages">How Rust's Loops Differ from Other Languages</a></h2>
<p>Rust's loops might look familiar, but they have several important differences from loops in other languages:</p>
<h3 id="1-expression-oriented"><a class="header" href="#1-expression-oriented">1. Expression-oriented</a></h3>
<p>All loops can be expressions that return values:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = loop {
    if some_condition {
        break some_value;
    }
};
<span class="boring">}</span></code></pre></pre>
<p>This expression-oriented approach allows for more concise code in many situations.</p>
<h3 id="2-no-c-style-for-loops"><a class="header" href="#2-no-c-style-for-loops">2. No C-style For Loops</a></h3>
<p>Rust doesn't have the traditional C-style for loop with initialization, condition, and increment:</p>
<pre><code class="language-c">// C-style loop - NOT AVAILABLE IN RUST
for (int i = 0; i &lt; 10; i++) {
    printf(&quot;%d\n&quot;, i);
}
</code></pre>
<p>Instead, Rust uses ranges and iterators:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust loop
for i in 0..10 {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-safety-first"><a class="header" href="#3-safety-first">3. Safety First</a></h3>
<p>Rust's loops are designed to be safe. There's no risk of off-by-one errors or accessing elements outside of a collection's bounds.</p>
<h3 id="4-iterator-based"><a class="header" href="#4-iterator-based">4. Iterator-based</a></h3>
<p>Rust's <code>for</code> loops are built on the iterator system, which provides a uniform interface for iterating over different types of collections. This makes them more powerful and flexible.</p>
<h3 id="5-ownership-aware"><a class="header" href="#5-ownership-aware">5. Ownership-aware</a></h3>
<p>Loops respect Rust's ownership system. When you iterate over a collection, you can choose to take ownership of elements, borrow them, or use mutable references:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];

// Borrow elements
for item in &amp;v {
    println!(&quot;{}&quot;, item);
}

// Take ownership (v is moved into the for loop)
for item in v {
    println!(&quot;{}&quot;, item);
}
// v is no longer accessible here
<span class="boring">}</span></code></pre></pre>
<h2 id="range-expressions"><a class="header" href="#range-expressions">Range Expressions</a></h2>
<p>Ranges in Rust are a concise way to express a sequence of values:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Range expressions
    let range1 = 1..5;    // Includes 1, 2, 3, 4 (exclusive upper bound)
    let range2 = 1..=5;   // Includes 1, 2, 3, 4, 5 (inclusive upper bound)

    // Using ranges in for loops
    for i in 1..5 {
        println!(&quot;{}&quot;, i);  // Prints 1 2 3 4
    }

    for i in 1..=5 {
        println!(&quot;{}&quot;, i);  // Prints 1 2 3 4 5
    }

    // Ranges with chars
    for c in 'a'..='e' {
        print!(&quot;{} &quot;, c);  // Prints a b c d e
    }
    println!();

    // Using step_by to skip values
    for i in (0..10).step_by(2) {
        print!(&quot;{} &quot;, i);  // Prints 0 2 4 6 8
    }
    println!();

    // Ranges can be used for slicing
    let numbers = [1, 2, 3, 4, 5];
    let slice = &amp;numbers[1..4]; // [2, 3, 4]

    // Ranges can be unbounded
    let from_three = 3..;  // From 3 to infinity (conceptually)
    let up_to_five = ..5;  // From negative infinity to 5 (exclusive)
    let everything = ..;   // The entire range

    // Using ranges in pattern matching
    let x = 5;
    match x {
        1..=5 =&gt; println!(&quot;x is between 1 and 5&quot;),
        _ =&gt; println!(&quot;x is something else&quot;),
    }
}</code></pre></pre>
<p>Ranges are a powerful feature that make iterating over sequences concise and readable.</p>
<h2 id="match-expressions-basics"><a class="header" href="#match-expressions-basics">Match Expressions Basics</a></h2>
<p>The <code>match</code> expression is one of Rust's most powerful features. It's similar to a <code>switch</code> statement in other languages, but far more powerful.</p>
<h3 id="basic-match-syntax"><a class="header" href="#basic-match-syntax">Basic Match Syntax</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 13;

    match number {
        // Match a single value
        1 =&gt; println!(&quot;One!&quot;),

        // Match multiple values
        2 | 3 | 5 | 7 | 11 | 13 =&gt; println!(&quot;This is a prime&quot;),

        // Match a range
        6..=10 =&gt; println!(&quot;Six through ten&quot;),

        // Default case
        _ =&gt; println!(&quot;Another number&quot;),
    }
}</code></pre></pre>
<h3 id="match-as-an-expression"><a class="header" href="#match-as-an-expression">Match as an Expression</a></h3>
<p>Like <code>if</code> and <code>loop</code>, <code>match</code> is also an expression that returns a value:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 13;

    let message = match number {
        1 =&gt; &quot;One!&quot;,
        2 | 3 | 5 | 7 | 11 | 13 =&gt; &quot;This is a prime&quot;,
        6..=10 =&gt; &quot;Six through ten&quot;,
        _ =&gt; &quot;Another number&quot;,
    };

    println!(&quot;Message: {}&quot;, message); // &quot;This is a prime&quot;
}</code></pre></pre>
<h3 id="exhaustiveness-checking"><a class="header" href="#exhaustiveness-checking">Exhaustiveness Checking</a></h3>
<p>Rust's <code>match</code> must be exhaustive, meaning every possible value of the matched expression must be covered:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let dice_roll = 9;

    match dice_roll {
        1 =&gt; println!(&quot;Critical failure!&quot;),
        2..=5 =&gt; println!(&quot;Normal roll&quot;),
        6 =&gt; println!(&quot;Critical success!&quot;),
        // Without this catch-all case, the compiler would complain
        // since dice_roll could be any i32 value
        _ =&gt; println!(&quot;Invalid dice roll&quot;),
    }
}</code></pre></pre>
<p>This requirement ensures that you've considered all possible cases, preventing subtle bugs.</p>
<h2 id="pattern-matching-basics"><a class="header" href="#pattern-matching-basics">Pattern Matching Basics</a></h2>
<p>Pattern matching goes beyond simple values in <code>match</code> expressions. It allows you to destructure complex data types.</p>
<h3 id="matching-with-tuples"><a class="header" href="#matching-with-tuples">Matching with Tuples</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let point = (3, 5);

    match point {
        (0, 0) =&gt; println!(&quot;Origin&quot;),
        (0, y) =&gt; println!(&quot;X-axis at y={}&quot;, y),
        (x, 0) =&gt; println!(&quot;Y-axis at x={}&quot;, x),
        (x, y) =&gt; println!(&quot;Point at ({}, {})&quot;, x, y),
    }
}</code></pre></pre>
<h3 id="destructuring-structs"><a class="header" href="#destructuring-structs">Destructuring Structs</a></h3>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x: 0, y } =&gt; println!(&quot;On the y-axis at y={}&quot;, y),
        Point { x, y: 0 } =&gt; println!(&quot;On the x-axis at x={}&quot;, x),
        Point { x, y } =&gt; println!(&quot;Point at ({}, {})&quot;, x, y),
    }
}</code></pre></pre>
<h3 id="ignoring-values-with-_"><a class="header" href="#ignoring-values-with-_">Ignoring Values with _</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth);
        }
    }
}</code></pre></pre>
<h3 id="match-guards"><a class="header" href="#match-guards">Match Guards</a></h3>
<p>You can add extra conditions to match arms with a <code>if</code> guard:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 4;

    match number {
        n if n &lt; 0 =&gt; println!(&quot;Negative number&quot;),
        n if n % 2 == 0 =&gt; println!(&quot;Even number&quot;),
        n if n % 2 == 1 =&gt; println!(&quot;Odd number&quot;),
        // This _ case would never execute because all cases are covered
        _ =&gt; unreachable!(),
    }
}</code></pre></pre>
<h3 id="binding-with--operator"><a class="header" href="#binding-with--operator">Binding with @ Operator</a></h3>
<p>The <code>@</code> operator lets you bind a value while also testing it:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    match x {
        n @ 1..=5 =&gt; println!(&quot;Got a small number: {}&quot;, n),
        n @ 6..=10 =&gt; println!(&quot;Got a medium number: {}&quot;, n),
        n =&gt; println!(&quot;Got a big number: {}&quot;, n),
    }
}</code></pre></pre>
<h2 id="early-returns-break-and-continue"><a class="header" href="#early-returns-break-and-continue">Early Returns, Break, and Continue</a></h2>
<p>Rust provides several ways to control the flow of execution within loops and functions.</p>
<h3 id="early-returns-in-functions"><a class="header" href="#early-returns-in-functions">Early Returns in Functions</a></h3>
<pre><pre class="playground"><code class="language-rust">fn find_even(numbers: &amp;[i32]) -&gt; Option&lt;i32&gt; {
    for &amp;num in numbers {
        if num % 2 == 0 {
            return Some(num); // Early return when we find an even number
        }
    }

    None // Return None if no even number is found
}

fn main() {
    let numbers = [1, 3, 5, 6, 9, 11];

    match find_even(&amp;numbers) {
        Some(n) =&gt; println!(&quot;Found even number: {}&quot;, n),
        None =&gt; println!(&quot;No even numbers found&quot;),
    }
}</code></pre></pre>
<p>Early returns are a clean way to handle special cases without deeply nested conditionals.</p>
<h3 id="break-and-continue"><a class="header" href="#break-and-continue">Break and Continue</a></h3>
<p>As we've seen, <code>break</code> exits a loop, while <code>continue</code> skips to the next iteration:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for i in 0..10 {
        if i % 2 == 0 {
            continue; // Skip even numbers
        }

        if i &gt; 7 {
            break; // Stop once we reach 8
        }

        println!(&quot;{}&quot;, i); // Prints 1, 3, 5, 7
    }
}</code></pre></pre>
<h2 id="loop-labels"><a class="header" href="#loop-labels">Loop Labels</a></h2>
<p>Rust allows you to label loops and break or continue specific loops in nested scenarios:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    'outer: for x in 0..5 {
        println!(&quot;x: {}&quot;, x);

        'inner: for y in 0..5 {
            println!(&quot;  y: {}&quot;, y);

            if y == 2 &amp;&amp; x == 1 {
                break 'outer; // Break out of the outer loop
            }

            if y == 1 {
                continue 'inner; // Skip to the next iteration of the inner loop
            }
        }
    }
}</code></pre></pre>
<p>Loop labels are especially useful when you have nested loops and need to control which loop is affected by <code>break</code> or <code>continue</code>.</p>
<h2 id="using-match-expressions-for-error-handling"><a class="header" href="#using-match-expressions-for-error-handling">Using Match Expressions for Error Handling</a></h2>
<p>One common use of <code>match</code> is to handle possible error conditions with <code>Option</code> and <code>Result</code> types:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = vec![1, 2, 3];

    // Using match with Option
    match numbers.get(5) {
        Some(value) =&gt; println!(&quot;Value at index 5: {}&quot;, value),
        None =&gt; println!(&quot;No value at index 5&quot;),
    }

    // Using match with Result
    let parse_result = &quot;42&quot;.parse::&lt;i32&gt;();
    match parse_result {
        Ok(number) =&gt; println!(&quot;Parsed number: {}&quot;, number),
        Err(error) =&gt; println!(&quot;Failed to parse: {}&quot;, error),
    }

    // Using if let for simpler matching
    if let Some(value) = numbers.get(1) {
        println!(&quot;Value at index 1: {}&quot;, value);
    }

    // Using while let for conditional loops
    let mut stack = Vec::new();
    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(value) = stack.pop() {
        println!(&quot;Popped: {}&quot;, value);
    }
}</code></pre></pre>
<p>This pattern-based approach to error handling is one of Rust's distinctive features, allowing for expressive and type-safe code.</p>
<h2 id="-project-number-guessing-game"><a class="header" href="#-project-number-guessing-game">üî® Project: Number Guessing Game</a></h2>
<p>Let's create a complete number guessing game to apply what we've learned about control flow in Rust.</p>
<h3 id="project-requirements"><a class="header" href="#project-requirements">Project Requirements</a></h3>
<ol>
<li>Generate a random number for the player to guess</li>
<li>Allow the player to input guesses</li>
<li>Provide feedback on whether the guess is too high, too low, or correct</li>
<li>Track the number of guesses and offer hints after several attempts</li>
<li>Allow multiple rounds of play</li>
</ol>
<h3 id="step-1-create-the-project"><a class="header" href="#step-1-create-the-project">Step 1: Create the Project</a></h3>
<pre><code class="language-bash">cargo new guessing_game
cd guessing_game
</code></pre>
<h3 id="step-2-add-dependencies"><a class="header" href="#step-2-add-dependencies">Step 2: Add Dependencies</a></h3>
<p>Edit your <code>Cargo.toml</code> file to add the <code>rand</code> crate:</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.5&quot;
</code></pre>
<h3 id="step-3-implement-the-game"><a class="header" href="#step-3-implement-the-game">Step 3: Implement the Game</a></h3>
<p>Now, let's write the code in <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use rand::Rng;
use std::cmp::Ordering;
use std::io::{self, Write};

fn main() {
    println!(&quot;üéÆ NUMBER GUESSING GAME üéÆ&quot;);
    println!(&quot;I'm thinking of a number between 1 and 100...&quot;);

    let mut play_again = true;
    let mut total_games = 0;
    let mut best_score = usize::MAX;

    while play_again {
        let secret_number = rand::thread_rng().gen_range(1..=100);
        let mut guesses = 0;
        let mut has_hint = false;

        loop {
            // Get user input
            print!(&quot;Enter your guess: &quot;);
            io::stdout().flush().unwrap(); // Ensure the prompt is displayed

            let mut guess = String::new();
            io::stdin()
                .read_line(&amp;mut guess)
                .expect(&quot;Failed to read line&quot;);

            // Parse the guess
            let guess: u32 = match guess.trim().parse() {
                Ok(num) =&gt; num,
                Err(_) =&gt; {
                    println!(&quot;Please enter a valid number!&quot;);
                    continue;
                }
            };

            guesses += 1;

            // Compare the guess with the secret number
            match guess.cmp(&amp;secret_number) {
                Ordering::Less =&gt; {
                    println!(&quot;Too small!&quot;);

                    // Provide a hint after 5 guesses
                    if guesses &gt;= 5 &amp;&amp; !has_hint {
                        has_hint = true;
                        let range = if secret_number &lt;= 50 { &quot;1-50&quot; } else { &quot;51-100&quot; };
                        println!(&quot;Hint: The number is in the range {}&quot;, range);
                    }
                }
                Ordering::Greater =&gt; {
                    println!(&quot;Too big!&quot;);

                    // Provide a hint after 5 guesses
                    if guesses &gt;= 5 &amp;&amp; !has_hint {
                        has_hint = true;
                        let range = if secret_number &lt;= 50 { &quot;1-50&quot; } else { &quot;51-100&quot; };
                        println!(&quot;Hint: The number is in the range {}&quot;, range);
                    }
                }
                Ordering::Equal =&gt; {
                    if guesses == 1 {
                        println!(&quot;üéâ You got it in 1 guess! Incredible!&quot;);
                    } else {
                        println!(&quot;üéâ You got it in {} guesses!&quot;, guesses);
                    }

                    // Update best score
                    if guesses &lt; best_score {
                        best_score = guesses;
                        println!(&quot;That's a new best score!&quot;);
                    }

                    break;
                }
            }
        }

        total_games += 1;

        // Ask to play again
        loop {
            print!(&quot;Play again? (y/n): &quot;);
            io::stdout().flush().unwrap();

            let mut response = String::new();
            io::stdin().read_line(&amp;mut response).expect(&quot;Failed to read line&quot;);

            match response.trim().to_lowercase().as_str() {
                &quot;y&quot; | &quot;yes&quot; =&gt; {
                    println!(&quot;\nGreat! Let's play again!&quot;);
                    println!(&quot;I'm thinking of a new number between 1 and 100...&quot;);
                    break;
                }
                &quot;n&quot; | &quot;no&quot; =&gt; {
                    play_again = false;
                    break;
                }
                _ =&gt; println!(&quot;Please enter y or n.&quot;),
            }
        }
    }

    // Game summary
    println!(&quot;\nüèÜ GAME SUMMARY üèÜ&quot;);
    println!(&quot;Games played: {}&quot;, total_games);

    if best_score != usize::MAX {
        println!(&quot;Best score: {} guesses&quot;, best_score);

        let rating = match best_score {
            1 =&gt; &quot;Psychic! üîÆ&quot;,
            2..=4 =&gt; &quot;Amazing! üåü&quot;,
            5..=7 =&gt; &quot;Good job! üëç&quot;,
            8..=10 =&gt; &quot;Not bad! üòä&quot;,
            _ =&gt; &quot;Keep practicing! üí™&quot;,
        };

        println!(&quot;Rating: {}&quot;, rating);
    }

    println!(&quot;\nThanks for playing!&quot;);
}</code></pre></pre>
<h3 id="step-4-run-the-game"><a class="header" href="#step-4-run-the-game">Step 4: Run the Game</a></h3>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="step-5-understanding-the-code"><a class="header" href="#step-5-understanding-the-code">Step 5: Understanding the Code</a></h3>
<p>This game demonstrates several control flow concepts:</p>
<ol>
<li><strong>Loops</strong>: Both <code>while</code> and <code>loop</code> for different purposes</li>
<li><strong>Match expressions</strong>: For comparing guesses and handling user input</li>
<li><strong>Early returns with <code>continue</code></strong>: To skip invalid inputs</li>
<li><strong>If/else conditionals</strong>: For providing hints and feedback</li>
<li><strong>Pattern matching with ranges</strong>: In the final rating system</li>
<li><strong>Break statements</strong>: To exit loops when a guess is correct</li>
<li><strong>Nested loops</strong>: For the main game loop and the play-again prompt</li>
</ol>
<h3 id="step-6-extending-the-game"><a class="header" href="#step-6-extending-the-game">Step 6: Extending the Game</a></h3>
<p>Here are some ways to extend the game:</p>
<ol>
<li>Add difficulty levels with different number ranges</li>
<li>Implement a time limit for each guess</li>
<li>Create a two-player mode</li>
<li>Add a graphical interface with a Rust GUI framework</li>
<li>Save high scores to a file</li>
</ol>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this chapter, we've explored Rust's control flow constructs, understanding how expressions differ from statements and how they affect Rust's programming style. We've covered:</p>
<ul>
<li>How Rust's expression-based nature distinguishes it from other languages</li>
<li>Working with conditional expressions using <code>if</code> and <code>else</code></li>
<li>The three types of loops: <code>loop</code>, <code>while</code>, and <code>for</code></li>
<li>How Rust's loops differ from loops in other languages</li>
<li>Creating and using ranges for sequences of values</li>
<li>Powerful pattern matching with <code>match</code> expressions</li>
<li>Controlling execution flow with <code>break</code>, <code>continue</code>, and early returns</li>
<li>Labeling loops for fine-grained control in nested loops</li>
<li>Using match expressions for effective error handling</li>
<li>Building a complete number guessing game application</li>
</ul>
<p>These control flow mechanisms are the building blocks for more complex Rust programs. The expression-oriented approach you've learned forms the foundation for much of Rust's syntax. As you continue your Rust journey, you'll find that thinking in terms of expressions makes your code more concise and often more readable.</p>
<p>In the next chapter, we'll dive into functions and procedures, exploring how to organize code into reusable units. We'll learn about parameters, return values, and how functions in Rust build upon the expression-based nature of the language that we've explored here.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li>
<p><strong>Expression Practice</strong>: Write a program that uses block expressions to calculate and assign values to variables. Experiment with adding semicolons to see how it changes the behavior.</p>
</li>
<li>
<p><strong>Control Flow Refactoring</strong>: Take a program written in another language that uses imperative control flow and rewrite it using Rust's expression-based approach.</p>
</li>
<li>
<p><strong>Pattern Matching Challenge</strong>: Create a program that matches different shapes (circles, rectangles, triangles) and calculates their areas using pattern matching.</p>
</li>
<li>
<p><strong>Loop Label Exercise</strong>: Write a program with nested loops that uses labeled breaks and continues to generate a specific pattern.</p>
</li>
<li>
<p><strong>Error Handling</strong>: Write a function that parses different types of input (numbers, dates, etc.) and uses match expressions to handle all possible error cases.</p>
</li>
<li>
<p><strong>Advanced Guessing Game</strong>: Extend the number guessing game with one or more of the suggested enhancements from Step 6.</p>
</li>
</ol>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html">The Rust Programming Language: Control Flow</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/flow_control.html">Rust By Example: Flow of Control</a></li>
<li><a href="https://doc.rust-lang.org/reference/expressions.html">The Rust Reference: Expressions</a></li>
<li><a href="https://doc.rust-lang.org/book/ch18-00-patterns.html">Pattern Matching in Rust</a></li>
<li><a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">Error Handling in Rust</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapters/04-basic-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapters/06-functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapters/04-basic-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapters/06-functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
