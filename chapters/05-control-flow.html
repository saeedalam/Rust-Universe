<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Control Flow in Rust - Rust Universe: Fearless Systems Engineering</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to learning the Rust programming language from fundamentals to mastery.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Universe: Fearless Systems Engineering</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/saeedalam/rust-universe" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/saeedalam/rust-universe/edit/main/src/chapters/05-control-flow.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-5-control-flow-in-rust"><a class="header" href="#chapter-5-control-flow-in-rust">Chapter 5: Control Flow in Rust</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Control flow is at the heart of any programming language, determining how a program executes based on conditions and iterations. Rust‚Äôs approach to control flow combines familiar constructs with powerful, expression-based semantics that set it apart from many other languages.</p>
<p>By the end of this chapter, you‚Äôll understand:</p>
<ul>
<li>The critical distinction between expressions and statements in Rust</li>
<li>How conditional logic works in Rust using <code>if</code> and <code>else</code></li>
<li>The various loop constructs available in Rust</li>
<li>How Rust‚Äôs loops differ from those in other programming languages</li>
<li>Working with ranges to create sequences of values</li>
<li>The powerful pattern matching capabilities of <code>match</code> expressions</li>
<li>How to control program flow with <code>break</code>, <code>continue</code>, and early returns</li>
<li>Using labeled loops for complex nested structures</li>
<li>Applying control flow to handle errors effectively</li>
<li>Building a complete number guessing game that combines these concepts</li>
</ul>
<h2 id="expressions-vs-statements"><a class="header" href="#expressions-vs-statements">Expressions vs Statements</a></h2>
<p>One of the most distinctive features of Rust is its expression-based nature. Understanding the difference between expressions and statements is fundamental to thinking in Rust.</p>
<h3 id="what-are-expressions-and-statements"><a class="header" href="#what-are-expressions-and-statements">What are Expressions and Statements?</a></h3>
<ul>
<li><strong>Expressions</strong> evaluate to a value</li>
<li><strong>Statements</strong> perform an action but don‚Äôt return a value</li>
</ul>
<p>In many programming languages, this distinction isn‚Äôt emphasized, but in Rust, it‚Äôs crucial. Most constructs in Rust are expressions, which allows for more concise and expressive code.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Statement: doesn't return a value
    let y = 6; // The whole let statement doesn't return a value

    // Expression: evaluates to a value
    let x = 5 + 5; // 5 + 5 is an expression that evaluates to 10

    // Block expressions evaluate to the last expression in the block
    let z = {
        let inner = 3;
        inner * 4 // Note: no semicolon here, making it an expression
    };
    println!("z: {}", z); // z: 12

    // Adding a semicolon turns an expression into a statement
    let w = {
        let inner = 3;
        inner * 4; // Semicolon added, now returns () (unit type)
        5 // This is the expression that's returned
    };
    println!("w: {}", w); // w: 5
}</code></pre></pre>
<p>The lack of a semicolon at the end of a block makes it an expression that evaluates to the value of its last line. This is an important pattern in Rust that we‚Äôll see frequently.</p>
<h3 id="expressions-in-function-returns"><a class="header" href="#expressions-in-function-returns">Expressions in Function Returns</a></h3>
<p>Expressions are particularly useful when returning values from functions:</p>
<pre><pre class="playground"><code class="language-rust">// This function returns the value of the final expression
fn expression_return() -&gt; i32 {
    let x = 5;
    x + 1 // No semicolon, so this expression's value is returned
}

// This function uses a return statement
fn statement_return() -&gt; i32 {
    let x = 5;
    return x + 1; // Explicit return statement
}

fn main() {
    println!("expression_return: {}", expression_return()); // 6
    println!("statement_return: {}", statement_return());   // 6
}</code></pre></pre>
<h3 id="the-unit-type"><a class="header" href="#the-unit-type">The Unit Type</a></h3>
<p>In Rust, the unit type <code>()</code> is used to indicate ‚Äúno value.‚Äù It‚Äôs similar to <code>void</code> in other languages, but it‚Äôs an actual type:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Statements have type ()
    let x = (let y = 6); // Error: let statements don't return a value

    // Functions with no return value implicitly return ()
    fn print_hello() {
        println!("Hello");
    }

    let result = print_hello(); // result has type ()

    // Explicitly returning unit
    fn explicit_unit() -&gt; () {
        return ();
    }
}</code></pre></pre>
<p>Understanding when you‚Äôre working with expressions vs. statements will help you write more idiomatic Rust code.</p>
<h2 id="conditional-expressions"><a class="header" href="#conditional-expressions">Conditional Expressions</a></h2>
<p>In Rust, <code>if</code> is an expression, not just a statement. This means it can be used on the right side of a <code>let</code> statement to assign a value based on a condition.</p>
<h3 id="basic-ifelse-syntax"><a class="header" href="#basic-ifelse-syntax">Basic If/Else Syntax</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}</code></pre></pre>
<h3 id="if-as-an-expression"><a class="header" href="#if-as-an-expression">If as an Expression</a></h3>
<p>Because <code>if</code> is an expression, it can return a value:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;

    // if is an expression, so it returns a value
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number); // 5

    // Both branches must return the same type
    // This would not compile:
    // let number = if condition { 5 } else { "six" };
}</code></pre></pre>
<p>When using <code>if</code> as an expression, all branches must return the same type, and every possible condition must be covered. This is enforced by the compiler.</p>
<h3 id="nested-conditions"><a class="header" href="#nested-conditions">Nested Conditions</a></h3>
<p>You can nest conditions within each other:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num = 15;

    let description = if num &lt; 10 {
        "less than 10"
    } else if num &lt; 20 {
        if num % 2 == 0 {
            "between 10 and 20, even"
        } else {
            "between 10 and 20, odd"
        }
    } else {
        "20 or greater"
    };

    println!("Number is {}", description); // "between 10 and 20, odd"
}</code></pre></pre>
<h3 id="ternary-like-expressions"><a class="header" href="#ternary-like-expressions">Ternary-like Expressions</a></h3>
<p>Rust doesn‚Äôt have a traditional ternary operator (<code>condition ? true_case : false_case</code>), but the <code>if-else</code> expression serves the same purpose:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let age = 20;
    let status = if age &gt;= 18 { "adult" } else { "minor" };

    println!("Status: {}", status); // "adult"
}</code></pre></pre>
<h2 id="loops"><a class="header" href="#loops">Loops</a></h2>
<p>Rust provides three kinds of loops: <code>loop</code>, <code>while</code>, and <code>for</code>. Each has its own use cases and advantages.</p>
<h3 id="the-loop-expression"><a class="header" href="#the-loop-expression">The Loop Expression</a></h3>
<p>The <code>loop</code> keyword gives us an infinite loop that continues until explicitly broken:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    loop {
        counter += 1;

        if counter == 10 {
            break; // Exit the loop
        }

        if counter % 2 == 0 {
            continue; // Skip to the next iteration
        }

        println!("counter: {}", counter);
    }

    println!("After loop, counter: {}", counter);
}</code></pre></pre>
<h3 id="loop-as-an-expression"><a class="header" href="#loop-as-an-expression">Loop as an Expression</a></h3>
<p>Like <code>if</code>, <code>loop</code> is also an expression. You can return a value from a loop using <code>break</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2; // Return counter * 2 from the loop
        }
    };

    println!("Result: {}", result); // Result: 20
}</code></pre></pre>
<p>This is particularly useful for retry logic or when you need to compute a value through iteration.</p>
<h3 id="while-loops"><a class="header" href="#while-loops">While Loops</a></h3>
<p><code>while</code> loops combine a condition with a loop, running until the condition is no longer true:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);
        number -= 1;
    }

    println!("LIFTOFF!!!");
}</code></pre></pre>
<p>While loops are ideal when you need to continue looping until a specific condition is met.</p>
<h3 id="for-loops"><a class="header" href="#for-loops">For Loops</a></h3>
<p>The <code>for</code> loop is the most commonly used loop in Rust. It‚Äôs used to iterate over elements of a collection, like an array or range:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Iterating over a range
    for number in 1..4 {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");

    // Iterating over an array
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("The value is: {}", element);
    }

    // Iterating with an index
    for (index, &amp;value) in a.iter().enumerate() {
        println!("a[{}] = {}", index, value);
    }
}</code></pre></pre>
<p>For loops in Rust are safe and prevent common errors like off-by-one errors or accessing elements outside of array bounds.</p>
<h2 id="how-rusts-loops-differ-from-other-languages"><a class="header" href="#how-rusts-loops-differ-from-other-languages">How Rust‚Äôs Loops Differ from Other Languages</a></h2>
<p>Rust‚Äôs loops might look familiar, but they have several important differences from loops in other languages:</p>
<h3 id="1-expression-oriented"><a class="header" href="#1-expression-oriented">1. Expression-oriented</a></h3>
<p>All loops can be expressions that return values:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = loop {
    if some_condition {
        break some_value;
    }
};
<span class="boring">}</span></code></pre></pre>
<p>This expression-oriented approach allows for more concise code in many situations.</p>
<h3 id="2-no-c-style-for-loops"><a class="header" href="#2-no-c-style-for-loops">2. No C-style For Loops</a></h3>
<p>Rust doesn‚Äôt have the traditional C-style for loop with initialization, condition, and increment:</p>
<pre><code class="language-c">// C-style loop - NOT AVAILABLE IN RUST
for (int i = 0; i &lt; 10; i++) {
    printf("%d\n", i);
}
</code></pre>
<p>Instead, Rust uses ranges and iterators:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust loop
for i in 0..10 {
    println!("{}", i);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-safety-first"><a class="header" href="#3-safety-first">3. Safety First</a></h3>
<p>Rust‚Äôs loops are designed to be safe. There‚Äôs no risk of off-by-one errors or accessing elements outside of a collection‚Äôs bounds.</p>
<h3 id="4-iterator-based"><a class="header" href="#4-iterator-based">4. Iterator-based</a></h3>
<p>Rust‚Äôs <code>for</code> loops are built on the iterator system, which provides a uniform interface for iterating over different types of collections. This makes them more powerful and flexible.</p>
<h3 id="5-ownership-aware"><a class="header" href="#5-ownership-aware">5. Ownership-aware</a></h3>
<p>Loops respect Rust‚Äôs ownership system. When you iterate over a collection, you can choose to take ownership of elements, borrow them, or use mutable references:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];

// Borrow elements
for item in &amp;v {
    println!("{}", item);
}

// Take ownership (v is moved into the for loop)
for item in v {
    println!("{}", item);
}
// v is no longer accessible here
<span class="boring">}</span></code></pre></pre>
<h2 id="range-expressions"><a class="header" href="#range-expressions">Range Expressions</a></h2>
<p>Ranges in Rust are a concise way to express a sequence of values:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Range expressions
    let range1 = 1..5;    // Includes 1, 2, 3, 4 (exclusive upper bound)
    let range2 = 1..=5;   // Includes 1, 2, 3, 4, 5 (inclusive upper bound)

    // Using ranges in for loops
    for i in 1..5 {
        println!("{}", i);  // Prints 1 2 3 4
    }

    for i in 1..=5 {
        println!("{}", i);  // Prints 1 2 3 4 5
    }

    // Ranges with chars
    for c in 'a'..='e' {
        print!("{} ", c);  // Prints a b c d e
    }
    println!();

    // Using step_by to skip values
    for i in (0..10).step_by(2) {
        print!("{} ", i);  // Prints 0 2 4 6 8
    }
    println!();

    // Ranges can be used for slicing
    let numbers = [1, 2, 3, 4, 5];
    let slice = &amp;numbers[1..4]; // [2, 3, 4]

    // Ranges can be unbounded
    let from_three = 3..;  // From 3 to infinity (conceptually)
    let up_to_five = ..5;  // From negative infinity to 5 (exclusive)
    let everything = ..;   // The entire range

    // Using ranges in pattern matching
    let x = 5;
    match x {
        1..=5 =&gt; println!("x is between 1 and 5"),
        _ =&gt; println!("x is something else"),
    }
}</code></pre></pre>
<p>Ranges are a powerful feature that make iterating over sequences concise and readable.</p>
<h2 id="match-expressions-basics"><a class="header" href="#match-expressions-basics">Match Expressions Basics</a></h2>
<p>The <code>match</code> expression is one of Rust‚Äôs most powerful features. It‚Äôs similar to a <code>switch</code> statement in other languages, but far more powerful.</p>
<h3 id="basic-match-syntax"><a class="header" href="#basic-match-syntax">Basic Match Syntax</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 13;

    match number {
        // Match a single value
        1 =&gt; println!("One!"),

        // Match multiple values
        2 | 3 | 5 | 7 | 11 | 13 =&gt; println!("This is a prime"),

        // Match a range
        6..=10 =&gt; println!("Six through ten"),

        // Default case
        _ =&gt; println!("Another number"),
    }
}</code></pre></pre>
<h3 id="match-as-an-expression"><a class="header" href="#match-as-an-expression">Match as an Expression</a></h3>
<p>Like <code>if</code> and <code>loop</code>, <code>match</code> is also an expression that returns a value:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 13;

    let message = match number {
        1 =&gt; "One!",
        2 | 3 | 5 | 7 | 11 | 13 =&gt; "This is a prime",
        6..=10 =&gt; "Six through ten",
        _ =&gt; "Another number",
    };

    println!("Message: {}", message); // "This is a prime"
}</code></pre></pre>
<h3 id="exhaustiveness-checking"><a class="header" href="#exhaustiveness-checking">Exhaustiveness Checking</a></h3>
<p>Rust‚Äôs <code>match</code> must be exhaustive, meaning every possible value of the matched expression must be covered:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let dice_roll = 9;

    match dice_roll {
        1 =&gt; println!("Critical failure!"),
        2..=5 =&gt; println!("Normal roll"),
        6 =&gt; println!("Critical success!"),
        // Without this catch-all case, the compiler would complain
        // since dice_roll could be any i32 value
        _ =&gt; println!("Invalid dice roll"),
    }
}</code></pre></pre>
<p>This requirement ensures that you‚Äôve considered all possible cases, preventing subtle bugs.</p>
<h2 id="pattern-matching-basics"><a class="header" href="#pattern-matching-basics">Pattern Matching Basics</a></h2>
<p>Pattern matching goes beyond simple values in <code>match</code> expressions. It allows you to destructure complex data types.</p>
<h3 id="matching-with-tuples"><a class="header" href="#matching-with-tuples">Matching with Tuples</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let point = (3, 5);

    match point {
        (0, 0) =&gt; println!("Origin"),
        (0, y) =&gt; println!("X-axis at y={}", y),
        (x, 0) =&gt; println!("Y-axis at x={}", x),
        (x, y) =&gt; println!("Point at ({}, {})", x, y),
    }
}</code></pre></pre>
<h3 id="destructuring-structs"><a class="header" href="#destructuring-structs">Destructuring Structs</a></h3>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x: 0, y } =&gt; println!("On the y-axis at y={}", y),
        Point { x, y: 0 } =&gt; println!("On the x-axis at x={}", x),
        Point { x, y } =&gt; println!("Point at ({}, {})", x, y),
    }
}</code></pre></pre>
<h3 id="ignoring-values-with-_"><a class="header" href="#ignoring-values-with-_">Ignoring Values with _</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("Some numbers: {}, {}, {}", first, third, fifth);
        }
    }
}</code></pre></pre>
<h3 id="match-guards"><a class="header" href="#match-guards">Match Guards</a></h3>
<p>You can add extra conditions to match arms with a <code>if</code> guard:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 4;

    match number {
        n if n &lt; 0 =&gt; println!("Negative number"),
        n if n % 2 == 0 =&gt; println!("Even number"),
        n if n % 2 == 1 =&gt; println!("Odd number"),
        // This _ case would never execute because all cases are covered
        _ =&gt; unreachable!(),
    }
}</code></pre></pre>
<h3 id="binding-with--operator"><a class="header" href="#binding-with--operator">Binding with @ Operator</a></h3>
<p>The <code>@</code> operator lets you bind a value while also testing it:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    match x {
        n @ 1..=5 =&gt; println!("Got a small number: {}", n),
        n @ 6..=10 =&gt; println!("Got a medium number: {}", n),
        n =&gt; println!("Got a big number: {}", n),
    }
}</code></pre></pre>
<h2 id="early-returns-break-and-continue"><a class="header" href="#early-returns-break-and-continue">Early Returns, Break, and Continue</a></h2>
<p>Rust provides several ways to control the flow of execution within loops and functions.</p>
<h3 id="early-returns-in-functions"><a class="header" href="#early-returns-in-functions">Early Returns in Functions</a></h3>
<pre><pre class="playground"><code class="language-rust">fn find_even(numbers: &amp;[i32]) -&gt; Option&lt;i32&gt; {
    for &amp;num in numbers {
        if num % 2 == 0 {
            return Some(num); // Early return when we find an even number
        }
    }

    None // Return None if no even number is found
}

fn main() {
    let numbers = [1, 3, 5, 6, 9, 11];

    match find_even(&amp;numbers) {
        Some(n) =&gt; println!("Found even number: {}", n),
        None =&gt; println!("No even numbers found"),
    }
}</code></pre></pre>
<p>Early returns are a clean way to handle special cases without deeply nested conditionals.</p>
<h3 id="break-and-continue"><a class="header" href="#break-and-continue">Break and Continue</a></h3>
<p>As we‚Äôve seen, <code>break</code> exits a loop, while <code>continue</code> skips to the next iteration:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for i in 0..10 {
        if i % 2 == 0 {
            continue; // Skip even numbers
        }

        if i &gt; 7 {
            break; // Stop once we reach 8
        }

        println!("{}", i); // Prints 1, 3, 5, 7
    }
}</code></pre></pre>
<h2 id="loop-labels"><a class="header" href="#loop-labels">Loop Labels</a></h2>
<p>Rust allows you to label loops and break or continue specific loops in nested scenarios:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    'outer: for x in 0..5 {
        println!("x: {}", x);

        'inner: for y in 0..5 {
            println!("  y: {}", y);

            if y == 2 &amp;&amp; x == 1 {
                break 'outer; // Break out of the outer loop
            }

            if y == 1 {
                continue 'inner; // Skip to the next iteration of the inner loop
            }
        }
    }
}</code></pre></pre>
<p>Loop labels are especially useful when you have nested loops and need to control which loop is affected by <code>break</code> or <code>continue</code>.</p>
<h2 id="using-match-expressions-for-error-handling"><a class="header" href="#using-match-expressions-for-error-handling">Using Match Expressions for Error Handling</a></h2>
<p>One common use of <code>match</code> is to handle possible error conditions with <code>Option</code> and <code>Result</code> types:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = vec![1, 2, 3];

    // Using match with Option
    match numbers.get(5) {
        Some(value) =&gt; println!("Value at index 5: {}", value),
        None =&gt; println!("No value at index 5"),
    }

    // Using match with Result
    let parse_result = "42".parse::&lt;i32&gt;();
    match parse_result {
        Ok(number) =&gt; println!("Parsed number: {}", number),
        Err(error) =&gt; println!("Failed to parse: {}", error),
    }

    // Using if let for simpler matching
    if let Some(value) = numbers.get(1) {
        println!("Value at index 1: {}", value);
    }

    // Using while let for conditional loops
    let mut stack = Vec::new();
    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(value) = stack.pop() {
        println!("Popped: {}", value);
    }
}</code></pre></pre>
<p>This pattern-based approach to error handling is one of Rust‚Äôs distinctive features, allowing for expressive and type-safe code.</p>
<h2 id="-project-number-guessing-game"><a class="header" href="#-project-number-guessing-game">üî® Project: Number Guessing Game</a></h2>
<p>Let‚Äôs create a complete number guessing game to apply what we‚Äôve learned about control flow in Rust.</p>
<h3 id="project-requirements"><a class="header" href="#project-requirements">Project Requirements</a></h3>
<ol>
<li>Generate a random number for the player to guess</li>
<li>Allow the player to input guesses</li>
<li>Provide feedback on whether the guess is too high, too low, or correct</li>
<li>Track the number of guesses and offer hints after several attempts</li>
<li>Allow multiple rounds of play</li>
</ol>
<h3 id="step-1-create-the-project"><a class="header" href="#step-1-create-the-project">Step 1: Create the Project</a></h3>
<pre><code class="language-bash">cargo new guessing_game
cd guessing_game
</code></pre>
<h3 id="step-2-add-dependencies"><a class="header" href="#step-2-add-dependencies">Step 2: Add Dependencies</a></h3>
<p>Edit your <code>Cargo.toml</code> file to add the <code>rand</code> crate:</p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<h3 id="step-3-implement-the-game"><a class="header" href="#step-3-implement-the-game">Step 3: Implement the Game</a></h3>
<p>Now, let‚Äôs write the code in <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use rand::Rng;
use std::cmp::Ordering;
use std::io::{self, Write};

fn main() {
    println!("üéÆ NUMBER GUESSING GAME üéÆ");
    println!("I'm thinking of a number between 1 and 100...");

    let mut play_again = true;
    let mut total_games = 0;
    let mut best_score = usize::MAX;

    while play_again {
        let secret_number = rand::thread_rng().gen_range(1..=100);
        let mut guesses = 0;
        let mut has_hint = false;

        loop {
            // Get user input
            print!("Enter your guess: ");
            io::stdout().flush().unwrap(); // Ensure the prompt is displayed

            let mut guess = String::new();
            io::stdin()
                .read_line(&amp;mut guess)
                .expect("Failed to read line");

            // Parse the guess
            let guess: u32 = match guess.trim().parse() {
                Ok(num) =&gt; num,
                Err(_) =&gt; {
                    println!("Please enter a valid number!");
                    continue;
                }
            };

            guesses += 1;

            // Compare the guess with the secret number
            match guess.cmp(&amp;secret_number) {
                Ordering::Less =&gt; {
                    println!("Too small!");

                    // Provide a hint after 5 guesses
                    if guesses &gt;= 5 &amp;&amp; !has_hint {
                        has_hint = true;
                        let range = if secret_number &lt;= 50 { "1-50" } else { "51-100" };
                        println!("Hint: The number is in the range {}", range);
                    }
                }
                Ordering::Greater =&gt; {
                    println!("Too big!");

                    // Provide a hint after 5 guesses
                    if guesses &gt;= 5 &amp;&amp; !has_hint {
                        has_hint = true;
                        let range = if secret_number &lt;= 50 { "1-50" } else { "51-100" };
                        println!("Hint: The number is in the range {}", range);
                    }
                }
                Ordering::Equal =&gt; {
                    if guesses == 1 {
                        println!("üéâ You got it in 1 guess! Incredible!");
                    } else {
                        println!("üéâ You got it in {} guesses!", guesses);
                    }

                    // Update best score
                    if guesses &lt; best_score {
                        best_score = guesses;
                        println!("That's a new best score!");
                    }

                    break;
                }
            }
        }

        total_games += 1;

        // Ask to play again
        loop {
            print!("Play again? (y/n): ");
            io::stdout().flush().unwrap();

            let mut response = String::new();
            io::stdin().read_line(&amp;mut response).expect("Failed to read line");

            match response.trim().to_lowercase().as_str() {
                "y" | "yes" =&gt; {
                    println!("\nGreat! Let's play again!");
                    println!("I'm thinking of a new number between 1 and 100...");
                    break;
                }
                "n" | "no" =&gt; {
                    play_again = false;
                    break;
                }
                _ =&gt; println!("Please enter y or n."),
            }
        }
    }

    // Game summary
    println!("\nüèÜ GAME SUMMARY üèÜ");
    println!("Games played: {}", total_games);

    if best_score != usize::MAX {
        println!("Best score: {} guesses", best_score);

        let rating = match best_score {
            1 =&gt; "Psychic! üîÆ",
            2..=4 =&gt; "Amazing! üåü",
            5..=7 =&gt; "Good job! üëç",
            8..=10 =&gt; "Not bad! üòä",
            _ =&gt; "Keep practicing! üí™",
        };

        println!("Rating: {}", rating);
    }

    println!("\nThanks for playing!");
}</code></pre></pre>
<h3 id="step-4-run-the-game"><a class="header" href="#step-4-run-the-game">Step 4: Run the Game</a></h3>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="step-5-understanding-the-code"><a class="header" href="#step-5-understanding-the-code">Step 5: Understanding the Code</a></h3>
<p>This game demonstrates several control flow concepts:</p>
<ol>
<li><strong>Loops</strong>: Both <code>while</code> and <code>loop</code> for different purposes</li>
<li><strong>Match expressions</strong>: For comparing guesses and handling user input</li>
<li><strong>Early returns with <code>continue</code></strong>: To skip invalid inputs</li>
<li><strong>If/else conditionals</strong>: For providing hints and feedback</li>
<li><strong>Pattern matching with ranges</strong>: In the final rating system</li>
<li><strong>Break statements</strong>: To exit loops when a guess is correct</li>
<li><strong>Nested loops</strong>: For the main game loop and the play-again prompt</li>
</ol>
<h3 id="step-6-extending-the-game"><a class="header" href="#step-6-extending-the-game">Step 6: Extending the Game</a></h3>
<p>Here are some ways to extend the game:</p>
<ol>
<li>Add difficulty levels with different number ranges</li>
<li>Implement a time limit for each guess</li>
<li>Create a two-player mode</li>
<li>Add a graphical interface with a Rust GUI framework</li>
<li>Save high scores to a file</li>
</ol>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this chapter, we‚Äôve explored Rust‚Äôs control flow constructs, understanding how expressions differ from statements and how they affect Rust‚Äôs programming style. We‚Äôve covered:</p>
<ul>
<li>How Rust‚Äôs expression-based nature distinguishes it from other languages</li>
<li>Working with conditional expressions using <code>if</code> and <code>else</code></li>
<li>The three types of loops: <code>loop</code>, <code>while</code>, and <code>for</code></li>
<li>How Rust‚Äôs loops differ from loops in other languages</li>
<li>Creating and using ranges for sequences of values</li>
<li>Powerful pattern matching with <code>match</code> expressions</li>
<li>Controlling execution flow with <code>break</code>, <code>continue</code>, and early returns</li>
<li>Labeling loops for fine-grained control in nested loops</li>
<li>Using match expressions for effective error handling</li>
<li>Building a complete number guessing game application</li>
</ul>
<p>These control flow mechanisms are the building blocks for more complex Rust programs. The expression-oriented approach you‚Äôve learned forms the foundation for much of Rust‚Äôs syntax. As you continue your Rust journey, you‚Äôll find that thinking in terms of expressions makes your code more concise and often more readable.</p>
<p>In the next chapter, we‚Äôll dive into functions and procedures, exploring how to organize code into reusable units. We‚Äôll learn about parameters, return values, and how functions in Rust build upon the expression-based nature of the language that we‚Äôve explored here.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li>
<p><strong>Expression Practice</strong>: Write a program that uses block expressions to calculate and assign values to variables. Experiment with adding semicolons to see how it changes the behavior.</p>
</li>
<li>
<p><strong>Control Flow Refactoring</strong>: Take a program written in another language that uses imperative control flow and rewrite it using Rust‚Äôs expression-based approach.</p>
</li>
<li>
<p><strong>Pattern Matching Challenge</strong>: Create a program that matches different shapes (circles, rectangles, triangles) and calculates their areas using pattern matching.</p>
</li>
<li>
<p><strong>Loop Label Exercise</strong>: Write a program with nested loops that uses labeled breaks and continues to generate a specific pattern.</p>
</li>
<li>
<p><strong>Error Handling</strong>: Write a function that parses different types of input (numbers, dates, etc.) and uses match expressions to handle all possible error cases.</p>
</li>
<li>
<p><strong>Advanced Guessing Game</strong>: Extend the number guessing game with one or more of the suggested enhancements from Step 6.</p>
</li>
</ol>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html">The Rust Programming Language: Control Flow</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/flow_control.html">Rust By Example: Flow of Control</a></li>
<li><a href="https://doc.rust-lang.org/reference/expressions.html">The Rust Reference: Expressions</a></li>
<li><a href="https://doc.rust-lang.org/book/ch18-00-patterns.html">Pattern Matching in Rust</a></li>
<li><a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">Error Handling in Rust</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapters/04-basic-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapters/06-functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapters/04-basic-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapters/06-functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
