<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Error Handling Patterns and Libraries - Rust Universe: Fearless Systems Engineering</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to learning the Rust programming language from fundamentals to mastery.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Universe: Fearless Systems Engineering</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/saeedalam/rust-universe" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/saeedalam/rust-universe/edit/main/src/chapters/21-error-patterns.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-21-error-handling-patterns-and-libraries"><a class="header" href="#chapter-21-error-handling-patterns-and-libraries">Chapter 21: Error Handling Patterns and Libraries</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>In the previous chapter, we explored the foundations of Rust’s error handling system using <code>Result</code> and <code>Option</code> types. We learned how to propagate errors, transform them, and build robust error handling flows. While these fundamentals are powerful on their own, real-world applications often require more sophisticated error handling patterns and tooling.</p>
<p>This chapter takes our error handling skills to the next level by exploring advanced patterns, ecosystem libraries, and best practices for managing errors in complex applications. We’ll learn how to create rich, domain-specific error types, add context to errors for better diagnostics, handle errors in asynchronous code, and design user-friendly error reporting systems.</p>
<p>By the end of this chapter, you’ll have a comprehensive toolkit for handling errors in even the most demanding Rust applications. You’ll understand when to use different error handling approaches, how to leverage popular error handling libraries, and how to design error systems that scale with your application’s complexity.</p>
<h2 id="creating-custom-error-types"><a class="header" href="#creating-custom-error-types">Creating Custom Error Types</a></h2>
<p>In the previous chapter, we created basic custom error types. Now, let’s explore more advanced patterns for designing error types that scale with your application’s complexity.</p>
<h3 id="domain-specific-error-types"><a class="header" href="#domain-specific-error-types">Domain-Specific Error Types</a></h3>
<p>As your application grows, it’s beneficial to create domain-specific error types that express the precise failure modes of each subsystem:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Authentication domain errors
#[derive(Debug)]
pub enum AuthError {
    InvalidCredentials,
    ExpiredToken { expired_at: DateTime&lt;Utc&gt; },
    InsufficientPermissions { required: Vec&lt;Permission&gt;, actual: Vec&lt;Permission&gt; },
    RateLimited { retry_after: Duration },
    ServiceUnavailable,
}

// Database domain errors
#[derive(Debug)]
pub enum DbError {
    ConnectionFailed { url: String, cause: Box&lt;dyn Error + Send + Sync&gt; },
    QueryFailed { query: String, cause: Box&lt;dyn Error + Send + Sync&gt; },
    TransactionFailed { cause: Box&lt;dyn Error + Send + Sync&gt; },
    RecordNotFound { entity: String, id: String },
    UniqueConstraintViolation { field: String, value: String },
    // Other database-specific errors...
}
<span class="boring">}</span></code></pre></pre>
<p>This approach allows consumers of your API to handle specific error conditions precisely while still having a clear categorization of errors.</p>
<h3 id="composing-error-types"><a class="header" href="#composing-error-types">Composing Error Types</a></h3>
<p>For larger applications, you’ll often want to combine multiple domain-specific error types into a unified application error. There are several patterns for this:</p>
<h4 id="enum-variants-pattern"><a class="header" href="#enum-variants-pattern">Enum Variants Pattern</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub enum AppError {
    Auth(AuthError),
    Database(DbError),
    Api(ApiError),
    Validation(ValidationError),
    // Other subsystem errors...
}

// Implementing From for each error type
impl From&lt;AuthError&gt; for AppError {
    fn from(error: AuthError) -&gt; Self {
        AppError::Auth(error)
    }
}

impl From&lt;DbError&gt; for AppError {
    fn from(error: DbError) -&gt; Self {
        AppError::Database(error)
    }
}

// And so on for other error types...
<span class="boring">}</span></code></pre></pre>
<p>This pattern is explicit but requires updating the enum when adding new error types.</p>
<h4 id="error-box-pattern"><a class="header" href="#error-box-pattern">Error Box Pattern</a></h4>
<p>For more flexibility, especially in library code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AppError {
    source: Box&lt;dyn Error + Send + Sync&gt;,
    context: Option&lt;String&gt;,
    // You can add more metadata like error codes, severity, etc.
}

impl AppError {
    pub fn new&lt;E&gt;(error: E) -&gt; Self
    where
        E: Error + Send + Sync + 'static
    {
        Self {
            source: Box::new(error),
            context: None,
        }
    }

    pub fn with_context&lt;E, S&gt;(error: E, context: S) -&gt; Self
    where
        E: Error + Send + Sync + 'static,
        S: Into&lt;String&gt;
    {
        Self {
            source: Box::new(error),
            context: Some(context.into()),
        }
    }
}

// Then you can wrap any error
let app_error = AppError::new(DbError::ConnectionFailed {
    url: "postgres://...".to_string(),
    cause: Box::new(std::io::Error::new(std::io::ErrorKind::ConnectionRefused, "Connection refused"))
});
<span class="boring">}</span></code></pre></pre>
<p>This pattern is more flexible but loses some type information.</p>
<h3 id="error-type-design-principles"><a class="header" href="#error-type-design-principles">Error Type Design Principles</a></h3>
<p>When designing custom error types, follow these principles:</p>
<ol>
<li><strong>Expressiveness</strong>: Error types should clearly communicate what went wrong.</li>
<li><strong>Context</strong>: Include enough information to diagnose and potentially fix the error.</li>
<li><strong>Privacy</strong>: Be careful not to leak sensitive information in error messages.</li>
<li><strong>Ergonomics</strong>: Make error types easy to create, transform, and handle.</li>
<li><strong>Stability</strong>: Consider the impact on your API when evolving error types.</li>
</ol>
<p>Here’s an example that balances these principles:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub enum PaymentError {
    InsufficientFunds {
        account_id: String,
        available: Money,
        required: Money,
    },
    CardDeclined {
        code: String,
        message: String,
        retry_possible: bool,
    },
    // Redact sensitive data
    InvalidCardDetails {
        // Don't include the actual card details in the error!
        field: String, // e.g., "expiration_date", "cvv"
    },
    PaymentProviderError {
        provider: String,
        status_code: u16,
        // Store full error for logging but don't expose in Display
        #[doc(hidden)]
        raw_error: String,
    },
    // ...
}

// User-facing error messages
impl std::fmt::Display for PaymentError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            Self::InsufficientFunds { available, required, .. } =&gt; {
                write!(f, "Insufficient funds. Available: {}, Required: {}", available, required)
            }
            Self::CardDeclined { message, retry_possible, .. } =&gt; {
                if *retry_possible {
                    write!(f, "Card declined: {}. Please try again.", message)
                } else {
                    write!(f, "Card declined: {}. Please use a different payment method.", message)
                }
            }
            Self::InvalidCardDetails { field } =&gt; {
                write!(f, "Invalid card details: {}", field)
            }
            Self::PaymentProviderError { provider, status_code, .. } =&gt; {
                write!(f, "Payment service error: {} returned status {}", provider, status_code)
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Notice how this design provides detailed information for debugging while presenting appropriate messages to end users.</p>
<h2 id="using-thiserror-and-anyhow-crates"><a class="header" href="#using-thiserror-and-anyhow-crates">Using thiserror and anyhow Crates</a></h2>
<p>While Rust’s standard library provides the basic building blocks for error handling, the ecosystem offers several libraries that make error handling more ergonomic. Two of the most popular are <code>thiserror</code> and <code>anyhow</code>.</p>
<h3 id="the-thiserror-crate"><a class="header" href="#the-thiserror-crate">The thiserror Crate</a></h3>
<p>The <code>thiserror</code> crate simplifies implementing the <code>Error</code> trait and related functionality through derive macros. It’s ideal for libraries or applications with well-defined error types.</p>
<p>To use it, add to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
thiserror = "1.0"
</code></pre>
<h4 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum DataStoreError {
    #[error("data store disconnected")]
    Disconnect(#[from] std::io::Error),

    #[error("the data for key `{0}` is not available")]
    Redaction(String),

    #[error("invalid header (expected {expected:?}, found {found:?})")]
    InvalidHeader {
        expected: String,
        found: String,
    },

    #[error("unknown data store error")]
    Unknown,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>#[error("...")]</code> attribute defines the <code>Display</code> implementation, and the <code>#[from]</code> attribute generates <code>From</code> implementations for automatic error conversion.</p>
<h4 id="advanced-thiserror-features"><a class="header" href="#advanced-thiserror-features">Advanced thiserror Features</a></h4>
<p><code>thiserror</code> supports several advanced features:</p>
<ol>
<li><strong>Source errors</strong>: Use the <code>#[source]</code> attribute to indicate the underlying cause:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Error, Debug)]
pub enum ApiError {
    #[error("request failed")]
    RequestFailed {
        #[source]
        source: reqwest::Error,
        url: String,
    },
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Format specifiers</strong>: Use format specifiers in error messages:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Error, Debug)]
pub enum ValidationError {
    #[error("invalid value for field {field}: {message}")]
    InvalidField {
        field: String,
        message: String,
    },

    #[error("missing required fields: {0:?}")]
    MissingFields(Vec&lt;String&gt;),
}
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li><strong>Transparent errors</strong>: Pass through an inner error’s <code>Display</code> and <code>source</code> implementations:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Error, Debug)]
pub enum DatabaseError {
    #[error(transparent)]
    Sql(#[from] sqlx::Error),

    // Other database errors...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-anyhow-crate"><a class="header" href="#the-anyhow-crate">The anyhow Crate</a></h3>
<p>While <code>thiserror</code> is ideal for library code with well-defined error types, <code>anyhow</code> provides a simpler approach for application code where you care more about context and error messages than the specific error types.</p>
<p>To use it, add to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
anyhow = "1.0"
</code></pre>
<h4 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h4>
<pre><pre class="playground"><code class="language-rust">use anyhow::{Result, Context, anyhow};

fn read_config(path: &amp;str) -&gt; Result&lt;Config&gt; {
    // anyhow::Result&lt;T&gt; is a type alias for Result&lt;T, anyhow::Error&gt;
    let content = std::fs::read_to_string(path)
        .context(format!("Failed to read config file: {}", path))?;

    let config = serde_json::from_str(&amp;content)
        .context("Failed to parse config file as JSON")?;

    Ok(config)
}

fn main() -&gt; Result&lt;()&gt; {
    let config = read_config("config.json")?;

    // Create errors directly with the anyhow! macro
    if !config.is_valid() {
        return Err(anyhow!("Invalid configuration"));
    }

    Ok(())
}</code></pre></pre>
<p>The key feature of <code>anyhow</code> is the ability to add context to errors with the <code>.context()</code> method, which wraps the error and adds a message that explains what was happening when the error occurred.</p>
<h4 id="advanced-anyhow-features"><a class="header" href="#advanced-anyhow-features">Advanced anyhow Features</a></h4>
<ol>
<li><strong>Backtrace capture</strong>: <code>anyhow</code> can capture backtraces for errors:</li>
</ol>
<pre><pre class="playground"><code class="language-rust">use anyhow::Result;

// Enable backtraces with RUST_BACKTRACE=1 or RUST_LIB_BACKTRACE=1
fn main() -&gt; Result&lt;()&gt; {
    // This will include a backtrace when printed
    Err(anyhow::anyhow!("Something went wrong"))
}</code></pre></pre>
<ol start="2">
<li><strong>Downcast errors</strong>: Recover the original error type when needed:</li>
</ol>
<pre><pre class="playground"><code class="language-rust">use anyhow::{Result, anyhow};
use std::io;

fn may_fail() -&gt; Result&lt;()&gt; {
    Err(io::Error::new(io::ErrorKind::NotFound, "File not found").into())
}

fn main() -&gt; Result&lt;()&gt; {
    let err = may_fail().unwrap_err();

    // Downcast to the original error type
    if let Some(io_err) = err.downcast_ref::&lt;io::Error&gt;() {
        if io_err.kind() == io::ErrorKind::NotFound {
            println!("File not found, creating default");
            return Ok(());
        }
    }

    // Re-throw the error if it wasn't handled
    Err(err)
}</code></pre></pre>
<ol start="3">
<li><strong>Custom error reporting</strong>: Format errors for different audiences:</li>
</ol>
<pre><pre class="playground"><code class="language-rust">use anyhow::{Result, Context};

fn process_data() -&gt; Result&lt;()&gt; {
    // Processing logic...
    Err(anyhow::anyhow!("Processing failed"))
        .context("Failed to process user data")
}

fn main() {
    match process_data() {
        Ok(()) =&gt; println!("Success!"),
        Err(e) =&gt; {
            // For end users
            println!("Error: {}", e);

            // For developers (with full chain)
            eprintln!("Error details: {:#}", e);

            // With backtrace if available
            eprintln!("Full error: {:?}", e);
        }
    }
}</code></pre></pre>
<h3 id="combining-thiserror-and-anyhow"><a class="header" href="#combining-thiserror-and-anyhow">Combining thiserror and anyhow</a></h3>
<p>A common pattern is to use <code>thiserror</code> for your library’s public error types and <code>anyhow</code> for internal error handling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In your library code
use thiserror::Error;

#[derive(Error, Debug)]
pub enum LibraryError {
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Configuration error: {0}")]
    Config(String),

    // Other error variants...
}

// In your application code
use anyhow::Result;

fn use_library() -&gt; Result&lt;()&gt; {
    // Use anyhow within your application
    my_library::do_something()
        .context("Failed while using my_library")?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>This approach gives you the best of both worlds: well-defined error types for your public API and flexible error handling with rich context for your application code.</p>
<h2 id="context-for-errors"><a class="header" href="#context-for-errors">Context for Errors</a></h2>
<p>Adding context to errors is essential for creating meaningful, actionable error messages. Let’s explore strategies for enriching errors with context.</p>
<h3 id="why-context-matters"><a class="header" href="#why-context-matters">Why Context Matters</a></h3>
<p>Error context helps answer questions like:</p>
<ol>
<li>What operation was being attempted when the error occurred?</li>
<li>What inputs or resources were involved?</li>
<li>Where in the code did the error originate?</li>
<li>What might the user do to fix the problem?</li>
</ol>
<h3 id="adding-context-with-anyhow"><a class="header" href="#adding-context-with-anyhow">Adding Context with anyhow</a></h3>
<p>The <code>anyhow</code> crate provides a simple way to add context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyhow::{Context, Result};
use std::fs;
use std::path::Path;

fn read_config(path: &amp;Path) -&gt; Result&lt;Config&gt; {
    let content = fs::read_to_string(path)
        .with_context(|| format!("Failed to read config file at {}", path.display()))?;

    let config = serde_json::from_str(&amp;content)
        .with_context(|| format!("Failed to parse config file at {}", path.display()))?;

    Ok(config)
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>.with_context()</code> method accepts a closure that only gets evaluated if an error occurs, which is more efficient than constructing the context string every time.</p>
<h3 id="custom-context-with-thiserror"><a class="header" href="#custom-context-with-thiserror">Custom Context with thiserror</a></h3>
<p>With <code>thiserror</code>, you can build context into your error types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;
use std::path::PathBuf;

#[derive(Error, Debug)]
pub enum ConfigError {
    #[error("Failed to read config file at {path}")]
    ReadError {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },

    #[error("Failed to parse config file at {path}")]
    ParseError {
        path: PathBuf,
        #[source]
        source: serde_json::Error,
    },
}

fn read_config(path: &amp;Path) -&gt; Result&lt;Config, ConfigError&gt; {
    let content = std::fs::read_to_string(path)
        .map_err(|e| ConfigError::ReadError {
            path: path.to_path_buf(),
            source: e
        })?;

    let config = serde_json::from_str(&amp;content)
        .map_err(|e| ConfigError::ParseError {
            path: path.to_path_buf(),
            source: e
        })?;

    Ok(config)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="context-chains"><a class="header" href="#context-chains">Context Chains</a></h3>
<p>For deeper context chains, combine multiple layers of context:</p>
<pre><pre class="playground"><code class="language-rust">use anyhow::{Context, Result};

fn main() -&gt; Result&lt;()&gt; {
    process_data()
        .context("Failed to process user data")?;
    Ok(())
}

fn process_data() -&gt; Result&lt;()&gt; {
    read_user_file()
        .context("Error while reading user data")?;
    Ok(())
}

fn read_user_file() -&gt; Result&lt;String&gt; {
    std::fs::read_to_string("users.json")
        .context("Could not read users.json file")
}</code></pre></pre>
<p>When an error occurs, the resulting error message would include the full context chain:</p>
<pre><code>Failed to process user data: Error while reading user data: Could not read users.json file: No such file or directory (os error 2)
</code></pre>
<h3 id="contextual-error-builder-pattern"><a class="header" href="#contextual-error-builder-pattern">Contextual Error Builder Pattern</a></h3>
<p>For more complex cases, a builder pattern can help construct rich error contexts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;
use std::fmt;

pub struct ErrorContext {
    message: String,
    source: Option&lt;Box&lt;dyn Error + Send + Sync&gt;&gt;,
    user_id: Option&lt;String&gt;,
    request_id: Option&lt;String&gt;,
    operation: Option&lt;String&gt;,
    severity: Severity,
}

#[derive(Debug, Clone, Copy)]
pub enum Severity {
    Info,
    Warning,
    Error,
    Critical,
}

impl ErrorContext {
    pub fn new&lt;S: Into&lt;String&gt;&gt;(message: S) -&gt; Self {
        Self {
            message: message.into(),
            source: None,
            user_id: None,
            request_id: None,
            operation: None,
            severity: Severity::Error,
        }
    }

    pub fn with_source&lt;E: Error + Send + Sync + 'static&gt;(mut self, source: E) -&gt; Self {
        self.source = Some(Box::new(source));
        self
    }

    pub fn with_user_id&lt;S: Into&lt;String&gt;&gt;(mut self, user_id: S) -&gt; Self {
        self.user_id = Some(user_id.into());
        self
    }

    pub fn with_request_id&lt;S: Into&lt;String&gt;&gt;(mut self, request_id: S) -&gt; Self {
        self.request_id = Some(request_id.into());
        self
    }

    pub fn with_operation&lt;S: Into&lt;String&gt;&gt;(mut self, operation: S) -&gt; Self {
        self.operation = Some(operation.into());
        self
    }

    pub fn with_severity(mut self, severity: Severity) -&gt; Self {
        self.severity = severity;
        self
    }
}

impl fmt::Display for ErrorContext {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "{}", self.message)?;

        if let Some(op) = &amp;self.operation {
            write!(f, " [operation: {}]", op)?;
        }

        if let Some(req_id) = &amp;self.request_id {
            write!(f, " [request-id: {}]", req_id)?;
        }

        Ok(())
    }
}

impl fmt::Debug for ErrorContext {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        let mut debug = f.debug_struct("ErrorContext");

        debug.field("message", &amp;self.message);
        debug.field("severity", &amp;self.severity);

        if let Some(source) = &amp;self.source {
            debug.field("source", source);
        }

        if let Some(user_id) = &amp;self.user_id {
            debug.field("user_id", user_id);
        }

        if let Some(request_id) = &amp;self.request_id {
            debug.field("request_id", request_id);
        }

        if let Some(operation) = &amp;self.operation {
            debug.field("operation", operation);
        }

        debug.finish()
    }
}

impl Error for ErrorContext {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        self.source.as_ref().map(|s| s.as_ref() as &amp;(dyn Error + 'static))
    }
}

// Usage
fn process_request(request_id: &amp;str, user_id: &amp;str) -&gt; Result&lt;(), ErrorContext&gt; {
    let result = std::fs::read_to_string("config.json");

    if let Err(e) = result {
        return Err(ErrorContext::new("Failed to process request")
            .with_source(e)
            .with_request_id(request_id)
            .with_user_id(user_id)
            .with_operation("read_config")
            .with_severity(Severity::Error));
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>This pattern allows you to build rich, structured error contexts that can be used for both user-facing messages and detailed logging.</p>
<h2 id="error-hierarchies"><a class="header" href="#error-hierarchies">Error Hierarchies</a></h2>
<p>As applications grow in complexity, error types often naturally form hierarchies. Managing these hierarchies effectively can significantly improve your error handling.</p>
<h3 id="nested-error-types"><a class="header" href="#nested-error-types">Nested Error Types</a></h3>
<p>One approach is to organize errors into nested types that reflect your application’s structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Top-level application error
#[derive(Debug, Error)]
pub enum AppError {
    #[error("API error: {0}")]
    Api(#[from] ApiError),

    #[error("Database error: {0}")]
    Database(#[from] DbError),

    #[error("Authentication error: {0}")]
    Auth(#[from] AuthError),

    #[error("Unexpected error: {0}")]
    Other(String),
}

// API subsystem errors
#[derive(Debug, Error)]
pub enum ApiError {
    #[error("Rate limit exceeded, retry after {retry_after} seconds")]
    RateLimited { retry_after: u64 },

    #[error("Resource not found: {resource}")]
    NotFound { resource: String },

    #[error("Invalid request: {0}")]
    InvalidRequest(#[from] ValidationError),

    #[error("Network error: {0}")]
    Network(#[from] NetworkError),
}

// Validation errors
#[derive(Debug, Error)]
pub enum ValidationError {
    #[error("Missing required field: {0}")]
    MissingField(String),

    #[error("Invalid value for {field}: {message}")]
    InvalidValue { field: String, message: String },

    #[error("Conflicting values between {field1} and {field2}")]
    ConflictingValues { field1: String, field2: String },
}

// And so on for other error types...
<span class="boring">}</span></code></pre></pre>
<p>With this structure, errors naturally flow up the hierarchy while preserving their specific details.</p>
<h3 id="error-categories-and-error-codes"><a class="header" href="#error-categories-and-error-codes">Error Categories and Error Codes</a></h3>
<p>Another approach is to categorize errors and assign error codes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ErrorCategory {
    Validation,
    Authentication,
    Authorization,
    NotFound,
    Conflict,
    RateLimit,
    Internal,
    Dependency,
}

#[derive(Debug, Error)]
pub struct AppError {
    #[source]
    source: Option&lt;Box&lt;dyn Error + Send + Sync&gt;&gt;,
    message: String,
    category: ErrorCategory,
    code: String,
    user_fixable: bool,
}

impl AppError {
    pub fn new&lt;S: Into&lt;String&gt;&gt;(
        message: S,
        category: ErrorCategory,
        code: &amp;str,
        user_fixable: bool,
    ) -&gt; Self {
        Self {
            source: None,
            message: message.into(),
            category,
            code: code.to_string(),
            user_fixable,
        }
    }

    pub fn with_source&lt;E: Error + Send + Sync + 'static&gt;(mut self, source: E) -&gt; Self {
        self.source = Some(Box::new(source));
        self
    }

    pub fn category(&amp;self) -&gt; ErrorCategory {
        self.category
    }

    pub fn code(&amp;self) -&gt; &amp;str {
        &amp;self.code
    }

    pub fn is_user_fixable(&amp;self) -&gt; bool {
        self.user_fixable
    }
}

impl Display for AppError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "[{}] {}", self.code, self.message)
    }
}

// Helper functions to create specific errors
impl AppError {
    pub fn validation&lt;S: Into&lt;String&gt;&gt;(message: S, code: &amp;str) -&gt; Self {
        Self::new(message, ErrorCategory::Validation, code, true)
    }

    pub fn authentication&lt;S: Into&lt;String&gt;&gt;(message: S, code: &amp;str) -&gt; Self {
        Self::new(message, ErrorCategory::Authentication, code, true)
    }

    pub fn not_found&lt;S: Into&lt;String&gt;&gt;(message: S, code: &amp;str) -&gt; Self {
        Self::new(message, ErrorCategory::NotFound, code, false)
    }

    // More helper methods...
}

// Usage
fn validate_user(user: &amp;User) -&gt; Result&lt;(), AppError&gt; {
    if user.name.is_empty() {
        return Err(AppError::validation(
            "User name cannot be empty",
            "VAL001",
        ));
    }

    if user.email.is_empty() {
        return Err(AppError::validation(
            "User email cannot be empty",
            "VAL002",
        ));
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>This approach allows for consistent error reporting and makes it easier to document error codes for API consumers.</p>
<h3 id="error-type-conversion-in-hierarchies"><a class="header" href="#error-type-conversion-in-hierarchies">Error Type Conversion in Hierarchies</a></h3>
<p>As errors travel up through your application layers, you often need to convert between error types. Here are some patterns for handling this:</p>
<h4 id="using-the-from-trait"><a class="header" href="#using-the-from-trait">Using the From Trait</a></h4>
<p>The most common approach is to implement <code>From</code> for conversions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;reqwest::Error&gt; for ApiError {
    fn from(error: reqwest::Error) -&gt; Self {
        if error.is_timeout() {
            ApiError::Network(NetworkError::Timeout {
                duration: std::time::Duration::from_secs(30),
            })
        } else if error.is_connect() {
            ApiError::Network(NetworkError::ConnectionFailed {
                url: error.url().map(|u| u.to_string()),
            })
        } else {
            ApiError::Network(NetworkError::Other(error.to_string()))
        }
    }
}

impl From&lt;ApiError&gt; for AppError {
    fn from(error: ApiError) -&gt; Self {
        AppError::Api(error)
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="using-error-mapping-functions"><a class="header" href="#using-error-mapping-functions">Using Error Mapping Functions</a></h4>
<p>For more control over error conversion, define mapping functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn map_io_error(error: std::io::Error, path: &amp;Path) -&gt; ConfigError {
    match error.kind() {
        std::io::ErrorKind::NotFound =&gt; ConfigError::FileNotFound {
            path: path.to_path_buf(),
        },
        std::io::ErrorKind::PermissionDenied =&gt; ConfigError::AccessDenied {
            path: path.to_path_buf(),
        },
        _ =&gt; ConfigError::IoError {
            path: path.to_path_buf(),
            source: error,
        },
    }
}

fn read_config(path: &amp;Path) -&gt; Result&lt;Config, ConfigError&gt; {
    let content = std::fs::read_to_string(path)
        .map_err(|e| map_io_error(e, path))?;

    // Continue processing...
    Ok(Config::default())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="interface-based-error-hierarchies"><a class="header" href="#interface-based-error-hierarchies">Interface-Based Error Hierarchies</a></h3>
<p>For more flexible error hierarchies, especially in large applications, you can use traits to define error interfaces:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait AppErrorTrait: Error + Send + Sync + 'static {
    fn error_code(&amp;self) -&gt; &amp;str;
    fn http_status(&amp;self) -&gt; u16;
    fn is_retriable(&amp;self) -&gt; bool;
    // Other error properties...
}

// Implement for specific error types
impl AppErrorTrait for ValidationError {
    fn error_code(&amp;self) -&gt; &amp;str {
        match self {
            Self::MissingField(_) =&gt; "VAL001",
            Self::InvalidValue { .. } =&gt; "VAL002",
            Self::ConflictingValues { .. } =&gt; "VAL003",
        }
    }

    fn http_status(&amp;self) -&gt; u16 {
        400 // Bad Request
    }

    fn is_retriable(&amp;self) -&gt; bool {
        false // Validation errors can't be resolved by retrying
    }
}

// Use trait objects for flexibility
type BoxedAppError = Box&lt;dyn AppErrorTrait&gt;;

fn process_request() -&gt; Result&lt;(), BoxedAppError&gt; {
    // Processing...
    Err(Box::new(ValidationError::MissingField("name".to_string())))
}

// Handle errors based on their traits
fn handle_error(error: &amp;dyn AppErrorTrait) {
    println!("Error code: {}", error.error_code());
    println!("HTTP status: {}", error.http_status());
    println!("Can retry: {}", error.is_retriable());
}
<span class="boring">}</span></code></pre></pre>
<p>This approach provides a uniform interface for errors while allowing for a diverse set of concrete error types.</p>
<h2 id="fallible-iterators"><a class="header" href="#fallible-iterators">Fallible Iterators</a></h2>
<p>When working with collections, it’s common to encounter operations that might fail for some elements. Rust provides several patterns for handling fallible operations on iterators.</p>
<h3 id="collecting-results"><a class="header" href="#collecting-results">Collecting Results</a></h3>
<p>The simplest approach is to collect results into a <code>Vec&lt;Result&lt;T, E&gt;&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_items&lt;T&gt;(items: &amp;[T]) -&gt; Vec&lt;Result&lt;ProcessedItem, ProcessError&gt;&gt;
where
    T: Process,
{
    items.iter().map(|item| item.process()).collect()
}
<span class="boring">}</span></code></pre></pre>
<p>This preserves all results, both successes and failures.</p>
<h3 id="filtering-successful-results"><a class="header" href="#filtering-successful-results">Filtering Successful Results</a></h3>
<p>If you only care about successful results, you can filter out errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_successful_items&lt;T&gt;(items: &amp;[T]) -&gt; Vec&lt;ProcessedItem&gt;
where
    T: Process,
{
    items
        .iter()
        .filter_map(|item| item.process().ok())
        .collect()
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>filter_map</code> method combines mapping and filtering, keeping only the <code>Some</code> values.</p>
<h3 id="early-return-on-first-error"><a class="header" href="#early-return-on-first-error">Early Return on First Error</a></h3>
<p>If you want to fail if any item fails, you can use <code>collect</code> with <code>Result</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_all_items&lt;T&gt;(items: &amp;[T]) -&gt; Result&lt;Vec&lt;ProcessedItem&gt;, ProcessError&gt;
where
    T: Process,
{
    items.iter().map(|item| item.process()).collect()
}
<span class="boring">}</span></code></pre></pre>
<p>This works because <code>Result</code> implements <code>FromIterator&lt;Result&lt;T, E&gt;&gt;</code> in a way that returns <code>Ok(Vec&lt;T&gt;)</code> if all items are <code>Ok</code>, or the first <code>Err</code> encountered.</p>
<h3 id="partition-results"><a class="header" href="#partition-results">Partition Results</a></h3>
<p>If you need to separate successes and failures, use <code>partition</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn partition_results&lt;T&gt;(items: &amp;[T]) -&gt; (Vec&lt;ProcessedItem&gt;, Vec&lt;ProcessError&gt;)
where
    T: Process,
{
    let results: Vec&lt;Result&lt;ProcessedItem, ProcessError&gt;&gt; =
        items.iter().map(|item| item.process()).collect();

    let (successes, failures): (Vec&lt;_&gt;, Vec&lt;_&gt;) = results.into_iter().partition(Result::is_ok);

    let successes = successes.into_iter().map(Result::unwrap).collect();
    let failures = failures.into_iter().map(Result::unwrap_err).collect();

    (successes, failures)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-specialized-crates"><a class="header" href="#using-specialized-crates">Using Specialized Crates</a></h3>
<p>Several crates provide more powerful fallible iterator tools:</p>
<h4 id="the-fallible-iterator-crate"><a class="header" href="#the-fallible-iterator-crate">The <code>fallible-iterator</code> Crate</a></h4>
<p>The <code>fallible-iterator</code> crate provides a trait for iterators where the iteration itself might fail:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fallible_iterator::{FallibleIterator, convert};

fn process_items&lt;T&gt;(items: &amp;[T]) -&gt; Result&lt;Vec&lt;ProcessedItem&gt;, ProcessError&gt;
where
    T: Process,
{
    // Convert regular iterator to fallible iterator
    let iter = convert(items.iter().map(|item| item.process()));

    // Collect all results, returning an error if any operation fails
    iter.collect()
}
<span class="boring">}</span></code></pre></pre>
<h4 id="the-itertools-crate"><a class="header" href="#the-itertools-crate">The <code>itertools</code> Crate</a></h4>
<p>The <code>itertools</code> crate provides additional utilities for working with iterators:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use itertools::Itertools;

fn summarize_results&lt;T&gt;(items: &amp;[T]) -&gt; Result&lt;Summary, ProcessError&gt;
where
    T: Process,
{
    // Process all items
    let results: Result&lt;Vec&lt;_&gt;, _&gt; = items
        .iter()
        .map(|item| item.process())
        .collect();

    // If successful, create a summary
    results.map(|processed| {
        let total = processed.len();
        let valid = processed.iter().filter(|p| p.is_valid()).count();

        Summary {
            total,
            valid,
            invalid: total - valid,
        }
    })
}
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-fallible-iterator-implementation"><a class="header" href="#custom-fallible-iterator-implementation">Custom Fallible Iterator Implementation</a></h3>
<p>For more complex cases, you might want to implement your own fallible iterator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FallibleProcess&lt;I, T, E&gt;
where
    I: Iterator&lt;Item = T&gt;,
{
    inner: I,
    max_errors: usize,
    errors: Vec&lt;E&gt;,
}

impl&lt;I, T, E&gt; FallibleProcess&lt;I, T, E&gt;
where
    I: Iterator&lt;Item = T&gt;,
{
    pub fn new(iter: I, max_errors: usize) -&gt; Self {
        Self {
            inner: iter,
            max_errors,
            errors: Vec::new(),
        }
    }

    pub fn process&lt;F, R&gt;(mut self, f: F) -&gt; Result&lt;Vec&lt;R&gt;, Vec&lt;E&gt;&gt;
    where
        F: Fn(T) -&gt; Result&lt;R, E&gt;,
    {
        let mut results = Vec::new();

        for item in self.inner {
            match f(item) {
                Ok(result) =&gt; results.push(result),
                Err(error) =&gt; {
                    self.errors.push(error);
                    if self.errors.len() &gt;= self.max_errors {
                        return Err(self.errors);
                    }
                }
            }
        }

        if self.errors.is_empty() {
            Ok(results)
        } else {
            Err(self.errors)
        }
    }
}

// Usage
fn process_with_tolerance&lt;T&gt;(items: &amp;[T], max_errors: usize) -&gt; Result&lt;Vec&lt;ProcessedItem&gt;, Vec&lt;ProcessError&gt;&gt;
where
    T: Process,
{
    FallibleProcess::new(items.iter(), max_errors)
        .process(|item| item.process())
}
<span class="boring">}</span></code></pre></pre>
<p>This custom implementation allows for a configurable error tolerance, collecting results until a maximum number of errors is reached.</p>
<h2 id="collecting-multiple-errors"><a class="header" href="#collecting-multiple-errors">Collecting Multiple Errors</a></h2>
<p>In many cases, especially with validation, you want to collect multiple errors rather than stopping at the first one. Let’s explore patterns for collecting and reporting multiple errors.</p>
<h3 id="using-vec-for-multiple-errors"><a class="header" href="#using-vec-for-multiple-errors">Using Vec<Error> for Multiple Errors</a></h3>
<p>The simplest approach is to return a vector of errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_user(user: &amp;User) -&gt; Result&lt;(), Vec&lt;ValidationError&gt;&gt; {
    let mut errors = Vec::new();

    if user.name.is_empty() {
        errors.push(ValidationError::MissingField("name".to_string()));
    }

    if user.email.is_empty() {
        errors.push(ValidationError::MissingField("email".to_string()));
    } else if !is_valid_email(&amp;user.email) {
        errors.push(ValidationError::InvalidValue {
            field: "email".to_string(),
            message: "Invalid email format".to_string(),
        });
    }

    if user.age &lt; 18 {
        errors.push(ValidationError::InvalidValue {
            field: "age".to_string(),
            message: "Must be at least 18 years old".to_string(),
        });
    }

    if errors.is_empty() {
        Ok(())
    } else {
        Err(errors)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-dedicated-error-collection-types"><a class="header" href="#using-dedicated-error-collection-types">Using Dedicated Error Collection Types</a></h3>
<p>For more structured error collection, create a dedicated error collection type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Default)]
pub struct ValidationErrors {
    errors: HashMap&lt;String, Vec&lt;String&gt;&gt;,
}

impl ValidationErrors {
    pub fn new() -&gt; Self {
        Self {
            errors: HashMap::new(),
        }
    }

    pub fn add&lt;F, M&gt;(&amp;mut self, field: F, message: M)
    where
        F: Into&lt;String&gt;,
        M: Into&lt;String&gt;,
    {
        self.errors
            .entry(field.into())
            .or_insert_with(Vec::new)
            .push(message.into());
    }

    pub fn is_empty(&amp;self) -&gt; bool {
        self.errors.is_empty()
    }

    pub fn has_errors_for(&amp;self, field: &amp;str) -&gt; bool {
        self.errors.get(field).map_or(false, |e| !e.is_empty())
    }

    pub fn errors_for(&amp;self, field: &amp;str) -&gt; Option&lt;&amp;[String]&gt; {
        self.errors.get(field).map(|e| e.as_slice())
    }
}

impl Error for ValidationErrors {}

impl fmt::Display for ValidationErrors {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        writeln!(f, "Validation errors:")?;

        for (field, errors) in &amp;self.errors {
            for error in errors {
                writeln!(f, "  {}: {}", field, error)?;
            }
        }

        Ok(())
    }
}

// Usage
fn validate_user(user: &amp;User) -&gt; Result&lt;(), ValidationErrors&gt; {
    let mut errors = ValidationErrors::new();

    if user.name.is_empty() {
        errors.add("name", "Name cannot be empty");
    }

    if user.email.is_empty() {
        errors.add("email", "Email cannot be empty");
    } else if !is_valid_email(&amp;user.email) {
        errors.add("email", "Invalid email format");
    }

    if errors.is_empty() {
        Ok(())
    } else {
        Err(errors)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-the-validator-crate"><a class="header" href="#using-the-validator-crate">Using the <code>validator</code> Crate</a></h3>
<p>The <code>validator</code> crate provides a robust framework for validating structs and collecting errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use validator::{Validate, ValidationError};

#[derive(Validate)]
struct User {
    #[validate(length(min = 1, message = "Name cannot be empty"))]
    name: String,

    #[validate(email(message = "Invalid email format"))]
    email: String,

    #[validate(range(min = 18, message = "Must be at least 18 years old"))]
    age: u8,
}

fn validate_user(user: &amp;User) -&gt; Result&lt;(), validator::ValidationErrors&gt; {
    user.validate()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-aggregation-patterns"><a class="header" href="#error-aggregation-patterns">Error Aggregation Patterns</a></h3>
<p>For more complex validation scenarios, you might want to aggregate errors from multiple sources:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Default)]
pub struct AggregateError {
    errors: Vec&lt;Box&lt;dyn Error + Send + Sync&gt;&gt;,
}

impl AggregateError {
    pub fn new() -&gt; Self {
        Self { errors: Vec::new() }
    }

    pub fn add&lt;E&gt;(&amp;mut self, error: E)
    where
        E: Error + Send + Sync + 'static,
    {
        self.errors.push(Box::new(error));
    }

    pub fn extend&lt;E&gt;(&amp;mut self, errors: Vec&lt;E&gt;)
    where
        E: Error + Send + Sync + 'static,
    {
        self.errors.extend(errors.into_iter().map(Box::new));
    }

    pub fn is_empty(&amp;self) -&gt; bool {
        self.errors.is_empty()
    }

    pub fn error_count(&amp;self) -&gt; usize {
        self.errors.len()
    }
}

impl Error for AggregateError {}

impl fmt::Display for AggregateError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        writeln!(f, "{} error(s) occurred:", self.errors.len())?;

        for (i, error) in self.errors.iter().enumerate() {
            writeln!(f, "Error {}: {}", i + 1, error)?;
        }

        Ok(())
    }
}

// Usage
fn validate_complex_data(data: &amp;ComplexData) -&gt; Result&lt;(), AggregateError&gt; {
    let mut aggregate = AggregateError::new();

    // Validate user information
    if let Err(errors) = validate_user(&amp;data.user) {
        aggregate.add(errors);
    }

    // Validate payment information
    if let Err(errors) = validate_payment(&amp;data.payment) {
        aggregate.add(errors);
    }

    // Validate all items in an order
    for (i, item) in data.items.iter().enumerate() {
        if let Err(errors) = validate_item(item) {
            let mut prefixed_errors = ValidationErrors::new();

            for (field, messages) in errors.errors {
                for message in messages {
                    prefixed_errors.add(format!("items[{}].{}", i, field), message);
                }
            }

            aggregate.add(prefixed_errors);
        }
    }

    if aggregate.is_empty() {
        Ok(())
    } else {
        Err(aggregate)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This pattern allows you to collect errors from different validation steps and present them in a unified way.</p>
<h2 id="error-logging-and-reporting"><a class="header" href="#error-logging-and-reporting">Error Logging and Reporting</a></h2>
<p>Effective error handling isn’t just about managing errors in your code—it’s also about communicating those errors to users, operators, and developers. Let’s explore patterns for logging and reporting errors in different contexts.</p>
<h3 id="structured-error-logging"><a class="header" href="#structured-error-logging">Structured Error Logging</a></h3>
<p>For effective troubleshooting, errors should be logged with structured data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use log::{error, warn, info};
use serde_json::json;
use uuid::Uuid;

fn log_error(err: &amp;dyn Error, request_id: &amp;str) {
    // Create structured log entry
    let log_data = json!({
        "request_id": request_id,
        "error_type": std::any::type_name_of_val(err),
        "message": err.to_string(),
        "timestamp": chrono::Utc::now().to_rfc3339(),
        "source_chain": build_error_chain(err),
    });

    error!("{}", serde_json::to_string(&amp;log_data).unwrap());
}

fn build_error_chain(err: &amp;dyn Error) -&gt; Vec&lt;String&gt; {
    let mut chain = vec![err.to_string()];
    let mut source = err.source();

    while let Some(err) = source {
        chain.push(err.to_string());
        source = err.source();
    }

    chain
}
<span class="boring">}</span></code></pre></pre>
<p>When combined with a structured logging system like <code>slog</code> or <code>tracing</code>, this approach provides rich error information that can be analyzed and searched.</p>
<h3 id="different-levels-of-error-detail"><a class="header" href="#different-levels-of-error-detail">Different Levels of Error Detail</a></h3>
<p>Different audiences need different levels of error detail:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ErrorAudience {
    EndUser,
    Administrator,
    Developer,
}

fn format_error_for_audience(err: &amp;AppError, audience: ErrorAudience) -&gt; String {
    match audience {
        // End users get simplified, actionable messages
        ErrorAudience::EndUser =&gt; match err {
            AppError::Auth(_) =&gt; "Authentication failed. Please check your credentials and try again.".into(),
            AppError::Database(_) =&gt; "A system error occurred. Please try again later.".into(),
            AppError::Validation(v) =&gt; format!("Invalid input: {}", v),
            _ =&gt; "An unexpected error occurred. Please try again later.".into(),
        },

        // Administrators get more operational details
        ErrorAudience::Administrator =&gt; {
            let mut message = format!("[{}] {}", err.error_code(), err);

            if let Some(retry_after) = err.retry_after() {
                message.push_str(&amp;format!(" (retry after {} seconds)", retry_after.as_secs()));
            }

            message
        },

        // Developers get full technical details
        ErrorAudience::Developer =&gt; {
            let mut message = format!("{:#?}", err);

            if let Some(source) = err.source() {
                message.push_str("\n\nCaused by:\n");
                message.push_str(&amp;format_error_chain(source));
            }

            message
        },
    }
}

fn format_error_chain(err: &amp;dyn Error) -&gt; String {
    let mut message = format!("- {}", err);
    let mut source = err.source();
    let mut indent = 2;

    while let Some(err) = source {
        message.push_str(&amp;format!("\n{:indent$}- {}", "", err, indent = indent));
        source = err.source();
        indent += 2;
    }

    message
}
<span class="boring">}</span></code></pre></pre>
<h3 id="contextual-error-information"><a class="header" href="#contextual-error-information">Contextual Error Information</a></h3>
<p>Errors are more useful when they include context about what was happening when they occurred:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RequestContext {
    request_id: String,
    user_id: Option&lt;String&gt;,
    ip_address: String,
    start_time: std::time::Instant,
    trace_id: String,
}

fn handle_request(req: Request, ctx: &amp;RequestContext) -&gt; Result&lt;Response, AppError&gt; {
    // Process request...
    let result = process_user_data(&amp;req.user_id).map_err(|e| {
        // Log detailed error with context
        log_error_with_context(&amp;e, ctx);

        // Return appropriate error to caller
        AppError::from(e)
    })?;

    Ok(Response::ok(result))
}

fn log_error_with_context(err: &amp;dyn Error, ctx: &amp;RequestContext) {
    let elapsed = ctx.start_time.elapsed();

    let log_entry = json!({
        "error": err.to_string(),
        "error_type": std::any::type_name_of_val(err),
        "request_id": ctx.request_id,
        "trace_id": ctx.trace_id,
        "user_id": ctx.user_id,
        "ip_address": ctx.ip_address,
        "elapsed_ms": elapsed.as_millis(),
        "timestamp": chrono::Utc::now().to_rfc3339(),
    });

    error!("{}", serde_json::to_string(&amp;log_entry).unwrap());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="distributed-tracing"><a class="header" href="#distributed-tracing">Distributed Tracing</a></h3>
<p>For microservice architectures, distributed tracing is essential for tracking errors across service boundaries:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use opentelemetry::{global, trace::{Span, Tracer}};
use opentelemetry_jaeger::new_pipeline;

fn init_tracer() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let exporter = new_pipeline()
        .with_service_name("my-service")
        .install_simple()?;

    global::set_tracer_provider(exporter);
    Ok(())
}

fn process_with_tracing() -&gt; Result&lt;(), AppError&gt; {
    let tracer = global::tracer("my-service");
    let mut span = tracer.start("process_data");

    // Record information in the span
    span.set_attribute(opentelemetry::Key::new("user.id").string("user-123"));

    match process_data() {
        Ok(result) =&gt; {
            span.set_attribute(opentelemetry::Key::new("result.size").i64(result.len() as i64));
            span.end();
            Ok(())
        }
        Err(e) =&gt; {
            // Record error in the span
            span.record_error(&amp;e);
            span.set_status(opentelemetry::trace::Status::error(e.to_string()));
            span.end();
            Err(e)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-reporting-services"><a class="header" href="#error-reporting-services">Error Reporting Services</a></h3>
<p>For production applications, integrating with error reporting services like Sentry can provide valuable insights:</p>
<pre><pre class="playground"><code class="language-rust">use sentry::{capture_error, configure_scope};

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let _guard = sentry::init(("https://your-sentry-dsn", sentry::ClientOptions {
        release: sentry::release_name!(),
        ..Default::default()
    }));

    if let Err(e) = run() {
        // Capture error in Sentry
        with_error_context(&amp;e, |e| {
            capture_error(e);
        });

        // Also log locally
        eprintln!("Error: {}", e);
        return Err(e.into());
    }

    Ok(())
}

fn with_error_context&lt;E: Error, F&gt;(error: &amp;E, f: F)
where
    F: FnOnce(&amp;E),
{
    configure_scope(|scope| {
        // Add contextual information
        scope.set_tag("environment", std::env::var("ENVIRONMENT").unwrap_or_else(|_| "development".into()));
        scope.set_user(Some(sentry::User {
            id: Some(get_current_user_id().unwrap_or_else(|| "anonymous".into())),
            ..Default::default()
        }));
    });

    f(error);
}</code></pre></pre>
<h3 id="error-metrics-and-monitoring"><a class="header" href="#error-metrics-and-monitoring">Error Metrics and Monitoring</a></h3>
<p>Track error rates and patterns with metrics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prometheus::{register_int_counter_vec, IntCounterVec};
use lazy_static::lazy_static;

lazy_static! {
    static ref ERROR_COUNTER: IntCounterVec = register_int_counter_vec!(
        "app_errors_total",
        "Total number of errors by type and code",
        &amp;["error_type", "error_code"]
    )
    .unwrap();
}

fn track_error(err: &amp;AppError) {
    // Increment error counter with labels
    ERROR_COUNTER
        .with_label_values(&amp;[
            std::any::type_name_of_val(err),
            err.error_code(),
        ])
        .inc();
}

fn handle_request(req: Request) -&gt; Result&lt;Response, AppError&gt; {
    match process_request(req) {
        Ok(response) =&gt; Ok(response),
        Err(e) =&gt; {
            // Track error metrics
            track_error(&amp;e);

            // Log error
            log_error(&amp;e);

            Err(e)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-rate-limiting"><a class="header" href="#error-rate-limiting">Error Rate Limiting</a></h3>
<p>For high-volume systems, implement error rate limiting to prevent overwhelming logs and reporting systems:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

struct ErrorRateLimiter {
    // Maps error type to last reported time and count
    last_reported: HashMap&lt;String, (Instant, u64)&gt;,
    // Minimum time between full error reports for the same error type
    min_interval: Duration,
    // Maximum errors to report in full detail during the interval
    max_per_interval: u64,
}

impl ErrorRateLimiter {
    fn new(min_interval: Duration, max_per_interval: u64) -&gt; Self {
        Self {
            last_reported: HashMap::new(),
            min_interval,
            max_per_interval,
        }
    }

    fn should_report_fully(&amp;mut self, error_type: &amp;str) -&gt; bool {
        let now = Instant::now();
        let entry = self.last_reported.entry(error_type.to_string())
            .or_insert((now, 0));

        if now.duration_since(entry.0) &gt; self.min_interval {
            // Reset if interval has passed
            *entry = (now, 1);
            true
        } else {
            // Increment counter
            entry.1 += 1;
            // Only report fully if under threshold
            entry.1 &lt;= self.max_per_interval
        }
    }
}

// Usage
fn log_error_with_rate_limiting(err: &amp;dyn Error, limiter: &amp;mut ErrorRateLimiter) {
    let error_type = std::any::type_name_of_val(err);

    if limiter.should_report_fully(error_type) {
        // Log full error details
        error!("Error: {}\n{:?}", err, err);
    } else {
        // Log minimal information
        warn!("Error rate limit exceeded for type: {}", error_type);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="customizing-error-display-for-different-formats"><a class="header" href="#customizing-error-display-for-different-formats">Customizing Error Display for Different Formats</a></h3>
<p>Different output formats require different error representations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ErrorFormatter {
    fn format_error(&amp;self, error: &amp;dyn Error) -&gt; String;
}

struct HtmlErrorFormatter;
impl ErrorFormatter for HtmlErrorFormatter {
    fn format_error(&amp;self, error: &amp;dyn Error) -&gt; String {
        let mut html = String::from("&lt;div class=\"error\"&gt;\n");
        html.push_str(&amp;format!("  &lt;div class=\"error-message\"&gt;{}&lt;/div&gt;\n", html_escape(error.to_string())));

        if let Some(source) = error.source() {
            html.push_str("  &lt;div class=\"error-cause\"&gt;\n");
            html.push_str("    &lt;div class=\"error-cause-label\"&gt;Caused by:&lt;/div&gt;\n");
            html.push_str(&amp;format!("    &lt;div class=\"error-cause-message\"&gt;{}&lt;/div&gt;\n", html_escape(source.to_string())));
            html.push_str("  &lt;/div&gt;\n");
        }

        html.push_str("&lt;/div&gt;");
        html
    }
}

struct JsonErrorFormatter;
impl ErrorFormatter for JsonErrorFormatter {
    fn format_error(&amp;self, error: &amp;dyn Error) -&gt; String {
        let mut causes = Vec::new();
        let mut current = error.source();

        while let Some(err) = current {
            causes.push(err.to_string());
            current = err.source();
        }

        let error_json = json!({
            "message": error.to_string(),
            "type": std::any::type_name_of_val(error),
            "causes": causes,
        });

        serde_json::to_string_pretty(&amp;error_json).unwrap()
    }
}

// Usage
fn render_error_page(err: &amp;dyn Error, formatter: &amp;dyn ErrorFormatter) -&gt; String {
    let mut page = String::from("&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n");
    page.push_str("  &lt;title&gt;Error&lt;/title&gt;\n");
    page.push_str("&lt;/head&gt;\n&lt;body&gt;\n");
    page.push_str("  &lt;h1&gt;An error occurred&lt;/h1&gt;\n");
    page.push_str(&amp;formatter.format_error(err));
    page.push_str("\n&lt;/body&gt;\n&lt;/html&gt;");
    page
}

fn html_escape(s: String) -&gt; String {
    s.replace("&amp;", "&amp;amp;")
     .replace("&lt;", "&amp;lt;")
     .replace("&gt;", "&amp;gt;")
     .replace("\"", "&amp;quot;")
     .replace("'", "&amp;#39;")
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-translation-for-internationalization"><a class="header" href="#error-translation-for-internationalization">Error Translation for Internationalization</a></h3>
<p>For applications with international users, error messages should be translatable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fluent::{FluentBundle, FluentResource};
use unic_langid::LanguageIdentifier;

struct I18nErrorFormatter {
    bundles: HashMap&lt;LanguageIdentifier, FluentBundle&lt;FluentResource&gt;&gt;,
}

impl I18nErrorFormatter {
    fn new() -&gt; Self {
        // Initialize with language bundles
        let mut bundles = HashMap::new();

        // English bundle
        let en_us: LanguageIdentifier = "en-US".parse().unwrap();
        let en_resource = FluentResource::try_new(String::from(r#"
            error-not-found = {$entity} not found.
            error-permission-denied = You don't have permission to access {$resource}.
            error-validation = Invalid value for {$field}: {$message}.
            error-generic = An error occurred. Please try again later.
        "#)).unwrap();

        let mut en_bundle = FluentBundle::new(vec![en_us.clone()]);
        en_bundle.add_resource(en_resource).unwrap();
        bundles.insert(en_us, en_bundle);

        // Add more languages as needed...

        Self { bundles }
    }

    fn format_error(&amp;self, error: &amp;AppError, lang_id: &amp;LanguageIdentifier) -&gt; String {
        let bundle = self.bundles.get(lang_id)
            .unwrap_or_else(|| self.bundles.get(&amp;"en-US".parse().unwrap()).unwrap());

        match error {
            AppError::NotFound { entity, id } =&gt; {
                let mut args = HashMap::new();
                args.insert("entity", entity.as_str());
                args.insert("id", id.as_str());

                let msg = bundle.get_message("error-not-found").unwrap();
                let pattern = msg.value().unwrap();

                bundle.format_pattern(pattern, Some(&amp;args), &amp;mut vec![]).unwrap().to_string()
            },
            // Handle other error types...
            _ =&gt; bundle.format_pattern(
                bundle.get_message("error-generic").unwrap().value().unwrap(),
                None,
                &amp;mut vec![]
            ).unwrap().to_string(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This approach separates error logic from the presentation, making it easier to provide localized error messages.</p>
<h2 id="error-handling-in-async-code"><a class="header" href="#error-handling-in-async-code">Error Handling in Async Code</a></h2>
<p>Asynchronous code introduces additional complexity to error handling. Let’s explore patterns for managing errors in async Rust.</p>
<h3 id="propagating-errors-in-async-functions"><a class="header" href="#propagating-errors-in-async-functions">Propagating Errors in Async Functions</a></h3>
<p>Just like synchronous code, async functions can use the <code>?</code> operator to propagate errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::fs;
use anyhow::Result;

async fn read_and_process_file(path: &amp;str) -&gt; Result&lt;String&gt; {
    let contents = fs::read_to_string(path).await?;
    let processed = process_contents(&amp;contents)?;
    Ok(processed)
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>?</code> operator works similarly in async functions, but the error propagation happens when the future is polled.</p>
<h3 id="handling-timeout-errors"><a class="header" href="#handling-timeout-errors">Handling Timeout Errors</a></h3>
<p>One common source of errors in async code is timeouts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::{timeout, Duration};
use thiserror::Error;

#[derive(Error, Debug)]
enum ApiError {
    #[error("request timed out after {0:?}")]
    Timeout(Duration),

    #[error("HTTP error: {0}")]
    Http(#[from] reqwest::Error),

    #[error("invalid response: {0}")]
    InvalidResponse(String),
}

async fn fetch_with_timeout(url: &amp;str, timeout_duration: Duration) -&gt; Result&lt;String, ApiError&gt; {
    let future = reqwest::get(url);

    match timeout(timeout_duration, future).await {
        Ok(response) =&gt; {
            let response = response.map_err(ApiError::Http)?;
            let text = response.text().await.map_err(ApiError::Http)?;

            if text.is_empty() {
                return Err(ApiError::InvalidResponse("Empty response".to_string()));
            }

            Ok(text)
        }
        Err(_) =&gt; Err(ApiError::Timeout(timeout_duration)),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="managing-concurrent-errors"><a class="header" href="#managing-concurrent-errors">Managing Concurrent Errors</a></h3>
<p>When executing multiple async operations concurrently, there are different strategies for handling errors:</p>
<h4 id="wait-for-all-results"><a class="header" href="#wait-for-all-results">Wait for All Results</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::future::{join_all, try_join_all};
use anyhow::Result;

async fn process_all_items(items: Vec&lt;Item&gt;) -&gt; Result&lt;Vec&lt;ProcessedItem&gt;&gt; {
    // Process all items concurrently, fail if any fail
    let futures = items.into_iter().map(|item| async move {
        process_item(item).await
    });

    // try_join_all returns an error if any future returns an error
    try_join_all(futures).await
}

async fn process_with_partial_results(items: Vec&lt;Item&gt;) -&gt; Vec&lt;Result&lt;ProcessedItem&gt;&gt; {
    // Process all items concurrently, collect all results
    let futures = items.into_iter().map(|item| async move {
        process_item(item).await
    });

    // join_all collects all futures regardless of success/failure
    join_all(futures).await
}
<span class="boring">}</span></code></pre></pre>
<h4 id="fail-fast-on-first-error"><a class="header" href="#fail-fast-on-first-error">Fail Fast on First Error</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::future::select_ok;
use thiserror::Error;

#[derive(Error, Debug)]
#[error("all attempts failed: {0}")]
struct AllFailedError(String);

async fn try_multiple_endpoints(endpoints: Vec&lt;String&gt;) -&gt; Result&lt;String, AllFailedError&gt; {
    let futures = endpoints.into_iter().map(|endpoint| async move {
        fetch_endpoint(&amp;endpoint).await
    });

    // select_ok returns the first successful result
    select_ok(futures).await
        .map(|(result, _)| result)
        .map_err(|e| AllFailedError(format!("all endpoints failed: {}", e)))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="backoff-and-retry-for-transient-errors"><a class="header" href="#backoff-and-retry-for-transient-errors">Backoff and Retry for Transient Errors</a></h3>
<p>For handling transient errors, implement retry logic with exponential backoff:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::{sleep, Duration};
use rand::Rng;

async fn with_retry&lt;F, Fut, T, E&gt;(
    operation: F,
    max_retries: usize,
    base_delay: Duration,
) -&gt; Result&lt;T, E&gt;
where
    F: Fn() -&gt; Fut,
    Fut: std::future::Future&lt;Output = Result&lt;T, E&gt;&gt;,
    E: std::fmt::Display,
{
    let mut rng = rand::thread_rng();
    let mut attempt = 0;
    let mut delay = base_delay;

    loop {
        match operation().await {
            Ok(value) =&gt; return Ok(value),
            Err(err) =&gt; {
                attempt += 1;

                if attempt &gt; max_retries {
                    return Err(err);
                }

                // Log retry attempt
                log::warn!(
                    "Operation failed (attempt {}/{}): {}. Retrying in {:?}...",
                    attempt,
                    max_retries,
                    err,
                    delay
                );

                // Add jitter to prevent thundering herd
                let jitter = Duration::from_millis(rng.gen_range(0..100));
                sleep(delay + jitter).await;

                // Exponential backoff
                delay *= 2;
            }
        }
    }
}

// Usage
async fn fetch_data_with_retry(url: &amp;str) -&gt; Result&lt;String, reqwest::Error&gt; {
    with_retry(
        || async { reqwest::get(url).await?.text().await },
        3,
        Duration::from_millis(100),
    )
    .await
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-boundaries-in-async-applications"><a class="header" href="#error-boundaries-in-async-applications">Error Boundaries in Async Applications</a></h3>
<p>In larger async applications, establish error boundaries to prevent error propagation across critical subsystems:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ErrorBoundary&lt;T&gt; {
    inner: T,
    name: &amp;'static str,
}

impl&lt;T&gt; ErrorBoundary&lt;T&gt; {
    fn new(inner: T, name: &amp;'static str) -&gt; Self {
        Self { inner, name }
    }

    async fn run&lt;F, Fut, R&gt;(&amp;self, operation: F) -&gt; R
    where
        F: FnOnce(&amp;T) -&gt; Fut,
        Fut: std::future::Future&lt;Output = Result&lt;R, anyhow::Error&gt;&gt;,
        R: Default,
    {
        match operation(&amp;self.inner).await {
            Ok(result) =&gt; result,
            Err(error) =&gt; {
                log::error!("Error in boundary {}: {}", self.name, error);

                // Report to monitoring system
                metrics::increment_counter!("error_boundary_failure", "boundary" =&gt; self.name);

                // Return default value for the result type
                R::default()
            }
        }
    }
}

// Usage
async fn run_subsystem() {
    let db = Database::connect().await.expect("Failed to connect to database");
    let api_client = ApiClient::new();

    let db_boundary = ErrorBoundary::new(db, "database");
    let api_boundary = ErrorBoundary::new(api_client, "api");

    // Even if this fails, it won't crash the application
    let users = db_boundary.run(|db| async {
        db.fetch_users().await.context("Failed to fetch users")
    }).await;

    // This runs regardless of whether the previous operation succeeded
    let products = api_boundary.run(|api| async {
        api.fetch_products().await.context("Failed to fetch products")
    }).await;

    // Continue with application logic...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="practical-error-handling-example"><a class="header" href="#practical-error-handling-example">Practical Error Handling Example</a></h2>
<p>Let’s tie everything together with a comprehensive example of error handling in a real-world application. We’ll create a file processing utility that demonstrates proper error handling throughout the application.</p>
<h3 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h3>
<pre><code>file-processor/
├── Cargo.toml
├── src/
│   ├── main.rs
│   ├── error.rs
│   ├── processor.rs
│   ├── storage.rs
│   └── config.rs
</code></pre>
<h3 id="error-module"><a class="header" href="#error-module">Error Module</a></h3>
<p>First, let’s define our error types in <code>error.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::PathBuf;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("I/O error: {source}")]
    Io {
        #[source]
        source: std::io::Error,
        path: Option&lt;PathBuf&gt;,
    },

    #[error("Configuration error: {0}")]
    Config(#[from] ConfigError),

    #[error("Processing error: {0}")]
    Processing(#[from] ProcessingError),

    #[error("Storage error: {0}")]
    Storage(#[from] StorageError),
}

// Convert io::Error to AppError with path context
impl From&lt;std::io::Error&gt; for AppError {
    fn from(error: std::io::Error) -&gt; Self {
        Self::Io {
            source: error,
            path: None,
        }
    }
}

// Helper to add path context to io errors
pub fn with_path&lt;T&gt;(result: std::io::Result&lt;T&gt;, path: impl Into&lt;PathBuf&gt;) -&gt; Result&lt;T, AppError&gt; {
    result.map_err(|err| AppError::Io {
        source: err,
        path: Some(path.into()),
    })
}

#[derive(Error, Debug)]
pub enum ConfigError {
    #[error("Missing required config value: {0}")]
    MissingValue(String),

    #[error("Invalid config value for {key}: {message}")]
    InvalidValue {
        key: String,
        message: String,
    },

    #[error("Failed to parse config file: {0}")]
    ParseError(#[source] serde_json::Error),
}

#[derive(Error, Debug)]
pub enum ProcessingError {
    #[error("Unsupported file format: {0}")]
    UnsupportedFormat(String),

    #[error("Processing timeout after {0:?}")]
    Timeout(std::time::Duration),

    #[error("Failed to process line {line}: {message}")]
    LineError {
        line: usize,
        message: String,
    },
}

#[derive(Error, Debug)]
pub enum StorageError {
    #[error("Failed to connect to storage: {0}")]
    ConnectionFailed(String),

    #[error("Item not found: {0}")]
    NotFound(String),

    #[error("Permission denied for operation on {resource}")]
    PermissionDenied {
        resource: String,
        #[source]
        source: Option&lt;std::io::Error&gt;,
    },
}

// Type alias for common result type
pub type Result&lt;T&gt; = std::result::Result&lt;T, AppError&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="config-module"><a class="header" href="#config-module">Config Module</a></h3>
<p>Now, let’s implement the configuration handling in <code>config.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::error::{ConfigError, Result, with_path};
use serde::Deserialize;
use std::path::Path;
use std::fs;

#[derive(Debug, Deserialize)]
pub struct Config {
    pub input_dir: String,
    pub output_dir: String,
    pub backup_dir: Option&lt;String&gt;,
    pub processing: ProcessingConfig,
}

#[derive(Debug, Deserialize)]
pub struct ProcessingConfig {
    pub max_concurrent_files: usize,
    pub timeout_seconds: u64,
    pub supported_formats: Vec&lt;String&gt;,
}

impl Config {
    pub fn from_file(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Self&gt; {
        let path = path.as_ref();
        let content = with_path(fs::read_to_string(path), path)?;

        let config: Config = serde_json::from_str(&amp;content)
            .map_err(ConfigError::ParseError)?;

        config.validate()?;

        Ok(config)
    }

    fn validate(&amp;self) -&gt; std::result::Result&lt;(), ConfigError&gt; {
        if self.input_dir.is_empty() {
            return Err(ConfigError::MissingValue("input_dir".to_string()));
        }

        if self.output_dir.is_empty() {
            return Err(ConfigError::MissingValue("output_dir".to_string()));
        }

        if self.processing.max_concurrent_files == 0 {
            return Err(ConfigError::InvalidValue {
                key: "processing.max_concurrent_files".to_string(),
                message: "Must be greater than 0".to_string(),
            });
        }

        if self.processing.supported_formats.is_empty() {
            return Err(ConfigError::InvalidValue {
                key: "processing.supported_formats".to_string(),
                message: "At least one format must be specified".to_string(),
            });
        }

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="processor-module"><a class="header" href="#processor-module">Processor Module</a></h3>
<p>Now, let’s implement the file processing logic in <code>processor.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::config::Config;
use crate::error::{ProcessingError, Result, with_path};
use crate::storage::Storage;
use std::path::{Path, PathBuf};
use std::fs;
use tokio::time::{timeout, Duration};
use futures::future::join_all;
use std::sync::Arc;
use tokio::sync::Semaphore;

pub struct Processor {
    config: Config,
    storage: Arc&lt;dyn Storage&gt;,
}

impl Processor {
    pub fn new(config: Config, storage: Arc&lt;dyn Storage&gt;) -&gt; Self {
        Self { config, storage }
    }

    pub async fn process_directory(&amp;self, dir: impl AsRef&lt;Path&gt;) -&gt; Result&lt;ProcessingSummary&gt; {
        let dir = dir.as_ref();
        let entries = with_path(fs::read_dir(dir), dir)?;

        let mut files = Vec::new();
        for entry in entries {
            let entry = entry?;
            let path = entry.path();

            if path.is_file() &amp;&amp; self.is_supported_format(&amp;path) {
                files.push(path);
            }
        }

        log::info!("Found {} files to process in {}", files.len(), dir.display());

        if files.is_empty() {
            return Ok(ProcessingSummary::default());
        }

        // Process files concurrently with a limit
        let semaphore = Arc::new(Semaphore::new(self.config.max_concurrent_files));
        let timeout_duration = Duration::from_secs(self.config.timeout_seconds);

        let futures = files.into_iter().map(|file| {
            let semaphore = Arc::clone(&amp;semaphore);
            let storage = Arc::clone(&amp;self.storage);

            async move {
                let _permit = semaphore.acquire().await.unwrap();
                self.process_file(&amp;file, &amp;storage, timeout_duration).await
            }
        });

        let results = join_all(futures).await;

        // Aggregate results
        let mut summary = ProcessingSummary::default();
        let mut errors = Vec::new();

        for (i, result) in results.into_iter().enumerate() {
            match result {
                Ok(file_result) =&gt; {
                    summary.processed_files += 1;
                    summary.processed_lines += file_result.processed_lines;
                }
                Err(e) =&gt; {
                    summary.failed_files += 1;
                    errors.push(format!("File {}: {}", i, e));
                }
            }
        }

        if !errors.is_empty() {
            log::warn!("Encountered errors while processing:\n{}", errors.join("\n"));
        }

        Ok(summary)
    }

    async fn process_file(
        &amp;self,
        path: &amp;Path,
        storage: &amp;Arc&lt;dyn Storage&gt;,
        timeout_duration: Duration,
    ) -&gt; Result&lt;FileResult&gt; {
        log::info!("Processing file: {}", path.display());

        // Apply timeout to the whole operation
        match timeout(timeout_duration, self.do_process_file(path, storage)).await {
            Ok(result) =&gt; result,
            Err(_) =&gt; Err(ProcessingError::Timeout(timeout_duration).into()),
        }
    }

    async fn do_process_file(&amp;self, path: &amp;Path, storage: &amp;Arc&lt;dyn Storage&gt;) -&gt; Result&lt;FileResult&gt; {
        let content = with_path(fs::read_to_string(path), path)?;
        let lines: Vec&lt;&amp;str&gt; = content.lines().collect();

        let mut result = FileResult::default();

        for (i, line) in lines.iter().enumerate() {
            let line_num = i + 1;

            if line.trim().is_empty() {
                continue;
            }

            match self.process_line(line, line_num)? {
                Some(processed) =&gt; {
                    storage.store(&amp;processed).await?;
                    result.processed_lines += 1;
                }
                None =&gt; continue,
            }
        }

        // Move to backup directory if specified
        if let Some(ref backup_dir) = self.config.backup_dir {
            let file_name = path.file_name().unwrap();
            let backup_path = Path::new(backup_dir).join(file_name);
            with_path(fs::rename(path, &amp;backup_path), path)?;
        }

        Ok(result)
    }

    fn process_line(&amp;self, line: &amp;str, line_num: usize) -&gt; Result&lt;Option&lt;String&gt;&gt; {
        // Skip comments
        if line.starts_with('#') {
            return Ok(None);
        }

        // Simple processing: uppercase non-comment lines
        let processed = line.to_uppercase();

        // Simulate validation
        if processed.contains("ERROR") {
            return Err(ProcessingError::LineError {
                line: line_num,
                message: "Line contains error marker".to_string(),
            }
            .into());
        }

        Ok(Some(processed))
    }

    fn is_supported_format(&amp;self, path: &amp;Path) -&gt; bool {
        if let Some(ext) = path.extension() {
            if let Some(ext_str) = ext.to_str() {
                return self.config.processing.supported_formats.contains(
                    &amp;ext_str.to_lowercase()
                );
            }
        }
        false
    }
}

#[derive(Debug, Default)]
pub struct ProcessingSummary {
    pub processed_files: usize,
    pub failed_files: usize,
    pub processed_lines: usize,
}

#[derive(Debug, Default)]
struct FileResult {
    processed_lines: usize,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="storage-module"><a class="header" href="#storage-module">Storage Module</a></h3>
<p>Next, let’s implement the storage interface in <code>storage.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_trait::async_trait;
use crate::error::{StorageError, Result};
use std::path::Path;
use std::fs::{self, File, OpenOptions};
use std::io::{self, Write};

#[async_trait]
pub trait Storage: Send + Sync {
    async fn store(&amp;self, data: &amp;str) -&gt; Result&lt;()&gt;;
}

pub struct FileStorage {
    output_path: String,
}

impl FileStorage {
    pub fn new(output_path: String) -&gt; Self {
        Self { output_path }
    }
}

#[async_trait]
impl Storage for FileStorage {
    async fn store(&amp;self, data: &amp;str) -&gt; Result&lt;()&gt; {
        let path = Path::new(&amp;self.output_path);

        // Ensure directory exists
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent).map_err(|e| StorageError::PermissionDenied {
                resource: parent.display().to_string(),
                source: Some(e),
            })?;
        }

        // Append to file
        let mut file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(path)
            .map_err(|e| StorageError::PermissionDenied {
                resource: path.display().to_string(),
                source: Some(e),
            })?;

        writeln!(file, "{}", data).map_err(|e| StorageError::PermissionDenied {
            resource: path.display().to_string(),
            source: Some(e),
        })?;

        Ok(())
    }
}

// Mock storage for testing
#[cfg(test)]
pub struct MockStorage {
    pub stored_items: std::sync::Mutex&lt;Vec&lt;String&gt;&gt;,
}

#[cfg(test)]
impl MockStorage {
    pub fn new() -&gt; Self {
        Self {
            stored_items: std::sync::Mutex::new(Vec::new()),
        }
    }
}

#[cfg(test)]
#[async_trait]
impl Storage for MockStorage {
    async fn store(&amp;self, data: &amp;str) -&gt; Result&lt;()&gt; {
        let mut items = self.stored_items.lock().unwrap();
        items.push(data.to_string());
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="main-application"><a class="header" href="#main-application">Main Application</a></h3>
<p>Finally, let’s implement the main application in <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">mod config;
mod error;
mod processor;
mod storage;

use crate::config::Config;
use crate::error::Result;
use crate::processor::Processor;
use crate::storage::FileStorage;
use std::sync::Arc;
use std::path::Path;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Initialize logging
    env_logger::init();

    // Load configuration
    let config_path = std::env::args()
        .nth(1)
        .unwrap_or_else(|| "config.json".to_string());

    log::info!("Loading configuration from {}", config_path);
    let config = Config::from_file(config_path)?;

    // Initialize storage
    let storage = Arc::new(FileStorage::new(config.output_dir.clone()));

    // Create processor
    let processor = Processor::new(config.clone(), storage);

    // Process input directory
    log::info!("Starting processing of directory: {}", config.input_dir);
    let summary = processor.process_directory(&amp;config.input_dir).await?;

    log::info!(
        "Processing complete. Processed {} files ({} failed) with {} lines.",
        summary.processed_files,
        summary.failed_files,
        summary.processed_lines
    );

    Ok(())
}</code></pre></pre>
<h3 id="error-handling-strategies-demonstrated"><a class="header" href="#error-handling-strategies-demonstrated">Error Handling Strategies Demonstrated</a></h3>
<p>This example demonstrates several error handling strategies:</p>
<ol>
<li><strong>Domain-specific error types</strong> - We define separate error enums for different parts of the application.</li>
<li><strong>Error context</strong> - We add context like file paths to I/O errors.</li>
<li><strong>Error conversion</strong> - We implement <code>From</code> traits to convert between error types.</li>
<li><strong>Functional error handling</strong> - We use combinators like <code>map_err</code> to transform errors.</li>
<li><strong>Async error handling</strong> - We handle errors in async code with timeouts and concurrency controls.</li>
<li><strong>Error aggregation</strong> - We collect errors from multiple concurrent operations.</li>
<li><strong>Structured logging</strong> - We log errors with context and severity levels.</li>
<li><strong>Error rate limiting</strong> - We implement error rate limiting to prevent overwhelming logs and reporting systems.</li>
<li><strong>Custom error formatting</strong> - We implement custom error formatting for different output formats.</li>
<li><strong>Error translation for internationalization</strong> - We implement error translation for different languages.</li>
</ol>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this chapter, we’ve explored advanced error handling patterns and libraries in Rust. We’ve seen how to:</p>
<ol>
<li>Create custom error types that express the specific failure modes of your application.</li>
<li>Use libraries like <code>thiserror</code> and <code>anyhow</code> to simplify error handling code.</li>
<li>Add rich context to errors to make them more actionable.</li>
<li>Build error hierarchies that scale with application complexity.</li>
<li>Work with collections and fallible operations on iterators.</li>
<li>Collect and aggregate multiple errors for validation scenarios.</li>
<li>Log and report errors in a structured way for different audiences.</li>
<li>Handle errors in asynchronous code with timeouts and retries.</li>
<li>Implement comprehensive error handling in a real-world application.</li>
</ol>
<p>Error handling is a critical aspect of writing robust, maintainable Rust code. By applying the patterns and techniques from this chapter, you can create applications that handle errors gracefully, provide clear diagnostics, and degrade gracefully when things go wrong.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li>
<p><strong>Error Type Design</strong>: Create a domain-specific error type for a web API client that handles different types of API errors (authentication, rate limiting, resource not found, etc.).</p>
</li>
<li>
<p><strong>Error Context</strong>: Enhance a file processing function to add detailed context to I/O errors, such as operation type, file path, and user permissions.</p>
</li>
<li>
<p><strong>Error Reporting</strong>: Implement a function that formats errors differently for three audiences: end users, system administrators, and developers.</p>
</li>
<li>
<p><strong>Fallible Collection Processing</strong>: Write a function that processes a collection of items, collecting successful results and errors separately, with a configurable error tolerance.</p>
</li>
<li>
<p><strong>Async Error Handling</strong>: Implement a function that fetches data from multiple sources concurrently, with timeouts and retries for transient errors.</p>
</li>
<li>
<p><strong>Error Aggregation</strong>: Create a validation system that checks multiple conditions and collects all validation errors instead of stopping at the first one.</p>
</li>
<li>
<p><strong>Error Libraries Integration</strong>: Refactor an existing error handling implementation to use <code>thiserror</code> and <code>anyhow</code> appropriately.</p>
</li>
<li>
<p><strong>Error Metrics</strong>: Add error tracking and metrics collection to an application, counting different types of errors and their frequencies.</p>
</li>
</ol>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/error.html">Rust by Example: Error Handling</a></li>
<li><a href="https://docs.rs/thiserror">The <code>thiserror</code> crate documentation</a></li>
<li><a href="https://docs.rs/anyhow">The <code>anyhow</code> crate documentation</a></li>
<li><a href="https://docs.rs/snafu">The <code>snafu</code> crate for error handling</a></li>
<li><a href="https://blog.burntsushi.net/rust-error-handling/">Error Handling in Rust</a> by Andrew Gallant</li>
<li><a href="https://www.youtube.com/watch?v=iesXrssV9Gg">Failure Modes in Distributed Systems</a> by Bryan Cantrill</li>
<li><a href="https://www.youtube.com/watch?v=udHj4FCUU1E">Designing Error Types in Rust</a> by Jane Lusby</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapters/20-result-option.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapters/22-iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapters/20-result-option.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapters/22-iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
