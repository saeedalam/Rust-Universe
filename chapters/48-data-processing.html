<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Real-Time Data Processing System - Rust Universe: Fearless Systems Engineering</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to learning the Rust programming language from fundamentals to mastery.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Universe: Fearless Systems Engineering</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/saeedalam/rust-universe" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/saeedalam/rust-universe/edit/main/src/chapters/48-data-processing.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-48-real-time-data-processing-system"><a class="header" href="#chapter-48-real-time-data-processing-system">Chapter 48: Real-Time Data Processing System</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>In today’s data-driven world, the ability to process and analyze information in real-time has become a critical competitive advantage across industries. From financial services monitoring market changes to e-commerce platforms tracking user behavior, or IoT networks processing sensor data—real-time data processing enables organizations to make faster, more informed decisions.</p>
<p>In this chapter, we’ll build a complete real-time data processing system in Rust, leveraging the language’s performance, safety, and concurrency features. Our system, which we’ll call “RustStream,” will demonstrate how to collect, process, analyze, and visualize streaming data with minimal latency.</p>
<p>By the end of this chapter, you’ll understand:</p>
<ol>
<li>The architecture of modern streaming data systems</li>
<li>How to implement event sourcing and stream processing patterns</li>
<li>Techniques for building robust, fault-tolerant data pipelines</li>
<li>Methods for real-time analytics and alerting</li>
<li>Approaches to visualizing live data</li>
<li>Strategies for deploying and scaling streaming applications</li>
</ol>
<p>Real-time data processing presents unique challenges compared to batch processing. Data arrives continuously, often at unpredictable rates, and must be processed with strict latency requirements. Our implementation will address these challenges while maintaining the reliability and correctness that Rust encourages.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>This chapter builds upon concepts covered throughout this book, particularly:</p>
<ul>
<li>Asynchronous programming (Chapter 25)</li>
<li>Concurrency fundamentals (Chapter 24)</li>
<li>Error handling patterns (Chapter 21)</li>
<li>Network programming (Chapter 32)</li>
<li>Performance optimization (Chapter 36)</li>
</ul>
<p>While not strictly necessary, familiarity with distributed systems concepts (Chapter 41) will be helpful.</p>
<h3 id="system-overview"><a class="header" href="#system-overview">System Overview</a></h3>
<p>Our RustStream system will comprise several key components:</p>
<ol>
<li><strong>Event Collection</strong>: Ingesting data from various sources through multiple protocols</li>
<li><strong>Stream Processing Engine</strong>: Transforming, filtering, and enriching data in real-time</li>
<li><strong>State Management</strong>: Maintaining queryable views of processed data</li>
<li><strong>Analytics Engine</strong>: Performing calculations and detecting patterns on streaming data</li>
<li><strong>Alerting System</strong>: Monitoring streams for conditions and notifying users</li>
<li><strong>Dashboard</strong>: Visualizing real-time metrics and insights</li>
<li><strong>Cluster Management</strong>: Coordinating distributed nodes for scalability and fault tolerance</li>
</ol>
<p>Let’s begin by exploring the fundamental concepts of event sourcing and stream processing, which form the theoretical foundation of our system.</p>
<h2 id="fundamentals-of-real-time-data-processing"><a class="header" href="#fundamentals-of-real-time-data-processing">Fundamentals of Real-Time Data Processing</a></h2>
<p>Before diving into implementation, let’s establish a solid understanding of the key concepts and architectural patterns in real-time data processing.</p>
<h3 id="event-sourcing"><a class="header" href="#event-sourcing">Event Sourcing</a></h3>
<p>Event sourcing is a pattern where changes to application state are stored as a sequence of events. Instead of just storing the current state, we record each change as an immutable fact. This approach offers several advantages:</p>
<ol>
<li><strong>Complete Audit Trail</strong>: Every change is recorded, providing a comprehensive history</li>
<li><strong>Temporal Queries</strong>: The ability to determine the state at any point in time</li>
<li><strong>Event Replay</strong>: Systems can be rebuilt by replaying events from any point</li>
<li><strong>Decoupled Systems</strong>: Events can be consumed by multiple systems independently</li>
</ol>
<p>In event sourcing, events are:</p>
<ul>
<li><strong>Immutable</strong>: Once recorded, events never change</li>
<li><strong>Chronological</strong>: Events have a clear temporal ordering</li>
<li><strong>Self-contained</strong>: Events contain all necessary information about what happened</li>
</ul>
<h3 id="stream-processing"><a class="header" href="#stream-processing">Stream Processing</a></h3>
<p>Stream processing is the practice of performing computations on data continuously as it arrives, rather than in batches. Key concepts include:</p>
<ol>
<li><strong>Streams</strong>: Unbounded sequences of events ordered by time</li>
<li><strong>Operators</strong>: Functions that transform one stream into another</li>
<li><strong>Windowing</strong>: Grouping events within time boundaries for aggregation</li>
<li><strong>Stateful Processing</strong>: Maintaining and updating state based on streaming events</li>
<li><strong>Backpressure</strong>: Mechanisms to handle scenarios where data arrives faster than it can be processed</li>
</ol>
<h3 id="data-flow-architecture"><a class="header" href="#data-flow-architecture">Data Flow Architecture</a></h3>
<p>Our system will follow a data flow architecture, where:</p>
<ol>
<li><strong>Sources</strong> produce events (e.g., sensors, user actions, system logs)</li>
<li><strong>Processors</strong> transform, filter, or enrich those events</li>
<li><strong>Sinks</strong> consume processed events (e.g., databases, notification systems, dashboards)</li>
</ol>
<p>This architecture enables a composable, modular system where components can be developed and scaled independently.</p>
<h3 id="consistency-and-reliability-models"><a class="header" href="#consistency-and-reliability-models">Consistency and Reliability Models</a></h3>
<p>Real-time systems must make trade-offs between:</p>
<ol>
<li><strong>Latency</strong>: How quickly events are processed</li>
<li><strong>Throughput</strong>: How many events can be processed per time unit</li>
<li><strong>Consistency</strong>: Guarantees about event ordering and processing</li>
<li><strong>Durability</strong>: Persistence of events against failures</li>
</ol>
<p>Our implementation will support multiple processing semantics:</p>
<ul>
<li><strong>At-most-once</strong>: Events might be lost but never processed twice</li>
<li><strong>At-least-once</strong>: Events are never lost but might be processed multiple times</li>
<li><strong>Exactly-once</strong>: Events are processed once and only once (the most challenging to implement)</li>
</ul>
<p>With these fundamental concepts in mind, let’s begin building our RustStream system, starting with the core event data model and processing engine.</p>
<h2 id="event-model-and-core-components"><a class="header" href="#event-model-and-core-components">Event Model and Core Components</a></h2>
<p>Let’s start by designing the core data model for our stream processing system. In Rust, we’ll define flexible, efficient structures that can represent a wide variety of event types while maintaining strong typing where possible.</p>
<h3 id="event-data-model"><a class="header" href="#event-data-model">Event Data Model</a></h3>
<p>First, let’s define our event structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;

/// Represents a single event in our system
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Event {
    /// Unique identifier for the event
    pub id: Uuid,
    /// Type of event (domain-specific)
    pub event_type: String,
    /// Source that produced the event
    pub source: String,
    /// When the event occurred
    pub timestamp: DateTime&lt;Utc&gt;,
    /// Event payload
    pub data: EventData,
    /// Additional metadata
    pub metadata: HashMap&lt;String, String&gt;,
}

/// Flexible data payload for events
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventData {
    /// Null value
    Null,
    /// Boolean value
    Bool(bool),
    /// Numeric value
    Number(f64),
    /// String value
    String(String),
    /// Array of values
    Array(Vec&lt;EventData&gt;),
    /// Object with string keys
    Object(HashMap&lt;String, EventData&gt;),
}

impl Event {
    /// Creates a new event
    pub fn new(event_type: &amp;str, source: &amp;str, data: EventData) -&gt; Self {
        Self {
            id: Uuid::new_v4(),
            event_type: event_type.to_string(),
            source: source.to_string(),
            timestamp: Utc::now(),
            data,
            metadata: HashMap::new(),
        }
    }

    /// Adds metadata to the event
    pub fn with_metadata(mut self, key: &amp;str, value: &amp;str) -&gt; Self {
        self.metadata.insert(key.to_string(), value.to_string());
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This flexible event model allows us to represent diverse data types while maintaining serialization compatibility. Next, let’s define the interfaces for event sources and sinks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_trait::async_trait;
use thiserror::Error;

/// Errors that can occur in the event processing system
#[derive(Debug, Error)]
pub enum EventError {
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Serialization error: {0}")]
    Serialization(String),

    #[error("Connection error: {0}")]
    Connection(String),

    #[error("Processing error: {0}")]
    Processing(String),

    #[error("Timeout error")]
    Timeout,
}

/// Result type for event operations
pub type EventResult&lt;T&gt; = Result&lt;T, EventError&gt;;

/// Source of events in the system
#[async_trait]
pub trait EventSource: Send + Sync {
    /// Returns the name of this event source
    fn name(&amp;self) -&gt; &amp;str;

    /// Asynchronously reads the next event
    async fn next(&amp;mut self) -&gt; EventResult&lt;Option&lt;Event&gt;&gt;;

    /// Commits progress (if supported by the source)
    async fn commit(&amp;mut self) -&gt; EventResult&lt;()&gt;;
}

/// Sink for events in the system
#[async_trait]
pub trait EventSink: Send + Sync {
    /// Returns the name of this event sink
    fn name(&amp;self) -&gt; &amp;str;

    /// Asynchronously writes an event
    async fn write(&amp;mut self, event: &amp;Event) -&gt; EventResult&lt;()&gt;;

    /// Flushes any buffered events
    async fn flush(&amp;mut self) -&gt; EventResult&lt;()&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="stream-processing-engine"><a class="header" href="#stream-processing-engine">Stream Processing Engine</a></h3>
<p>Now let’s build the core stream processing engine that will orchestrate data flow through our system:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::stream::{self, Stream, StreamExt};
use std::pin::Pin;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::{mpsc, Mutex};
use tokio::time;

/// Type alias for a boxed stream of events
pub type EventStream = Pin&lt;Box&lt;dyn Stream&lt;Item = EventResult&lt;Event&gt;&gt; + Send&gt;&gt;;

/// Represents an operation on an event stream
#[async_trait]
pub trait Operator: Send + Sync {
    /// Returns the name of this operator
    fn name(&amp;self) -&gt; &amp;str;

    /// Applies this operator to an input stream, producing an output stream
    async fn apply(&amp;self, input: EventStream) -&gt; EventStream;
}

/// The core stream processing engine
pub struct StreamEngine {
    /// Name of this engine instance
    name: String,
    /// Registered event sources
    sources: Vec&lt;Arc&lt;Mutex&lt;dyn EventSource&gt;&gt;&gt;,
    /// Processing operators
    operators: Vec&lt;Arc&lt;dyn Operator&gt;&gt;,
    /// Event sinks
    sinks: Vec&lt;Arc&lt;Mutex&lt;dyn EventSink&gt;&gt;&gt;,
}

impl StreamEngine {
    /// Creates a new stream engine
    pub fn new(name: &amp;str) -&gt; Self {
        Self {
            name: name.to_string(),
            sources: Vec::new(),
            operators: Vec::new(),
            sinks: Vec::new(),
        }
    }

    /// Adds an event source to the engine
    pub fn add_source&lt;S&gt;(&amp;mut self, source: S) -&gt; &amp;mut Self
    where
        S: EventSource + 'static,
    {
        self.sources.push(Arc::new(Mutex::new(source)));
        self
    }

    /// Adds an operator to the processing pipeline
    pub fn add_operator&lt;O&gt;(&amp;mut self, operator: O) -&gt; &amp;mut Self
    where
        O: Operator + 'static,
    {
        self.operators.push(Arc::new(operator));
        self
    }

    /// Adds an event sink to the engine
    pub fn add_sink&lt;S&gt;(&amp;mut self, sink: S) -&gt; &amp;mut Self
    where
        S: EventSink + 'static,
    {
        self.sinks.push(Arc::new(Mutex::new(sink)));
        self
    }

    /// Runs the stream processing pipeline
    pub async fn run(&amp;self) -&gt; EventResult&lt;()&gt; {
        // Create input streams from all sources
        let mut source_streams = Vec::new();

        for source in &amp;self.sources {
            let source_clone = source.clone();

            // Create a stream from this source
            let stream = stream::unfold(source_clone, |source_ref| async move {
                let mut source = source_ref.lock().await;
                match source.next().await {
                    Ok(Some(event)) =&gt; {
                        // Successfully got an event
                        Some((Ok(event), source_ref))
                    }
                    Ok(None) =&gt; {
                        // Source is exhausted
                        None
                    }
                    Err(e) =&gt; {
                        // Error occurred
                        Some((Err(e), source_ref))
                    }
                }
            });

            source_streams.push(Box::pin(stream) as EventStream);
        }

        // Merge all source streams
        let mut merged_stream: EventStream = if source_streams.is_empty() {
            // Empty stream if no sources
            Box::pin(stream::empty())
        } else if source_streams.len() == 1 {
            // Just use the single stream
            source_streams.pop().unwrap()
        } else {
            // Merge multiple streams
            Box::pin(stream::select_all(source_streams))
        };

        // Apply all operators in sequence
        for operator in &amp;self.operators {
            merged_stream = operator.apply(merged_stream).await;
        }

        // Create channels for each sink
        let (tx, mut rx) = mpsc::channel(1000); // Buffer size of 1000 events

        // Task to process events and send to sinks
        let sinks = self.sinks.clone();
        tokio::spawn(async move {
            while let Some(result) = rx.recv().await {
                match result {
                    Ok(event) =&gt; {
                        // Send to all sinks
                        for sink in &amp;sinks {
                            let mut sink = sink.lock().await;
                            if let Err(e) = sink.write(&amp;event).await {
                                eprintln!("Error writing to sink {}: {}", sink.name(), e);
                            }
                        }
                    }
                    Err(e) =&gt; {
                        eprintln!("Error in stream processing: {}", e);
                    }
                }
            }

            // Flush all sinks when the channel closes
            for sink in &amp;sinks {
                let mut sink = sink.lock().await;
                if let Err(e) = sink.flush().await {
                    eprintln!("Error flushing sink {}: {}", sink.name(), e);
                }
            }
        });

        // Process the stream
        tokio::spawn(async move {
            merged_stream
                .for_each(|result| async {
                    if tx.send(result).await.is_err() {
                        // Channel closed, stop processing
                        return;
                    }
                })
                .await;
        });

        // Keep the engine running
        loop {
            time::sleep(Duration::from_secs(1)).await;
            // In a real implementation, we would have proper shutdown handling
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="common-stream-operators"><a class="header" href="#common-stream-operators">Common Stream Operators</a></h3>
<p>Let’s implement some common stream operators that form the building blocks of our processing pipelines:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Filters events based on a predicate
pub struct FilterOperator&lt;F&gt; {
    name: String,
    predicate: F,
}

impl&lt;F&gt; FilterOperator&lt;F&gt;
where
    F: Fn(&amp;Event) -&gt; bool + Send + Sync + 'static,
{
    pub fn new(name: &amp;str, predicate: F) -&gt; Self {
        Self {
            name: name.to_string(),
            predicate,
        }
    }
}

#[async_trait]
impl&lt;F&gt; Operator for FilterOperator&lt;F&gt;
where
    F: Fn(&amp;Event) -&gt; bool + Send + Sync + 'static,
{
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    async fn apply(&amp;self, input: EventStream) -&gt; EventStream {
        let predicate = self.predicate.clone();
        Box::pin(input.filter(move |result| {
            let keep = match result {
                Ok(event) =&gt; predicate(event),
                Err(_) =&gt; true, // Pass through errors
            };
            futures::future::ready(keep)
        }))
    }
}

/// Maps events using a transformation function
pub struct MapOperator&lt;F&gt; {
    name: String,
    mapper: F,
}

impl&lt;F&gt; MapOperator&lt;F&gt;
where
    F: Fn(Event) -&gt; Event + Send + Sync + 'static,
{
    pub fn new(name: &amp;str, mapper: F) -&gt; Self {
        Self {
            name: name.to_string(),
            mapper,
        }
    }
}

#[async_trait]
impl&lt;F&gt; Operator for MapOperator&lt;F&gt;
where
    F: Fn(Event) -&gt; Event + Send + Sync + 'static,
{
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    async fn apply(&amp;self, input: EventStream) -&gt; EventStream {
        let mapper = self.mapper.clone();
        Box::pin(input.map(move |result| match result {
            Ok(event) =&gt; Ok(mapper(event)),
            Err(e) =&gt; Err(e),
        }))
    }
}

/// Windowing operator that groups events by time
pub struct WindowOperator {
    name: String,
    window_duration: Duration,
}

impl WindowOperator {
    pub fn new(name: &amp;str, window_duration: Duration) -&gt; Self {
        Self {
            name: name.to_string(),
            window_duration,
        }
    }
}

#[async_trait]
impl Operator for WindowOperator {
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    async fn apply(&amp;self, input: EventStream) -&gt; EventStream {
        let duration = self.window_duration;

        // Create a channel for windowed events
        let (tx, rx) = mpsc::channel(1000);

        // Spawn a task to handle windowing
        tokio::spawn(async move {
            let mut window = Vec::new();
            let mut window_end = None;

            input
                .for_each(|result| async {
                    match result {
                        Ok(event) =&gt; {
                            // Initialize window end if this is the first event
                            if window_end.is_none() {
                                window_end = Some(event.timestamp + chrono::Duration::from_std(duration).unwrap());
                            }

                            // Check if this event belongs to the current window
                            if let Some(end) = window_end {
                                if event.timestamp &lt; end {
                                    // Event belongs to current window
                                    window.push(event);
                                } else {
                                    // Close current window and emit events
                                    let events_to_emit = std::mem::take(&amp;mut window);

                                    // Create a window event containing all events
                                    if !events_to_emit.is_empty() {
                                        let window_event = Event::new(
                                            "window",
                                            "stream_engine",
                                            EventData::Array(
                                                events_to_emit
                                                    .into_iter()
                                                    .map(|e| EventData::Object({
                                                        let mut map = HashMap::new();
                                                        map.insert("event".to_string(), EventData::Object({
                                                            let mut inner_map = HashMap::new();
                                                            inner_map.insert("id".to_string(), EventData::String(e.id.to_string()));
                                                            inner_map.insert("type".to_string(), EventData::String(e.event_type));
                                                            inner_map.insert("source".to_string(), EventData::String(e.source));
                                                            inner_map.insert("timestamp".to_string(), EventData::String(e.timestamp.to_rfc3339()));
                                                            inner_map.insert("data".to_string(), e.data);
                                                            inner_map
                                                        }));
                                                        map
                                                    }))
                                                    .collect(),
                                            ),
                                        );

                                        if tx.send(Ok(window_event)).await.is_err() {
                                            return;
                                        }
                                    }

                                    // Start a new window
                                    window.push(event);
                                    window_end = Some(event.timestamp + chrono::Duration::from_std(duration).unwrap());
                                }
                            }
                        }
                        Err(e) =&gt; {
                            // Pass through errors
                            if tx.send(Err(e)).await.is_err() {
                                return;
                            }
                        }
                    }
                })
                .await;

            // Emit any remaining events in the window
            if !window.is_empty() {
                let window_event = Event::new(
                    "window",
                    "stream_engine",
                    EventData::Array(
                        window
                            .into_iter()
                            .map(|e| EventData::Object({
                                let mut map = HashMap::new();
                                map.insert("event".to_string(), EventData::Object({
                                    let mut inner_map = HashMap::new();
                                    inner_map.insert("id".to_string(), EventData::String(e.id.to_string()));
                                    inner_map.insert("type".to_string(), EventData::String(e.event_type));
                                    inner_map.insert("source".to_string(), EventData::String(e.source));
                                    inner_map.insert("timestamp".to_string(), EventData::String(e.timestamp.to_rfc3339()));
                                    inner_map.insert("data".to_string(), e.data);
                                    inner_map
                                }));
                                map
                            }))
                            .collect(),
                    ),
                );

                let _ = tx.send(Ok(window_event)).await;
            }
        });

        // Convert receiver to a stream
        Box::pin(tokio_stream::wrappers::ReceiverStream::new(rx))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>With these core components in place, we have the foundation of our stream processing system. Let’s now implement some concrete event sources and sinks that will allow our system to connect to the outside world.</p>
<h2 id="event-sources-and-sinks"><a class="header" href="#event-sources-and-sinks">Event Sources and Sinks</a></h2>
<p>Now that we have our core stream processing engine, let’s implement concrete source and sink adapters to connect our system to the outside world.</p>
<h3 id="file-based-sources-and-sinks"><a class="header" href="#file-based-sources-and-sinks">File-based Sources and Sinks</a></h3>
<p>Let’s start with file-based implementations that are useful for testing and development:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::{File, OpenOptions};
use std::io::{BufRead, BufReader, BufWriter, Write};
use std::path::Path;

/// A source that reads events from a file
pub struct FileSource {
    name: String,
    reader: BufReader&lt;File&gt;,
    path: String,
}

impl FileSource {
    /// Creates a new file source
    pub fn new(name: &amp;str, path: impl AsRef&lt;Path&gt;) -&gt; EventResult&lt;Self&gt; {
        let path_str = path.as_ref().to_string_lossy().to_string();
        let file = File::open(path.as_ref())?;
        let reader = BufReader::new(file);

        Ok(Self {
            name: name.to_string(),
            reader,
            path: path_str,
        })
    }
}

#[async_trait]
impl EventSource for FileSource {
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    async fn next(&amp;mut self) -&gt; EventResult&lt;Option&lt;Event&gt;&gt; {
        // Use tokio::task::spawn_blocking for file I/O
        let mut line = String::new();

        match tokio::task::spawn_blocking(move || {
            let mut temp_reader = &amp;self.reader;
            let bytes_read = temp_reader.read_line(&amp;mut line)?;

            if bytes_read == 0 {
                // End of file
                Ok(None)
            } else {
                // Remove trailing newline
                if line.ends_with('\n') {
                    line.pop();
                    if line.ends_with('\r') {
                        line.pop();
                    }
                }

                // Parse JSON
                let event: Event = serde_json::from_str(&amp;line)
                    .map_err(|e| EventError::Serialization(e.to_string()))?;

                Ok(Some(event))
            }
        }).await {
            Ok(result) =&gt; result,
            Err(e) =&gt; Err(EventError::Processing(e.to_string())),
        }
    }

    async fn commit(&amp;mut self) -&gt; EventResult&lt;()&gt; {
        // File source doesn't support commit
        Ok(())
    }
}

/// A sink that writes events to a file
pub struct FileSink {
    name: String,
    writer: BufWriter&lt;File&gt;,
    path: String,
}

impl FileSink {
    /// Creates a new file sink
    pub fn new(name: &amp;str, path: impl AsRef&lt;Path&gt;, append: bool) -&gt; EventResult&lt;Self&gt; {
        let path_str = path.as_ref().to_string_lossy().to_string();

        let file = OpenOptions::new()
            .write(true)
            .create(true)
            .append(append)
            .truncate(!append)
            .open(path.as_ref())?;

        let writer = BufWriter::new(file);

        Ok(Self {
            name: name.to_string(),
            writer,
            path: path_str,
        })
    }
}

#[async_trait]
impl EventSink for FileSink {
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    async fn write(&amp;mut self, event: &amp;Event) -&gt; EventResult&lt;()&gt; {
        // Serialize event to JSON
        let json = serde_json::to_string(event)
            .map_err(|e| EventError::Serialization(e.to_string()))?;

        // Use tokio::task::spawn_blocking for file I/O
        let mut writer = &amp;mut self.writer;
        let result = tokio::task::spawn_blocking(move || {
            writeln!(writer, "{}", json)?;
            Ok(())
        }).await;

        match result {
            Ok(inner) =&gt; inner,
            Err(e) =&gt; Err(EventError::Processing(e.to_string())),
        }
    }

    async fn flush(&amp;mut self) -&gt; EventResult&lt;()&gt; {
        let mut writer = &amp;mut self.writer;
        let result = tokio::task::spawn_blocking(move || {
            writer.flush()?;
            Ok(())
        }).await;

        match result {
            Ok(inner) =&gt; inner,
            Err(e) =&gt; Err(EventError::Processing(e.to_string())),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="network-sources-and-sinks"><a class="header" href="#network-sources-and-sinks">Network Sources and Sinks</a></h3>
<p>Let’s implement TCP-based sources and sinks for network communication:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader as TokioBufReader};
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::mpsc;
use std::net::SocketAddr;

/// A source that accepts events over TCP
pub struct TcpSource {
    name: String,
    rx: mpsc::Receiver&lt;EventResult&lt;Event&gt;&gt;,
    addr: SocketAddr,
}

impl TcpSource {
    /// Creates a new TCP source
    pub async fn new(name: &amp;str, addr: impl AsRef&lt;str&gt;) -&gt; EventResult&lt;Self&gt; {
        let socket_addr: SocketAddr = addr
            .as_ref()
            .parse()
            .map_err(|e| EventError::Connection(format!("Invalid address: {}", e)))?;

        let listener = TcpListener::bind(socket_addr)
            .await
            .map_err(|e| EventError::Connection(format!("Failed to bind: {}", e)))?;

        println!("TCP source listening on {}", socket_addr);

        // Channel for events
        let (tx, rx) = mpsc::channel(1000);

        // Spawn a task to accept connections
        tokio::spawn(async move {
            loop {
                match listener.accept().await {
                    Ok((socket, peer_addr)) =&gt; {
                        println!("New connection from {}", peer_addr);
                        let tx = tx.clone();

                        // Handle this connection
                        tokio::spawn(async move {
                            Self::handle_connection(socket, tx).await;
                        });
                    }
                    Err(e) =&gt; {
                        eprintln!("Error accepting connection: {}", e);
                    }
                }
            }
        });

        Ok(Self {
            name: name.to_string(),
            rx,
            addr: socket_addr,
        })
    }

    /// Handles a single client connection
    async fn handle_connection(socket: TcpStream, tx: mpsc::Sender&lt;EventResult&lt;Event&gt;&gt;) {
        let mut reader = TokioBufReader::new(socket);
        let mut line = String::new();

        loop {
            line.clear();

            match reader.read_line(&amp;mut line).await {
                Ok(0) =&gt; {
                    // Connection closed
                    break;
                }
                Ok(_) =&gt; {
                    // Parse JSON
                    match serde_json::from_str::&lt;Event&gt;(&amp;line) {
                        Ok(event) =&gt; {
                            if tx.send(Ok(event)).await.is_err() {
                                // Channel closed
                                break;
                            }
                        }
                        Err(e) =&gt; {
                            // Report parsing error
                            let err = EventError::Serialization(e.to_string());
                            if tx.send(Err(err)).await.is_err() {
                                // Channel closed
                                break;
                            }
                        }
                    }
                }
                Err(e) =&gt; {
                    // I/O error
                    let err = EventError::Io(e);
                    let _ = tx.send(Err(err)).await;
                    break;
                }
            }
        }
    }
}

#[async_trait]
impl EventSource for TcpSource {
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    async fn next(&amp;mut self) -&gt; EventResult&lt;Option&lt;Event&gt;&gt; {
        match self.rx.recv().await {
            Some(result) =&gt; result.map(Some),
            None =&gt; Ok(None), // Channel closed
        }
    }

    async fn commit(&amp;mut self) -&gt; EventResult&lt;()&gt; {
        // TCP source doesn't support commit
        Ok(())
    }
}

/// A sink that sends events over TCP
pub struct TcpSink {
    name: String,
    stream: TcpStream,
    addr: SocketAddr,
}

impl TcpSink {
    /// Creates a new TCP sink
    pub async fn new(name: &amp;str, addr: impl AsRef&lt;str&gt;) -&gt; EventResult&lt;Self&gt; {
        let socket_addr: SocketAddr = addr
            .as_ref()
            .parse()
            .map_err(|e| EventError::Connection(format!("Invalid address: {}", e)))?;

        let stream = TcpStream::connect(socket_addr)
            .await
            .map_err(|e| EventError::Connection(format!("Failed to connect: {}", e)))?;

        println!("Connected to TCP server at {}", socket_addr);

        Ok(Self {
            name: name.to_string(),
            stream,
            addr: socket_addr,
        })
    }
}

#[async_trait]
impl EventSink for TcpSink {
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    async fn write(&amp;mut self, event: &amp;Event) -&gt; EventResult&lt;()&gt; {
        // Serialize event to JSON
        let mut json = serde_json::to_string(event)
            .map_err(|e| EventError::Serialization(e.to_string()))?;

        // Add newline
        json.push('\n');

        // Write to socket
        self.stream.write_all(json.as_bytes()).await?;

        Ok(())
    }

    async fn flush(&amp;mut self) -&gt; EventResult&lt;()&gt; {
        self.stream.flush().await?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="kafka-integration"><a class="header" href="#kafka-integration">Kafka Integration</a></h3>
<p>For production systems, Apache Kafka is a popular choice for event streaming. Let’s implement Kafka source and sink adapters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rdkafka::config::ClientConfig;
use rdkafka::consumer::{Consumer, StreamConsumer};
use rdkafka::message::Message;
use rdkafka::producer::{FutureProducer, FutureRecord};
use std::time::Duration;

/// A source that consumes events from Kafka
pub struct KafkaSource {
    name: String,
    consumer: StreamConsumer,
    topic: String,
}

impl KafkaSource {
    /// Creates a new Kafka source
    pub fn new(
        name: &amp;str,
        brokers: &amp;str,
        topic: &amp;str,
        group_id: &amp;str,
    ) -&gt; EventResult&lt;Self&gt; {
        let consumer: StreamConsumer = ClientConfig::new()
            .set("bootstrap.servers", brokers)
            .set("group.id", group_id)
            .set("enable.auto.commit", "true")
            .set("auto.offset.reset", "earliest")
            .create()
            .map_err(|e| EventError::Connection(format!("Kafka consumer error: {}", e)))?;

        consumer
            .subscribe(&amp;[topic])
            .map_err(|e| EventError::Connection(format!("Kafka subscription error: {}", e)))?;

        println!("Subscribed to Kafka topic: {}", topic);

        Ok(Self {
            name: name.to_string(),
            consumer,
            topic: topic.to_string(),
        })
    }
}

#[async_trait]
impl EventSource for KafkaSource {
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    async fn next(&amp;mut self) -&gt; EventResult&lt;Option&lt;Event&gt;&gt; {
        // Wait for the next message
        match self.consumer.recv().await {
            Ok(msg) =&gt; {
                // Extract payload
                if let Some(payload) = msg.payload() {
                    // Parse as JSON
                    let event: Event = serde_json::from_slice(payload)
                        .map_err(|e| EventError::Serialization(format!("Kafka message parse error: {}", e)))?;

                    Ok(Some(event))
                } else {
                    Err(EventError::Processing("Empty Kafka message".to_string()))
                }
            }
            Err(e) =&gt; Err(EventError::Processing(format!("Kafka consumer error: {}", e))),
        }
    }

    async fn commit(&amp;mut self) -&gt; EventResult&lt;()&gt; {
        // Auto-commit is enabled
        Ok(())
    }
}

/// A sink that produces events to Kafka
pub struct KafkaSink {
    name: String,
    producer: FutureProducer,
    topic: String,
}

impl KafkaSink {
    /// Creates a new Kafka sink
    pub fn new(name: &amp;str, brokers: &amp;str, topic: &amp;str) -&gt; EventResult&lt;Self&gt; {
        let producer: FutureProducer = ClientConfig::new()
            .set("bootstrap.servers", brokers)
            .set("message.timeout.ms", "5000")
            .create()
            .map_err(|e| EventError::Connection(format!("Kafka producer error: {}", e)))?;

        println!("Connected to Kafka for topic: {}", topic);

        Ok(Self {
            name: name.to_string(),
            producer,
            topic: topic.to_string(),
        })
    }
}

#[async_trait]
impl EventSink for KafkaSink {
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    async fn write(&amp;mut self, event: &amp;Event) -&gt; EventResult&lt;()&gt; {
        // Serialize event to JSON
        let payload = serde_json::to_vec(event)
            .map_err(|e| EventError::Serialization(e.to_string()))?;

        // Use event ID as key
        let key = event.id.to_string();

        // Send to Kafka
        let record = FutureRecord::to(&amp;self.topic)
            .key(&amp;key)
            .payload(&amp;payload);

        let result = self.producer.send(record, Duration::from_secs(5)).await;

        match result {
            Ok(_) =&gt; Ok(()),
            Err((e, _)) =&gt; Err(EventError::Processing(format!("Kafka send error: {}", e))),
        }
    }

    async fn flush(&amp;mut self) -&gt; EventResult&lt;()&gt; {
        // Flush is implicit with FutureProducer
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="http-webhook-sink"><a class="header" href="#http-webhook-sink">HTTP Webhook Sink</a></h3>
<p>Let’s also implement an HTTP webhook sink for sending events to web services:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reqwest::{Client, StatusCode};

/// A sink that sends events to an HTTP endpoint
pub struct WebhookSink {
    name: String,
    client: Client,
    url: String,
    headers: HashMap&lt;String, String&gt;,
}

impl WebhookSink {
    /// Creates a new webhook sink
    pub fn new(name: &amp;str, url: &amp;str) -&gt; EventResult&lt;Self&gt; {
        let client = Client::new();

        Ok(Self {
            name: name.to_string(),
            client,
            url: url.to_string(),
            headers: HashMap::new(),
        })
    }

    /// Adds a header to the HTTP request
    pub fn with_header(mut self, key: &amp;str, value: &amp;str) -&gt; Self {
        self.headers.insert(key.to_string(), value.to_string());
        self
    }
}

#[async_trait]
impl EventSink for WebhookSink {
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    async fn write(&amp;mut self, event: &amp;Event) -&gt; EventResult&lt;()&gt; {
        // Build request
        let mut request = self.client.post(&amp;self.url);

        // Add headers
        for (key, value) in &amp;self.headers {
            request = request.header(key, value);
        }

        // Send event as JSON
        let response = request
            .json(event)
            .send()
            .await
            .map_err(|e| EventError::Connection(format!("HTTP request failed: {}", e)))?;

        // Check status
        let status = response.status();
        if status != StatusCode::OK &amp;&amp; status != StatusCode::CREATED &amp;&amp; status != StatusCode::ACCEPTED {
            return Err(EventError::Processing(format!(
                "HTTP request returned non-success status: {}", status
            )));
        }

        Ok(())
    }

    async fn flush(&amp;mut self) -&gt; EventResult&lt;()&gt; {
        // No buffering in webhook sink
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>With these sources and sinks, our RustStream system can connect to various external systems, making it useful in real-world scenarios. In the next section, we’ll build the analytics engine that will process the streaming data to derive insights.</p>
<h2 id="analytics-engine"><a class="header" href="#analytics-engine">Analytics Engine</a></h2>
<p>With our core stream processing engine and adapters in place, let’s build a real-time analytics engine that can derive insights from streaming data. This will include metrics calculation, anomaly detection, and pattern recognition.</p>
<h3 id="metrics-and-aggregations"><a class="header" href="#metrics-and-aggregations">Metrics and Aggregations</a></h3>
<p>First, let’s create a framework for calculating metrics over streaming data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::{HashMap, VecDeque};
use std::fmt;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::RwLock;

/// A metric value
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum MetricValue {
    /// Count value
    Count(u64),
    /// Gauge value
    Gauge(f64),
    /// Timer value (in milliseconds)
    Timer(f64),
}

impl fmt::Display for MetricValue {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            MetricValue::Count(v) =&gt; write!(f, "{}", v),
            MetricValue::Gauge(v) =&gt; write!(f, "{:.2}", v),
            MetricValue::Timer(v) =&gt; write!(f, "{:.2}ms", v),
        }
    }
}

/// A named metric with metadata
#[derive(Debug, Clone)]
pub struct Metric {
    /// Metric name
    pub name: String,
    /// Current value
    pub value: MetricValue,
    /// Tags for this metric
    pub tags: HashMap&lt;String, String&gt;,
    /// Last update time
    pub updated_at: Instant,
}

impl Metric {
    /// Creates a new metric
    pub fn new(name: &amp;str, value: MetricValue) -&gt; Self {
        Self {
            name: name.to_string(),
            value,
            tags: HashMap::new(),
            updated_at: Instant::now(),
        }
    }

    /// Adds a tag to the metric
    pub fn with_tag(mut self, key: &amp;str, value: &amp;str) -&gt; Self {
        self.tags.insert(key.to_string(), value.to_string());
        self
    }
}

/// Repository for storing and querying metrics
pub struct MetricsRepository {
    /// Current metrics
    metrics: HashMap&lt;String, Metric&gt;,
    /// Historical values (time series)
    history: HashMap&lt;String, VecDeque&lt;(Instant, MetricValue)&gt;&gt;,
    /// Maximum history length
    max_history: usize,
}

impl MetricsRepository {
    /// Creates a new metrics repository
    pub fn new(max_history: usize) -&gt; Self {
        Self {
            metrics: HashMap::new(),
            history: HashMap::new(),
            max_history,
        }
    }

    /// Updates a metric
    pub fn update(&amp;mut self, metric: Metric) {
        // Update current value
        let key = Self::metric_key(&amp;metric);
        self.metrics.insert(key.clone(), metric.clone());

        // Update history
        let history = self.history.entry(key).or_insert_with(VecDeque::new);
        history.push_back((metric.updated_at, metric.value));

        // Trim history if needed
        while history.len() &gt; self.max_history {
            history.pop_front();
        }
    }

    /// Gets a metric by name and tags
    pub fn get(&amp;self, name: &amp;str, tags: &amp;HashMap&lt;String, String&gt;) -&gt; Option&lt;&amp;Metric&gt; {
        let key = Self::key(name, tags);
        self.metrics.get(&amp;key)
    }

    /// Gets the history of a metric
    pub fn get_history(
        &amp;self,
        name: &amp;str,
        tags: &amp;HashMap&lt;String, String&gt;,
    ) -&gt; Option&lt;&amp;VecDeque&lt;(Instant, MetricValue)&gt;&gt; {
        let key = Self::key(name, tags);
        self.history.get(&amp;key)
    }

    /// Gets all metrics
    pub fn get_all(&amp;self) -&gt; impl Iterator&lt;Item = &amp;Metric&gt; {
        self.metrics.values()
    }

    /// Generates a unique key for a metric
    fn metric_key(metric: &amp;Metric) -&gt; String {
        Self::key(&amp;metric.name, &amp;metric.tags)
    }

    /// Generates a unique key from name and tags
    fn key(name: &amp;str, tags: &amp;HashMap&lt;String, String&gt;) -&gt; String {
        let mut parts = vec![name.to_string()];

        let mut tag_pairs: Vec&lt;_&gt; = tags.iter().collect();
        tag_pairs.sort_by_key(|k| k.0);

        for (k, v) in tag_pairs {
            parts.push(format!("{}={}", k, v));
        }

        parts.join(";")
    }
}

/// Shared metrics repository that can be accessed from multiple threads
pub type SharedMetricsRepository = Arc&lt;RwLock&lt;MetricsRepository&gt;&gt;;

/// Creates a new shared metrics repository
pub fn create_metrics_repository(max_history: usize) -&gt; SharedMetricsRepository {
    Arc::new(RwLock::new(MetricsRepository::new(max_history)))
}

/// Operator that calculates metrics from events
pub struct MetricsOperator {
    name: String,
    repository: SharedMetricsRepository,
    calculators: Vec&lt;Box&lt;dyn MetricCalculator&gt;&gt;,
}

/// Trait for calculating metrics from events
#[async_trait]
pub trait MetricCalculator: Send + Sync {
    /// Calculates metrics from an event
    async fn calculate(&amp;self, event: &amp;Event) -&gt; Vec&lt;Metric&gt;;
}

impl MetricsOperator {
    /// Creates a new metrics operator
    pub fn new(name: &amp;str, repository: SharedMetricsRepository) -&gt; Self {
        Self {
            name: name.to_string(),
            repository,
            calculators: Vec::new(),
        }
    }

    /// Adds a metric calculator
    pub fn add_calculator&lt;C&gt;(&amp;mut self, calculator: C) -&gt; &amp;mut Self
    where
        C: MetricCalculator + 'static,
    {
        self.calculators.push(Box::new(calculator));
        self
    }
}

#[async_trait]
impl Operator for MetricsOperator {
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    async fn apply(&amp;self, input: EventStream) -&gt; EventStream {
        let repository = self.repository.clone();
        let calculators = self.calculators.clone();

        Box::pin(input.then(move |result| {
            let repository = repository.clone();
            let calculators = calculators.clone();

            async move {
                if let Ok(event) = &amp;result {
                    // Calculate metrics
                    for calculator in &amp;calculators {
                        let metrics = calculator.calculate(event).await;

                        // Update repository
                        let mut repo = repository.write().await;
                        for metric in metrics {
                            repo.update(metric);
                        }
                    }
                }

                // Pass the event through unchanged
                result
            }
        }))
    }
}

/// Calculator for count metrics
pub struct CountMetricCalculator {
    name: String,
    filter: Box&lt;dyn Fn(&amp;Event) -&gt; bool + Send + Sync&gt;,
    dimensions: Vec&lt;String&gt;,
}

impl CountMetricCalculator {
    /// Creates a new count metric calculator
    pub fn new&lt;F&gt;(name: &amp;str, filter: F) -&gt; Self
    where
        F: Fn(&amp;Event) -&gt; bool + Send + Sync + 'static,
    {
        Self {
            name: name.to_string(),
            filter: Box::new(filter),
            dimensions: Vec::new(),
        }
    }

    /// Adds a dimension for grouping
    pub fn with_dimension(mut self, dimension: &amp;str) -&gt; Self {
        self.dimensions.push(dimension.to_string());
        self
    }
}

#[async_trait]
impl MetricCalculator for CountMetricCalculator {
    async fn calculate(&amp;self, event: &amp;Event) -&gt; Vec&lt;Metric&gt; {
        if !(self.filter)(event) {
            return Vec::new();
        }

        // Extract dimension values
        let mut tags = HashMap::new();
        for dim in &amp;self.dimensions {
            if let Some(value) = Self::extract_dimension(event, dim) {
                tags.insert(dim.clone(), value);
            }
        }

        // Create metric
        vec![Metric::new(&amp;self.name, MetricValue::Count(1))
            .with_tag("event_type", &amp;event.event_type)]
    }
}

impl CountMetricCalculator {
    /// Extracts a dimension value from an event
    fn extract_dimension(event: &amp;Event, dimension: &amp;str) -&gt; Option&lt;String&gt; {
        // Try to extract from metadata
        if let Some(value) = event.metadata.get(dimension) {
            return Some(value.clone());
        }

        // Try to extract from event type
        if dimension == "event_type" {
            return Some(event.event_type.clone());
        }

        // Try to extract from event source
        if dimension == "source" {
            return Some(event.source.clone());
        }

        // Try to extract from data
        match &amp;event.data {
            EventData::Object(obj) =&gt; {
                if let Some(value) = obj.get(dimension) {
                    return match value {
                        EventData::String(s) =&gt; Some(s.clone()),
                        EventData::Number(n) =&gt; Some(n.to_string()),
                        EventData::Bool(b) =&gt; Some(b.to_string()),
                        _ =&gt; None,
                    };
                }
            }
            _ =&gt; {}
        }

        None
    }
}

/// Calculator for gauge metrics
pub struct GaugeMetricCalculator {
    name: String,
    extractor: Box&lt;dyn Fn(&amp;Event) -&gt; Option&lt;f64&gt; + Send + Sync&gt;,
    dimensions: Vec&lt;String&gt;,
}

impl GaugeMetricCalculator {
    /// Creates a new gauge metric calculator
    pub fn new&lt;F&gt;(name: &amp;str, extractor: F) -&gt; Self
    where
        F: Fn(&amp;Event) -&gt; Option&lt;f64&gt; + Send + Sync + 'static,
    {
        Self {
            name: name.to_string(),
            extractor: Box::new(extractor),
            dimensions: Vec::new(),
        }
    }

    /// Adds a dimension for grouping
    pub fn with_dimension(mut self, dimension: &amp;str) -&gt; Self {
        self.dimensions.push(dimension.to_string());
        self
    }
}

#[async_trait]
impl MetricCalculator for GaugeMetricCalculator {
    async fn calculate(&amp;self, event: &amp;Event) -&gt; Vec&lt;Metric&gt; {
        if let Some(value) = (self.extractor)(event) {
            // Extract dimension values
            let mut tags = HashMap::new();
            for dim in &amp;self.dimensions {
                if let Some(dim_value) = CountMetricCalculator::extract_dimension(event, dim) {
                    tags.insert(dim.clone(), dim_value);
                }
            }

            // Create metric
            vec![Metric::new(&amp;self.name, MetricValue::Gauge(value))
                .with_tag("event_type", &amp;event.event_type)]
        } else {
            Vec::new()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="anomaly-detection"><a class="header" href="#anomaly-detection">Anomaly Detection</a></h3>
<p>Now let’s implement an anomaly detection system that can identify unusual patterns in the data stream:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Types of anomaly detection algorithms
pub enum AnomalyDetectionAlgorithm {
    /// Z-score detection (based on standard deviation)
    ZScore { threshold: f64 },
    /// Moving average with tolerance
    MovingAverage { window_size: usize, tolerance: f64 },
    /// Rate of change detection
    RateOfChange { max_rate: f64 },
}

/// Anomaly detector for a specific metric
pub struct AnomalyDetector {
    name: String,
    metric_name: String,
    metric_tags: HashMap&lt;String, String&gt;,
    algorithm: AnomalyDetectionAlgorithm,
    repository: SharedMetricsRepository,
}

impl AnomalyDetector {
    /// Creates a new anomaly detector
    pub fn new(
        name: &amp;str,
        metric_name: &amp;str,
        repository: SharedMetricsRepository,
        algorithm: AnomalyDetectionAlgorithm,
    ) -&gt; Self {
        Self {
            name: name.to_string(),
            metric_name: metric_name.to_string(),
            metric_tags: HashMap::new(),
            algorithm,
            repository,
        }
    }

    /// Adds a tag filter
    pub fn with_tag(mut self, key: &amp;str, value: &amp;str) -&gt; Self {
        self.metric_tags.insert(key.to_string(), value.to_string());
        self
    }

    /// Checks for anomalies
    pub async fn check(&amp;self) -&gt; Option&lt;AnomalyEvent&gt; {
        let repo = self.repository.read().await;

        // Get metric history
        let history = match repo.get_history(&amp;self.metric_name, &amp;self.metric_tags) {
            Some(h) =&gt; h,
            None =&gt; return None,
        };

        // Need at least two points for most algorithms
        if history.len() &lt; 2 {
            return None;
        }

        // Extract values
        let values: Vec&lt;f64&gt; = history
            .iter()
            .filter_map(|(_, v)| match v {
                MetricValue::Gauge(f) =&gt; Some(*f),
                MetricValue::Count(c) =&gt; Some(*c as f64),
                MetricValue::Timer(t) =&gt; Some(*t),
            })
            .collect();

        // Current value
        let current = *values.last().unwrap();

        // Check for anomaly based on algorithm
        let is_anomaly = match &amp;self.algorithm {
            AnomalyDetectionAlgorithm::ZScore { threshold } =&gt; {
                // Calculate mean and standard deviation
                let mean = values.iter().sum::&lt;f64&gt;() / values.len() as f64;
                let variance = values
                    .iter()
                    .map(|x| (*x - mean).powi(2))
                    .sum::&lt;f64&gt;()
                    / values.len() as f64;
                let std_dev = variance.sqrt();

                // Z-score
                if std_dev &gt; 0.0 {
                    let z_score = (current - mean) / std_dev;
                    z_score.abs() &gt; *threshold
                } else {
                    false
                }
            }
            AnomalyDetectionAlgorithm::MovingAverage {
                window_size,
                tolerance,
            } =&gt; {
                // Calculate moving average
                let window = values.len().min(*window_size);
                let moving_avg = values[values.len() - window..].iter().sum::&lt;f64&gt;() / window as f64;

                // Check if current value deviates from moving average
                (current - moving_avg).abs() &gt; *tolerance
            }
            AnomalyDetectionAlgorithm::RateOfChange { max_rate } =&gt; {
                // Calculate rate of change
                let previous = values[values.len() - 2];
                if previous != 0.0 {
                    let rate = (current - previous).abs() / previous;
                    rate &gt; *max_rate
                } else {
                    false
                }
            }
        };

        if is_anomaly {
            // Create anomaly event
            Some(AnomalyEvent {
                detector_name: self.name.clone(),
                metric_name: self.metric_name.clone(),
                metric_tags: self.metric_tags.clone(),
                current_value: current,
                timestamp: Instant::now(),
            })
        } else {
            None
        }
    }
}

/// An anomaly detected in the metrics
#[derive(Debug, Clone)]
pub struct AnomalyEvent {
    /// Name of the detector that found this anomaly
    pub detector_name: String,
    /// Name of the metric with the anomaly
    pub metric_name: String,
    /// Tags of the metric with the anomaly
    pub metric_tags: HashMap&lt;String, String&gt;,
    /// Current value that triggered the anomaly
    pub current_value: f64,
    /// When the anomaly was detected
    pub timestamp: Instant,
}

/// Service that manages anomaly detectors
pub struct AnomalyDetectionService {
    detectors: Vec&lt;AnomalyDetector&gt;,
    check_interval: Duration,
    alert_sink: Option&lt;Box&lt;dyn AlertSink&gt;&gt;,
}

impl AnomalyDetectionService {
    /// Creates a new anomaly detection service
    pub fn new(check_interval: Duration) -&gt; Self {
        Self {
            detectors: Vec::new(),
            check_interval,
            alert_sink: None,
        }
    }

    /// Adds an anomaly detector
    pub fn add_detector(&amp;mut self, detector: AnomalyDetector) -&gt; &amp;mut Self {
        self.detectors.push(detector);
        self
    }

    /// Sets the alert sink
    pub fn set_alert_sink&lt;S&gt;(&amp;mut self, sink: S) -&gt; &amp;mut Self
    where
        S: AlertSink + 'static,
    {
        self.alert_sink = Some(Box::new(sink));
        self
    }

    /// Starts the anomaly detection service
    pub async fn start(&amp;self) -&gt; EventResult&lt;()&gt; {
        let detectors = self.detectors.clone();
        let check_interval = self.check_interval;
        let alert_sink = self.alert_sink.clone();

        tokio::spawn(async move {
            let mut interval = tokio::time::interval(check_interval);

            loop {
                interval.tick().await;

                // Check all detectors
                for detector in &amp;detectors {
                    if let Some(anomaly) = detector.check().await {
                        println!("Anomaly detected: {:?}", anomaly);

                        // Send alert if sink is configured
                        if let Some(sink) = &amp;alert_sink {
                            if let Err(e) = sink.send_alert(&amp;anomaly).await {
                                eprintln!("Error sending alert: {}", e);
                            }
                        }
                    }
                }
            }
        });

        Ok(())
    }
}

/// Sink for anomaly alerts
#[async_trait]
pub trait AlertSink: Send + Sync {
    /// Sends an alert for an anomaly
    async fn send_alert(&amp;self, anomaly: &amp;AnomalyEvent) -&gt; EventResult&lt;()&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-recognition"><a class="header" href="#pattern-recognition">Pattern Recognition</a></h3>
<p>Finally, let’s implement a simple pattern recognition system using the Complex Event Processing (CEP) approach:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A pattern to match in the event stream
pub struct Pattern {
    /// Name of this pattern
    name: String,
    /// Sequence of event conditions to match
    conditions: Vec&lt;Box&lt;dyn EventCondition&gt;&gt;,
    /// Maximum time window for matching the pattern
    window: Duration,
}

/// Condition that an event must satisfy
#[async_trait]
pub trait EventCondition: Send + Sync {
    /// Checks if an event satisfies this condition
    async fn matches(&amp;self, event: &amp;Event) -&gt; bool;
}

/// Condition based on event type
pub struct EventTypeCondition {
    /// Expected event type
    event_type: String,
}

impl EventTypeCondition {
    /// Creates a new event type condition
    pub fn new(event_type: &amp;str) -&gt; Self {
        Self {
            event_type: event_type.to_string(),
        }
    }
}

#[async_trait]
impl EventCondition for EventTypeCondition {
    async fn matches(&amp;self, event: &amp;Event) -&gt; bool {
        event.event_type == self.event_type
    }
}

/// Condition based on event data
pub struct EventDataCondition&lt;F&gt; {
    /// Predicate function
    predicate: F,
}

impl&lt;F&gt; EventDataCondition&lt;F&gt;
where
    F: Fn(&amp;EventData) -&gt; bool + Send + Sync + 'static,
{
    /// Creates a new event data condition
    pub fn new(predicate: F) -&gt; Self {
        Self { predicate }
    }
}

#[async_trait]
impl&lt;F&gt; EventCondition for EventDataCondition&lt;F&gt;
where
    F: Fn(&amp;EventData) -&gt; bool + Send + Sync + 'static,
{
    async fn matches(&amp;self, event: &amp;Event) -&gt; bool {
        (self.predicate)(&amp;event.data)
    }
}

impl Pattern {
    /// Creates a new pattern
    pub fn new(name: &amp;str, window: Duration) -&gt; Self {
        Self {
            name: name.to_string(),
            conditions: Vec::new(),
            window,
        }
    }

    /// Adds a condition to the pattern
    pub fn add_condition&lt;C&gt;(&amp;mut self, condition: C) -&gt; &amp;mut Self
    where
        C: EventCondition + 'static,
    {
        self.conditions.push(Box::new(condition));
        self
    }
}

/// Pattern matching engine
pub struct PatternMatcher {
    name: String,
    patterns: Vec&lt;Pattern&gt;,
    partial_matches: Vec&lt;PartialMatch&gt;,
}

/// A partial match of a pattern
struct PartialMatch {
    /// Pattern being matched
    pattern: Pattern,
    /// Matched events so far
    events: Vec&lt;Event&gt;,
    /// When the first event was matched
    start_time: Instant,
    /// Index of the next condition to match
    next_index: usize,
}

/// Result of a completed pattern match
#[derive(Debug, Clone)]
pub struct PatternMatch {
    /// Name of the matched pattern
    pub pattern_name: String,
    /// Events that matched the pattern
    pub events: Vec&lt;Event&gt;,
    /// When the pattern started matching
    pub start_time: Instant,
    /// When the pattern completed matching
    pub end_time: Instant,
}

impl PatternMatcher {
    /// Creates a new pattern matcher
    pub fn new(name: &amp;str) -&gt; Self {
        Self {
            name: name.to_string(),
            patterns: Vec::new(),
            partial_matches: Vec::new(),
        }
    }

    /// Adds a pattern to match
    pub fn add_pattern(&amp;mut self, pattern: Pattern) -&gt; &amp;mut Self {
        self.patterns.push(pattern);
        self
    }

    /// Processes an event and returns any completed pattern matches
    pub async fn process(&amp;mut self, event: &amp;Event) -&gt; Vec&lt;PatternMatch&gt; {
        let mut completed_matches = Vec::new();

        // Check for expired partial matches
        let now = Instant::now();
        self.partial_matches.retain(|m| {
            now.duration_since(m.start_time) &lt;= m.pattern.window
        });

        // Check if this event continues any partial matches
        for i in (0..self.partial_matches.len()).rev() {
            let partial = &amp;mut self.partial_matches[i];

            if partial.next_index &lt; partial.pattern.conditions.len() {
                let condition = &amp;partial.pattern.conditions[partial.next_index];

                if condition.matches(event).await {
                    // This event matches the next condition
                    partial.events.push(event.clone());
                    partial.next_index += 1;

                    // Check if pattern is complete
                    if partial.next_index &gt;= partial.pattern.conditions.len() {
                        // Complete match
                        completed_matches.push(PatternMatch {
                            pattern_name: partial.pattern.name.clone(),
                            events: partial.events.clone(),
                            start_time: partial.start_time,
                            end_time: now,
                        });

                        // Remove the completed match
                        self.partial_matches.swap_remove(i);
                    }
                }
            }
        }

        // Check if this event starts any new patterns
        for pattern in &amp;self.patterns {
            if !pattern.conditions.is_empty() {
                let first_condition = &amp;pattern.conditions[0];

                if first_condition.matches(event).await {
                    // Start a new partial match
                    let partial = PartialMatch {
                        pattern: pattern.clone(),
                        events: vec![event.clone()],
                        start_time: now,
                        next_index: 1,
                    };

                    // Check if pattern is already complete (single condition)
                    if partial.next_index &gt;= partial.pattern.conditions.len() {
                        // Complete match
                        completed_matches.push(PatternMatch {
                            pattern_name: partial.pattern.name.clone(),
                            events: partial.events.clone(),
                            start_time: partial.start_time,
                            end_time: now,
                        });
                    } else {
                        // Partial match
                        self.partial_matches.push(partial);
                    }
                }
            }
        }

        completed_matches
    }
}

/// Operator that matches patterns in the event stream
pub struct PatternMatchingOperator {
    name: String,
    matcher: Arc&lt;Mutex&lt;PatternMatcher&gt;&gt;,
}

impl PatternMatchingOperator {
    /// Creates a new pattern matching operator
    pub fn new(name: &amp;str, matcher: PatternMatcher) -&gt; Self {
        Self {
            name: name.to_string(),
            matcher: Arc::new(Mutex::new(matcher)),
        }
    }
}

#[async_trait]
impl Operator for PatternMatchingOperator {
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    async fn apply(&amp;self, input: EventStream) -&gt; EventStream {
        let matcher = self.matcher.clone();

        Box::pin(input.then(move |result| {
            let matcher = matcher.clone();

            async move {
                if let Ok(event) = &amp;result {
                    // Process event
                    let mut matcher_guard = matcher.lock().await;
                    let matches = matcher_guard.process(event).await;

                    // Emit a pattern match event for each match
                    if !matches.is_empty() {
                        // In a real implementation, we would emit these as new events
                        for m in &amp;matches {
                            println!("Pattern matched: {} with {} events", m.pattern_name, m.events.len());
                        }
                    }
                }

                // Pass the original event through
                result
            }
        }))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>With these components, our analytics engine can calculate metrics, detect anomalies, and recognize patterns in real-time data streams. This provides the foundation for deriving actionable insights from the data flowing through our system.</p>
<p>In the next section, we’ll build an alerting system to notify users when important conditions are detected.</p>
<h2 id="alerting-system"><a class="header" href="#alerting-system">Alerting System</a></h2>
<p>Now that our system can detect anomalies and recognize patterns, we need a way to alert users when significant events occur. Let’s build a flexible alerting system that can integrate with various notification channels.</p>
<h3 id="alert-model"><a class="header" href="#alert-model">Alert Model</a></h3>
<p>First, let’s define our alert data model:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

/// Alert severity levels
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum AlertSeverity {
    /// Informational alert
    Info,
    /// Warning alert
    Warning,
    /// Error alert
    Error,
    /// Critical alert
    Critical,
}

impl fmt::Display for AlertSeverity {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            AlertSeverity::Info =&gt; write!(f, "INFO"),
            AlertSeverity::Warning =&gt; write!(f, "WARNING"),
            AlertSeverity::Error =&gt; write!(f, "ERROR"),
            AlertSeverity::Critical =&gt; write!(f, "CRITICAL"),
        }
    }
}

/// An alert generated by the system
#[derive(Debug, Clone)]
pub struct Alert {
    /// Unique identifier
    pub id: Uuid,
    /// Alert title
    pub title: String,
    /// Alert description
    pub description: String,
    /// Alert severity
    pub severity: AlertSeverity,
    /// When the alert was generated
    pub timestamp: DateTime&lt;Utc&gt;,
    /// Source of the alert
    pub source: String,
    /// Additional tags
    pub tags: HashMap&lt;String, String&gt;,
    /// Related events
    pub events: Vec&lt;Event&gt;,
}

impl Alert {
    /// Creates a new alert
    pub fn new(title: &amp;str, description: &amp;str, severity: AlertSeverity, source: &amp;str) -&gt; Self {
        Self {
            id: Uuid::new_v4(),
            title: title.to_string(),
            description: description.to_string(),
            severity,
            timestamp: Utc::now(),
            source: source.to_string(),
            tags: HashMap::new(),
            events: Vec::new(),
        }
    }

    /// Adds a tag to the alert
    pub fn with_tag(mut self, key: &amp;str, value: &amp;str) -&gt; Self {
        self.tags.insert(key.to_string(), value.to_string());
        self
    }

    /// Adds an event to the alert
    pub fn with_event(mut self, event: Event) -&gt; Self {
        self.events.push(event);
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="alert-manager"><a class="header" href="#alert-manager">Alert Manager</a></h3>
<p>Next, let’s create an alert manager to handle alert routing, deduplication, and throttling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Routes alerts to notification channels
pub struct AlertManager {
    /// Name of this alert manager
    name: String,
    /// Notification channels
    channels: Vec&lt;Box&lt;dyn NotificationChannel&gt;&gt;,
    /// Alert history (for deduplication)
    history: HashMap&lt;String, Vec&lt;(DateTime&lt;Utc&gt;, Uuid)&gt;&gt;,
    /// Maximum history size per alert key
    max_history: usize,
    /// Minimum interval between similar alerts
    throttle_interval: Option&lt;Duration&gt;,
}

/// A channel for sending notifications
#[async_trait]
pub trait NotificationChannel: Send + Sync {
    /// Returns the name of this channel
    fn name(&amp;self) -&gt; &amp;str;

    /// Sends an alert notification
    async fn send(&amp;self, alert: &amp;Alert) -&gt; EventResult&lt;()&gt;;
}

impl AlertManager {
    /// Creates a new alert manager
    pub fn new(name: &amp;str) -&gt; Self {
        Self {
            name: name.to_string(),
            channels: Vec::new(),
            history: HashMap::new(),
            max_history: 100,
            throttle_interval: None,
        }
    }

    /// Adds a notification channel
    pub fn add_channel&lt;C&gt;(&amp;mut self, channel: C) -&gt; &amp;mut Self
    where
        C: NotificationChannel + 'static,
    {
        self.channels.push(Box::new(channel));
        self
    }

    /// Sets the throttle interval
    pub fn with_throttle(mut self, interval: Duration) -&gt; Self {
        self.throttle_interval = Some(interval);
        self
    }

    /// Sends an alert through all channels
    pub async fn send_alert(&amp;mut self, alert: Alert) -&gt; EventResult&lt;()&gt; {
        // Create alert key for deduplication
        let key = self.alert_key(&amp;alert);

        // Check for duplicate/throttled alerts
        if let Some(interval) = self.throttle_interval {
            if let Some(history) = self.history.get(&amp;key) {
                if !history.is_empty() {
                    let (last_time, _) = history.last().unwrap();
                    let now = Utc::now();
                    let elapsed = now.signed_duration_since(*last_time);

                    if elapsed &lt; chrono::Duration::from_std(interval).unwrap() {
                        // Skip this alert (throttled)
                        return Ok(());
                    }
                }
            }
        }

        // Add to history
        let entry = self.history.entry(key).or_insert_with(Vec::new);
        entry.push((alert.timestamp, alert.id));

        // Trim history if needed
        while entry.len() &gt; self.max_history {
            entry.remove(0);
        }

        // Send to all channels
        for channel in &amp;self.channels {
            if let Err(e) = channel.send(&amp;alert).await {
                eprintln!("Error sending alert to channel {}: {}", channel.name(), e);
            }
        }

        Ok(())
    }

    /// Generates a key for alert deduplication
    fn alert_key(&amp;self, alert: &amp;Alert) -&gt; String {
        format!("{}:{}", alert.source, alert.title)
    }
}

/// Implementation of AlertSink for the anomaly detection service
pub struct AnomalyAlertSink {
    alert_manager: Arc&lt;Mutex&lt;AlertManager&gt;&gt;,
}

impl AnomalyAlertSink {
    /// Creates a new anomaly alert sink
    pub fn new(alert_manager: Arc&lt;Mutex&lt;AlertManager&gt;&gt;) -&gt; Self {
        Self { alert_manager }
    }
}

#[async_trait]
impl AlertSink for AnomalyAlertSink {
    async fn send_alert(&amp;self, anomaly: &amp;AnomalyEvent) -&gt; EventResult&lt;()&gt; {
        // Create an alert from the anomaly
        let alert = Alert::new(
            &amp;format!("Anomaly detected in metric '{}'", anomaly.metric_name),
            &amp;format!(
                "The metric '{}' has an anomalous value of {}",
                anomaly.metric_name, anomaly.current_value
            ),
            AlertSeverity::Warning,
            "anomaly_detector",
        );

        // Send the alert
        let mut manager = self.alert_manager.lock().await;
        manager.send_alert(alert).await
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="notification-channels"><a class="header" href="#notification-channels">Notification Channels</a></h3>
<p>Let’s implement several notification channels for different delivery methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Sends email notifications
pub struct EmailChannel {
    name: String,
    smtp_server: String,
    smtp_port: u16,
    username: String,
    password: String,
    from_address: String,
    to_addresses: Vec&lt;String&gt;,
}

impl EmailChannel {
    /// Creates a new email channel
    pub fn new(
        name: &amp;str,
        smtp_server: &amp;str,
        smtp_port: u16,
        username: &amp;str,
        password: &amp;str,
        from_address: &amp;str,
    ) -&gt; Self {
        Self {
            name: name.to_string(),
            smtp_server: smtp_server.to_string(),
            smtp_port,
            username: username.to_string(),
            password: password.to_string(),
            from_address: from_address.to_string(),
            to_addresses: Vec::new(),
        }
    }

    /// Adds a recipient email address
    pub fn add_recipient(mut self, email: &amp;str) -&gt; Self {
        self.to_addresses.push(email.to_string());
        self
    }
}

#[async_trait]
impl NotificationChannel for EmailChannel {
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    async fn send(&amp;self, alert: &amp;Alert) -&gt; EventResult&lt;()&gt; {
        // In a real implementation, we would use an SMTP client
        // This is a simplified example
        println!(
            "Sending email alert '{}' to {} recipients",
            alert.title,
            self.to_addresses.len()
        );

        // Create email content
        let subject = format!("[{}] {}", alert.severity, alert.title);
        let body = format!(
            "Alert: {}\nSeverity: {}\nTime: {}\nSource: {}\n\n{}",
            alert.title, alert.severity, alert.timestamp, alert.source, alert.description
        );

        // Simulate sending
        tokio::time::sleep(Duration::from_millis(100)).await;

        Ok(())
    }
}

/// Sends Slack notifications
pub struct SlackChannel {
    name: String,
    webhook_url: String,
}

impl SlackChannel {
    /// Creates a new Slack channel
    pub fn new(name: &amp;str, webhook_url: &amp;str) -&gt; Self {
        Self {
            name: name.to_string(),
            webhook_url: webhook_url.to_string(),
        }
    }
}

#[async_trait]
impl NotificationChannel for SlackChannel {
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    async fn send(&amp;self, alert: &amp;Alert) -&gt; EventResult&lt;()&gt; {
        // In a real implementation, we would use the Slack API
        // This is a simplified example
        println!("Sending Slack alert: {}", alert.title);

        // Create Slack message
        let emoji = match alert.severity {
            AlertSeverity::Info =&gt; ":information_source:",
            AlertSeverity::Warning =&gt; ":warning:",
            AlertSeverity::Error =&gt; ":x:",
            AlertSeverity::Critical =&gt; ":rotating_light:",
        };

        let message = json!({
            "text": format!("{} *{}*", emoji, alert.title),
            "attachments": [{
                "color": match alert.severity {
                    AlertSeverity::Info =&gt; "#36a64f",
                    AlertSeverity::Warning =&gt; "#ffcc00",
                    AlertSeverity::Error =&gt; "#ff9900",
                    AlertSeverity::Critical =&gt; "#ff0000",
                },
                "fields": [
                    {
                        "title": "Description",
                        "value": alert.description,
                        "short": false
                    },
                    {
                        "title": "Severity",
                        "value": alert.severity.to_string(),
                        "short": true
                    },
                    {
                        "title": "Source",
                        "value": alert.source,
                        "short": true
                    },
                    {
                        "title": "Time",
                        "value": alert.timestamp.to_rfc3339(),
                        "short": true
                    }
                ]
            }]
        });

        // Simulate sending
        tokio::time::sleep(Duration::from_millis(100)).await;

        Ok(())
    }
}

/// Logs alerts to a file
pub struct LogFileChannel {
    name: String,
    file_path: String,
}

impl LogFileChannel {
    /// Creates a new log file channel
    pub fn new(name: &amp;str, file_path: &amp;str) -&gt; Self {
        Self {
            name: name.to_string(),
            file_path: file_path.to_string(),
        }
    }
}

#[async_trait]
impl NotificationChannel for LogFileChannel {
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    async fn send(&amp;self, alert: &amp;Alert) -&gt; EventResult&lt;()&gt; {
        // Format the log entry
        let log_entry = format!(
            "[{}] [{}] {}: {}\n",
            alert.timestamp.to_rfc3339(),
            alert.severity,
            alert.source,
            alert.title
        );

        // Write to the log file
        tokio::fs::OpenOptions::new()
            .write(true)
            .create(true)
            .append(true)
            .open(&amp;self.file_path)
            .await?
            .write_all(log_entry.as_bytes())
            .await?;

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="alert-rules"><a class="header" href="#alert-rules">Alert Rules</a></h3>
<p>Finally, let’s create a rule-based system to generate alerts from events and metrics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A rule that generates alerts based on conditions
pub struct AlertRule {
    name: String,
    condition: Box&lt;dyn AlertCondition&gt;,
    alert_template: AlertTemplate,
}

/// Template for generating alerts
pub struct AlertTemplate {
    title: String,
    description: String,
    severity: AlertSeverity,
    source: String,
    tags: HashMap&lt;String, String&gt;,
}

/// Condition that triggers an alert
#[async_trait]
pub trait AlertCondition: Send + Sync {
    /// Checks if an event should trigger an alert
    async fn check(&amp;self, event: &amp;Event) -&gt; bool;
}

impl AlertRule {
    /// Creates a new alert rule
    pub fn new(
        name: &amp;str,
        condition: impl AlertCondition + 'static,
        template: AlertTemplate,
    ) -&gt; Self {
        Self {
            name: name.to_string(),
            condition: Box::new(condition),
            alert_template: template,
        }
    }

    /// Checks if an event should trigger an alert
    pub async fn check(&amp;self, event: &amp;Event) -&gt; Option&lt;Alert&gt; {
        if self.condition.check(event).await {
            // Generate alert from template
            let mut alert = Alert::new(
                &amp;self.alert_template.title,
                &amp;self.alert_template.description,
                self.alert_template.severity,
                &amp;self.alert_template.source,
            );

            // Add template tags
            for (k, v) in &amp;self.alert_template.tags {
                alert = alert.with_tag(k, v);
            }

            // Add the triggering event
            alert = alert.with_event(event.clone());

            Some(alert)
        } else {
            None
        }
    }
}

impl AlertTemplate {
    /// Creates a new alert template
    pub fn new(
        title: &amp;str,
        description: &amp;str,
        severity: AlertSeverity,
        source: &amp;str,
    ) -&gt; Self {
        Self {
            title: title.to_string(),
            description: description.to_string(),
            severity,
            source: source.to_string(),
            tags: HashMap::new(),
        }
    }

    /// Adds a tag to the alert template
    pub fn with_tag(mut self, key: &amp;str, value: &amp;str) -&gt; Self {
        self.tags.insert(key.to_string(), value.to_string());
        self
    }
}

/// Condition based on event type
pub struct EventTypeAlertCondition {
    event_type: String,
}

impl EventTypeAlertCondition {
    /// Creates a new event type condition
    pub fn new(event_type: &amp;str) -&gt; Self {
        Self {
            event_type: event_type.to_string(),
        }
    }
}

#[async_trait]
impl AlertCondition for EventTypeAlertCondition {
    async fn check(&amp;self, event: &amp;Event) -&gt; bool {
        event.event_type == self.event_type
    }
}

/// Condition based on a predicate function
pub struct PredicateAlertCondition&lt;F&gt; {
    predicate: F,
}

impl&lt;F&gt; PredicateAlertCondition&lt;F&gt;
where
    F: Fn(&amp;Event) -&gt; bool + Send + Sync + 'static,
{
    /// Creates a new predicate condition
    pub fn new(predicate: F) -&gt; Self {
        Self { predicate }
    }
}

#[async_trait]
impl&lt;F&gt; AlertCondition for PredicateAlertCondition&lt;F&gt;
where
    F: Fn(&amp;Event) -&gt; bool + Send + Sync + 'static,
{
    async fn check(&amp;self, event: &amp;Event) -&gt; bool {
        (self.predicate)(event)
    }
}

/// Operator that applies alert rules to events
pub struct AlertRuleOperator {
    name: String,
    rules: Vec&lt;AlertRule&gt;,
    alert_manager: Arc&lt;Mutex&lt;AlertManager&gt;&gt;,
}

impl AlertRuleOperator {
    /// Creates a new alert rule operator
    pub fn new(name: &amp;str, alert_manager: Arc&lt;Mutex&lt;AlertManager&gt;&gt;) -&gt; Self {
        Self {
            name: name.to_string(),
            rules: Vec::new(),
            alert_manager,
        }
    }

    /// Adds an alert rule
    pub fn add_rule(&amp;mut self, rule: AlertRule) -&gt; &amp;mut Self {
        self.rules.push(rule);
        self
    }
}

#[async_trait]
impl Operator for AlertRuleOperator {
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    async fn apply(&amp;self, input: EventStream) -&gt; EventStream {
        let rules = self.rules.clone();
        let alert_manager = self.alert_manager.clone();

        Box::pin(input.then(move |result| {
            let rules = rules.clone();
            let alert_manager = alert_manager.clone();

            async move {
                if let Ok(event) = &amp;result {
                    // Check all rules
                    for rule in &amp;rules {
                        if let Some(alert) = rule.check(event).await {
                            // Send the alert
                            let mut manager = alert_manager.lock().await;
                            if let Err(e) = manager.send_alert(alert).await {
                                eprintln!("Error sending alert: {}", e);
                            }
                        }
                    }
                }

                // Pass the event through
                result
            }
        }))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>With this alerting system, our RustStream platform can notify users through various channels when important conditions are detected in the data stream. The rule-based approach allows for flexible alert definitions, while the alert manager provides deduplication and throttling to prevent alert fatigue.</p>
<p>In the next section, we’ll build a dashboard to visualize the real-time data and analytics.</p>
<h2 id="dashboard-and-visualization"><a class="header" href="#dashboard-and-visualization">Dashboard and Visualization</a></h2>
<p>To make our real-time data processing system complete, we need a way to visualize the data and insights. Let’s create a web-based dashboard that provides real-time visualizations of metrics, alerts, and events.</p>
<h3 id="web-api"><a class="header" href="#web-api">Web API</a></h3>
<p>First, let’s build a RESTful API that exposes our system’s data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{web, App, HttpResponse, HttpServer, Responder};
use actix_web::middleware::Logger;
use serde::Serialize;

/// Shared application state
pub struct AppState {
    /// Metrics repository
    metrics_repository: SharedMetricsRepository,
    /// Alert history
    alert_history: Arc&lt;RwLock&lt;Vec&lt;Alert&gt;&gt;&gt;,
    /// Event buffer (recent events)
    event_buffer: Arc&lt;RwLock&lt;VecDeque&lt;Event&gt;&gt;&gt;,
}

/// API response for metrics
#[derive(Serialize)]
struct MetricsResponse {
    metrics: Vec&lt;MetricDto&gt;,
}

/// DTO for metrics
#[derive(Serialize)]
struct MetricDto {
    name: String,
    value: String,
    tags: HashMap&lt;String, String&gt;,
    updated_at: String,
}

/// API response for alerts
#[derive(Serialize)]
struct AlertsResponse {
    alerts: Vec&lt;AlertDto&gt;,
}

/// DTO for alerts
#[derive(Serialize)]
struct AlertDto {
    id: String,
    title: String,
    description: String,
    severity: String,
    timestamp: String,
    source: String,
    tags: HashMap&lt;String, String&gt;,
}

/// Starts the dashboard API server
pub async fn start_dashboard_api(
    metrics_repository: SharedMetricsRepository,
    alert_history: Arc&lt;RwLock&lt;Vec&lt;Alert&gt;&gt;&gt;,
    event_buffer: Arc&lt;RwLock&lt;VecDeque&lt;Event&gt;&gt;&gt;,
    bind_address: &amp;str,
) -&gt; std::io::Result&lt;()&gt; {
    let app_state = web::Data::new(AppState {
        metrics_repository,
        alert_history,
        event_buffer,
    });

    HttpServer::new(move || {
        App::new()
            .app_data(app_state.clone())
            .wrap(Logger::default())
            // API routes
            .route("/api/metrics", web::get().to(get_metrics))
            .route("/api/metrics/{name}", web::get().to(get_metric_by_name))
            .route("/api/alerts", web::get().to(get_alerts))
            .route("/api/events", web::get().to(get_events))
            // Static files for the dashboard frontend
            .service(actix_files::Files::new("/", "./dashboard/dist").index_file("index.html"))
    })
    .bind(bind_address)?
    .run()
    .await
}

/// Gets all metrics
async fn get_metrics(state: web::Data&lt;AppState&gt;) -&gt; impl Responder {
    let repo = state.metrics_repository.read().await;

    let metrics: Vec&lt;MetricDto&gt; = repo.get_all()
        .map(|m| MetricDto {
            name: m.name.clone(),
            value: m.value.to_string(),
            tags: m.tags.clone(),
            updated_at: format!("{:?}", m.updated_at.elapsed()),
        })
        .collect();

    HttpResponse::Ok().json(MetricsResponse { metrics })
}

/// Gets a metric by name
async fn get_metric_by_name(
    state: web::Data&lt;AppState&gt;,
    path: web::Path&lt;String&gt;,
) -&gt; impl Responder {
    let name = path.into_inner();
    let repo = state.metrics_repository.read().await;

    // Find metrics with matching name
    let metrics: Vec&lt;MetricDto&gt; = repo.get_all()
        .filter(|m| m.name == name)
        .map(|m| MetricDto {
            name: m.name.clone(),
            value: m.value.to_string(),
            tags: m.tags.clone(),
            updated_at: format!("{:?}", m.updated_at.elapsed()),
        })
        .collect();

    if metrics.is_empty() {
        HttpResponse::NotFound().finish()
    } else {
        HttpResponse::Ok().json(MetricsResponse { metrics })
    }
}

/// Gets recent alerts
async fn get_alerts(state: web::Data&lt;AppState&gt;) -&gt; impl Responder {
    let alerts = state.alert_history.read().await;

    let alert_dtos: Vec&lt;AlertDto&gt; = alerts.iter()
        .map(|a| AlertDto {
            id: a.id.to_string(),
            title: a.title.clone(),
            description: a.description.clone(),
            severity: a.severity.to_string(),
            timestamp: a.timestamp.to_rfc3339(),
            source: a.source.clone(),
            tags: a.tags.clone(),
        })
        .collect();

    HttpResponse::Ok().json(AlertsResponse { alerts: alert_dtos })
}

/// Gets recent events
async fn get_events(state: web::Data&lt;AppState&gt;) -&gt; impl Responder {
    let events = state.event_buffer.read().await;
    let events_vec: Vec&lt;&amp;Event&gt; = events.iter().collect();

    HttpResponse::Ok().json(events_vec)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="websocket-support"><a class="header" href="#websocket-support">WebSocket Support</a></h3>
<p>To provide real-time updates to the dashboard, let’s add WebSocket support:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{web, Error, HttpRequest, HttpResponse};
use actix_web_actors::ws;
use actix::{Actor, ActorContext, AsyncContext, StreamHandler};
use std::time::{Duration, Instant};

/// Interval for sending ping messages
const HEARTBEAT_INTERVAL: Duration = Duration::from_secs(5);
/// How long before lack of client response causes a timeout
const CLIENT_TIMEOUT: Duration = Duration::from_secs(10);

/// WebSocket connection actor
struct DashboardWebSocket {
    /// Client ID
    id: usize,
    /// Client must send ping at least once per 10 seconds
    hb: Instant,
    /// Shared application state
    app_state: web::Data&lt;AppState&gt;,
}

impl Actor for DashboardWebSocket {
    type Context = ws::WebsocketContext&lt;Self&gt;;

    /// Method called on actor start
    fn started(&amp;mut self, ctx: &amp;mut Self::Context) {
        // Start the heartbeat process
        self.hb(ctx);

        // Set up subscription to updates
        let metrics_repo = self.app_state.metrics_repository.clone();
        let alerts = self.app_state.alert_history.clone();
        let events = self.app_state.event_buffer.clone();

        // Send initial data
        ctx.spawn(Box::pin(async move {
            // Send metrics
            let metrics = {
                let repo = metrics_repo.read().await;
                repo.get_all()
                    .map(|m| MetricDto {
                        name: m.name.clone(),
                        value: m.value.to_string(),
                        tags: m.tags.clone(),
                        updated_at: format!("{:?}", m.updated_at.elapsed()),
                    })
                    .collect::&lt;Vec&lt;_&gt;&gt;()
            };

            // Return initial data
            (metrics, alerts, events)
        }.then(move |(metrics, alerts, events)| {
            async move {
                // Send initial metrics
                ctx.text(serde_json::to_string(&amp;MetricsResponse { metrics }).unwrap());

                // TODO: Send alerts and events
            }
        })));
    }
}

impl StreamHandler&lt;Result&lt;ws::Message, ws::ProtocolError&gt;&gt; for DashboardWebSocket {
    fn handle(&amp;mut self, msg: Result&lt;ws::Message, ws::ProtocolError&gt;, ctx: &amp;mut Self::Context) {
        match msg {
            Ok(ws::Message::Ping(msg)) =&gt; {
                self.hb = Instant::now();
                ctx.pong(&amp;msg);
            }
            Ok(ws::Message::Pong(_)) =&gt; {
                self.hb = Instant::now();
            }
            Ok(ws::Message::Text(text)) =&gt; {
                // Handle text messages from client
                if let Ok(command) = serde_json::from_str::&lt;DashboardCommand&gt;(&amp;text) {
                    match command {
                        DashboardCommand::Subscribe { topic } =&gt; {
                            // Handle subscription request
                            ctx.text(format!("Subscribed to {}", topic));
                        }
                        DashboardCommand::Unsubscribe { topic } =&gt; {
                            // Handle unsubscription request
                            ctx.text(format!("Unsubscribed from {}", topic));
                        }
                    }
                }
            }
            Ok(ws::Message::Binary(_)) =&gt; {
                // We don't handle binary messages
            }
            Ok(ws::Message::Close(reason)) =&gt; {
                // Handle WebSocket close
                ctx.close(reason);
                ctx.stop();
            }
            _ =&gt; ctx.stop(),
        }
    }
}

impl DashboardWebSocket {
    /// Sends ping to client and checks for client timeout
    fn hb(&amp;self, ctx: &amp;mut ws::WebsocketContext&lt;Self&gt;) {
        ctx.run_interval(HEARTBEAT_INTERVAL, |act, ctx| {
            // Check client heartbeat
            if Instant::now().duration_since(act.hb) &gt; CLIENT_TIMEOUT {
                // Client timed out
                ctx.stop();
                return;
            }

            // Send ping
            ctx.ping(b"");
        });
    }
}

/// Command sent from the dashboard client
#[derive(Deserialize)]
#[serde(tag = "type")]
enum DashboardCommand {
    /// Subscribe to a topic
    Subscribe {
        /// Topic to subscribe to
        topic: String,
    },
    /// Unsubscribe from a topic
    Unsubscribe {
        /// Topic to unsubscribe from
        topic: String,
    },
}

/// WebSocket handler
async fn ws_dashboard(
    req: HttpRequest,
    stream: web::Payload,
    app_state: web::Data&lt;AppState&gt;,
) -&gt; Result&lt;HttpResponse, Error&gt; {
    // Create WebSocket actor
    let ws = DashboardWebSocket {
        id: 0, // We would generate a unique ID in a real app
        hb: Instant::now(),
        app_state,
    };

    // Start WebSocket connection
    let resp = ws::start(ws, &amp;req, stream)?;
    Ok(resp)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="frontend-dashboard"><a class="header" href="#frontend-dashboard">Frontend Dashboard</a></h3>
<p>For the dashboard frontend, we’ll use a modern JavaScript framework. Here’s a simplified React-based dashboard component:</p>
<pre><code class="language-jsx">// Dashboard.jsx
import React, { useState, useEffect } from "react";
import { LineChart, BarChart, PieChart } from "./Charts";
import { MetricsTable, AlertsTable, EventsTable } from "./Tables";

// Dashboard component
export function Dashboard() {
  const [metrics, setMetrics] = useState([]);
  const [alerts, setAlerts] = useState([]);
  const [events, setEvents] = useState([]);
  const [ws, setWs] = useState(null);

  // Initialize WebSocket
  useEffect(() =&gt; {
    const socket = new WebSocket(`ws://${window.location.host}/ws`);

    socket.onopen = () =&gt; {
      console.log("WebSocket connected");
      // Subscribe to updates
      socket.send(JSON.stringify({ type: "Subscribe", topic: "metrics" }));
      socket.send(JSON.stringify({ type: "Subscribe", topic: "alerts" }));
      socket.send(JSON.stringify({ type: "Subscribe", topic: "events" }));
    };

    socket.onmessage = (event) =&gt; {
      const data = JSON.parse(event.data);

      if (data.metrics) {
        setMetrics(data.metrics);
      } else if (data.alerts) {
        setAlerts(data.alerts);
      } else if (data.events) {
        setEvents(data.events);
      }
    };

    socket.onclose = () =&gt; {
      console.log("WebSocket disconnected");
    };

    setWs(socket);

    // Cleanup on unmount
    return () =&gt; {
      socket.close();
    };
  }, []);

  // Fetch initial data
  useEffect(() =&gt; {
    // Fetch metrics
    fetch("/api/metrics")
      .then((res) =&gt; res.json())
      .then((data) =&gt; setMetrics(data.metrics))
      .catch((err) =&gt; console.error("Error fetching metrics:", err));

    // Fetch alerts
    fetch("/api/alerts")
      .then((res) =&gt; res.json())
      .then((data) =&gt; setAlerts(data.alerts))
      .catch((err) =&gt; console.error("Error fetching alerts:", err));

    // Fetch events
    fetch("/api/events")
      .then((res) =&gt; res.json())
      .then((data) =&gt; setEvents(data))
      .catch((err) =&gt; console.error("Error fetching events:", err));
  }, []);

  return (
    &lt;div className="dashboard"&gt;
      &lt;header&gt;
        &lt;h1&gt;RustStream Dashboard&lt;/h1&gt;
      &lt;/header&gt;

      &lt;div className="dashboard-grid"&gt;
        {/* Metrics section */}
        &lt;div className="dashboard-panel"&gt;
          &lt;h2&gt;Key Metrics&lt;/h2&gt;
          &lt;div className="charts-container"&gt;
            &lt;LineChart
              data={metrics.filter((m) =&gt; m.name === "events_per_second")}
              title="Events Per Second"
            /&gt;
            &lt;BarChart
              data={metrics.filter((m) =&gt; m.name === "events_by_type")}
              title="Events by Type"
            /&gt;
          &lt;/div&gt;
          &lt;MetricsTable metrics={metrics} /&gt;
        &lt;/div&gt;

        {/* Alerts section */}
        &lt;div className="dashboard-panel"&gt;
          &lt;h2&gt;Recent Alerts&lt;/h2&gt;
          &lt;AlertsTable alerts={alerts} /&gt;
        &lt;/div&gt;

        {/* Events section */}
        &lt;div className="dashboard-panel"&gt;
          &lt;h2&gt;Recent Events&lt;/h2&gt;
          &lt;EventsTable events={events} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting It All Together</a></h3>
<p>Finally, let’s create a dashboard manager that connects our web API to the real-time processing system:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Manages the dashboard components
pub struct DashboardManager {
    /// Metrics repository
    metrics_repository: SharedMetricsRepository,
    /// Alert history
    alert_history: Arc&lt;RwLock&lt;Vec&lt;Alert&gt;&gt;&gt;,
    /// Event buffer
    event_buffer: Arc&lt;RwLock&lt;VecDeque&lt;Event&gt;&gt;&gt;,
    /// Maximum events to keep in buffer
    max_events: usize,
    /// Maximum alerts to keep in history
    max_alerts: usize,
}

impl DashboardManager {
    /// Creates a new dashboard manager
    pub fn new(
        metrics_repository: SharedMetricsRepository,
        max_events: usize,
        max_alerts: usize,
    ) -&gt; Self {
        Self {
            metrics_repository,
            alert_history: Arc::new(RwLock::new(Vec::new())),
            event_buffer: Arc::new(RwLock::new(VecDeque::with_capacity(max_events))),
            max_events,
            max_alerts,
        }
    }

    /// Starts the dashboard
    pub async fn start(&amp;self, bind_address: &amp;str) -&gt; std::io::Result&lt;()&gt; {
        // Start the dashboard API server
        start_dashboard_api(
            self.metrics_repository.clone(),
            self.alert_history.clone(),
            self.event_buffer.clone(),
            bind_address,
        ).await
    }

    /// Records an event in the buffer
    pub async fn record_event(&amp;self, event: Event) {
        let mut buffer = self.event_buffer.write().await;

        // Add event to buffer
        buffer.push_back(event);

        // Trim buffer if needed
        while buffer.len() &gt; self.max_events {
            buffer.pop_front();
        }
    }

    /// Records an alert in the history
    pub async fn record_alert(&amp;self, alert: Alert) {
        let mut history = self.alert_history.write().await;

        // Add alert to history
        history.push(alert);

        // Sort by timestamp (newest first)
        history.sort_by(|a, b| b.timestamp.cmp(&amp;a.timestamp));

        // Trim history if needed
        if history.len() &gt; self.max_alerts {
            history.truncate(self.max_alerts);
        }
    }
}

/// Creates an event sink that records events for the dashboard
pub fn create_dashboard_event_sink(
    dashboard_manager: Arc&lt;DashboardManager&gt;,
) -&gt; impl EventSink {
    DashboardEventSink { dashboard_manager }
}

/// Event sink that records events for the dashboard
struct DashboardEventSink {
    dashboard_manager: Arc&lt;DashboardManager&gt;,
}

#[async_trait]
impl EventSink for DashboardEventSink {
    fn name(&amp;self) -&gt; &amp;str {
        "dashboard_event_sink"
    }

    async fn write(&amp;mut self, event: &amp;Event) -&gt; EventResult&lt;()&gt; {
        self.dashboard_manager.record_event(event.clone()).await;
        Ok(())
    }

    async fn flush(&amp;mut self) -&gt; EventResult&lt;()&gt; {
        // No buffering in this sink
        Ok(())
    }
}

/// Creates an alert sink that records alerts for the dashboard
pub fn create_dashboard_alert_sink(
    dashboard_manager: Arc&lt;DashboardManager&gt;,
) -&gt; impl AlertSink {
    DashboardAlertSink { dashboard_manager }
}

/// Alert sink that records alerts for the dashboard
struct DashboardAlertSink {
    dashboard_manager: Arc&lt;DashboardManager&gt;,
}

#[async_trait]
impl AlertSink for DashboardAlertSink {
    async fn send_alert(&amp;self, anomaly: &amp;AnomalyEvent) -&gt; EventResult&lt;()&gt; {
        // Create an alert from the anomaly
        let alert = Alert::new(
            &amp;format!("Anomaly detected in metric '{}'", anomaly.metric_name),
            &amp;format!(
                "The metric '{}' has an anomalous value of {}",
                anomaly.metric_name, anomaly.current_value
            ),
            AlertSeverity::Warning,
            "anomaly_detector",
        );

        // Record the alert
        self.dashboard_manager.record_alert(alert).await;

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>With these components, we’ve created a complete web-based dashboard for our RustStream system. The dashboard provides real-time visualizations of metrics, alerts, and events, allowing users to monitor and understand the data flowing through the system.</p>
<p>In the next section, we’ll implement high availability and fault tolerance features to ensure our system remains reliable in production environments.</p>
<h2 id="high-availability-and-fault-tolerance"><a class="header" href="#high-availability-and-fault-tolerance">High Availability and Fault Tolerance</a></h2>
<p>Real-time data processing systems must be highly available and resilient to failures. Let’s implement strategies to ensure our RustStream system can operate reliably in production environments.</p>
<h3 id="distributed-cluster-management"><a class="header" href="#distributed-cluster-management">Distributed Cluster Management</a></h3>
<p>To support multiple nodes working together, we’ll implement a simple cluster management system:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::sync::mpsc;
use tokio::time::{self, Duration};
use std::collections::HashMap;

/// Status of a cluster node
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum NodeStatus {
    /// Node is starting up
    Starting,
    /// Node is active and processing data
    Active,
    /// Node is shutting down
    ShuttingDown,
    /// Node has failed
    Failed,
}

/// Information about a cluster node
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NodeInfo {
    /// Node ID
    pub id: String,
    /// Node address
    pub address: String,
    /// Node status
    pub status: NodeStatus,
    /// When the node was last seen
    pub last_heartbeat: DateTime&lt;Utc&gt;,
    /// Node capabilities and roles
    pub roles: Vec&lt;String&gt;,
}

/// Event related to cluster membership
#[derive(Debug, Clone)]
pub enum ClusterEvent {
    /// Node joined the cluster
    NodeJoined(NodeInfo),
    /// Node left the cluster
    NodeLeft(String),
    /// Node failed
    NodeFailed(String),
    /// Node status changed
    NodeStatusChanged(String, NodeStatus),
}

/// Manages a cluster of stream processing nodes
pub struct ClusterManager {
    /// Node ID for this node
    node_id: String,
    /// Information about this node
    node_info: NodeInfo,
    /// Known cluster nodes
    nodes: HashMap&lt;String, NodeInfo&gt;,
    /// Cluster event subscribers
    subscribers: Vec&lt;mpsc::Sender&lt;ClusterEvent&gt;&gt;,
    /// Leader election service
    leader_election: Option&lt;Box&lt;dyn LeaderElection&gt;&gt;,
}

/// Service for leader election
#[async_trait]
pub trait LeaderElection: Send + Sync {
    /// Attempts to become the leader
    async fn try_become_leader(&amp;self) -&gt; bool;

    /// Checks if this node is the leader
    async fn is_leader(&amp;self) -&gt; bool;

    /// Relinquishes leadership
    async fn resign_leadership(&amp;self) -&gt; Result&lt;(), &amp;'static str&gt;;
}

impl ClusterManager {
    /// Creates a new cluster manager
    pub fn new(
        node_id: &amp;str,
        address: &amp;str,
        roles: Vec&lt;String&gt;,
    ) -&gt; Self {
        let node_info = NodeInfo {
            id: node_id.to_string(),
            address: address.to_string(),
            status: NodeStatus::Starting,
            last_heartbeat: Utc::now(),
            roles,
        };

        let mut nodes = HashMap::new();
        nodes.insert(node_id.to_string(), node_info.clone());

        Self {
            node_id: node_id.to_string(),
            node_info,
            nodes,
            subscribers: Vec::new(),
            leader_election: None,
        }
    }

    /// Sets the leader election service
    pub fn with_leader_election&lt;L&gt;(&amp;mut self, leader_election: L) -&gt; &amp;mut Self
    where
        L: LeaderElection + 'static,
    {
        self.leader_election = Some(Box::new(leader_election));
        self
    }

    /// Starts the cluster manager
    pub async fn start(&amp;mut self) -&gt; EventResult&lt;mpsc::Receiver&lt;ClusterEvent&gt;&gt; {
        // Create channel for cluster events
        let (tx, rx) = mpsc::channel(100);
        self.subscribers.push(tx);

        // Set node as active
        self.node_info.status = NodeStatus::Active;
        self.notify_status_change().await;

        // Start heartbeat task
        let node_id = self.node_id.clone();
        let nodes = self.nodes.clone();
        let subscribers = self.subscribers.clone();

        tokio::spawn(async move {
            let mut interval = time::interval(Duration::from_secs(5));

            loop {
                interval.tick().await;

                // Update own heartbeat
                if let Some(node) = nodes.get_mut(&amp;node_id) {
                    node.last_heartbeat = Utc::now();
                }

                // Check for failed nodes
                let now = Utc::now();
                let failed_nodes: Vec&lt;_&gt; = nodes.iter()
                    .filter(|(id, node)| {
                        id != &amp;node_id &amp;&amp;
                        node.status == NodeStatus::Active &amp;&amp;
                        now.signed_duration_since(node.last_heartbeat).num_seconds() &gt; 15
                    })
                    .map(|(id, _)| id.clone())
                    .collect();

                // Notify about failed nodes
                for id in failed_nodes {
                    if let Some(node) = nodes.get_mut(&amp;id) {
                        node.status = NodeStatus::Failed;

                        // Notify subscribers
                        let event = ClusterEvent::NodeFailed(id.clone());
                        for sub in &amp;subscribers {
                            let _ = sub.send(event.clone()).await;
                        }
                    }
                }
            }
        });

        Ok(rx)
    }

    /// Adds a node to the cluster
    pub async fn add_node(&amp;mut self, node: NodeInfo) -&gt; Result&lt;(), &amp;'static str&gt; {
        // Check if node already exists
        if let Some(existing) = self.nodes.get(&amp;node.id) {
            if existing.status != NodeStatus::Failed {
                return Err("Node already exists in the cluster");
            }
        }

        // Add node
        self.nodes.insert(node.id.clone(), node.clone());

        // Notify subscribers
        let event = ClusterEvent::NodeJoined(node);
        for sub in &amp;self.subscribers {
            let _ = sub.send(event.clone()).await;
        }

        Ok(())
    }

    /// Removes a node from the cluster
    pub async fn remove_node(&amp;mut self, node_id: &amp;str) -&gt; Result&lt;(), &amp;'static str&gt; {
        // Check if node exists
        if !self.nodes.contains_key(node_id) {
            return Err("Node not found in the cluster");
        }

        // Remove node
        self.nodes.remove(node_id);

        // Notify subscribers
        let event = ClusterEvent::NodeLeft(node_id.to_string());
        for sub in &amp;self.subscribers {
            let _ = sub.send(event.clone()).await;
        }

        Ok(())
    }

    /// Updates node status
    pub async fn update_status(&amp;mut self, status: NodeStatus) -&gt; Result&lt;(), &amp;'static str&gt; {
        // Update status
        self.node_info.status = status;

        if let Some(node) = self.nodes.get_mut(&amp;self.node_id) {
            node.status = status;
        }

        // Notify subscribers
        self.notify_status_change().await;

        Ok(())
    }

    /// Notifies subscribers about a status change
    async fn notify_status_change(&amp;self) {
        let event = ClusterEvent::NodeStatusChanged(
            self.node_id.clone(),
            self.node_info.status.clone(),
        );

        for sub in &amp;self.subscribers {
            let _ = sub.send(event.clone()).await;
        }
    }

    /// Checks if this node is the leader
    pub async fn is_leader(&amp;self) -&gt; bool {
        if let Some(ref leader_election) = self.leader_election {
            leader_election.is_leader().await
        } else {
            // Default to true if no leader election service
            true
        }
    }

    /// Attempts to become the leader
    pub async fn try_become_leader(&amp;self) -&gt; bool {
        if let Some(ref leader_election) = self.leader_election {
            leader_election.try_become_leader().await
        } else {
            // Default to true if no leader election service
            true
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="state-replication"><a class="header" href="#state-replication">State Replication</a></h3>
<p>For fault tolerance, we need to replicate state between nodes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Replicates state between nodes
pub struct StateReplicator&lt;T&gt; {
    /// State to replicate
    state: Arc&lt;RwLock&lt;T&gt;&gt;,
    /// Cluster manager
    cluster_manager: Arc&lt;RwLock&lt;ClusterManager&gt;&gt;,
    /// Replication topic
    topic: String,
}

impl&lt;T&gt; StateReplicator&lt;T&gt;
where
    T: Clone + Send + Sync + Serialize + for&lt;'de&gt; Deserialize&lt;'de&gt; + 'static,
{
    /// Creates a new state replicator
    pub fn new(
        state: Arc&lt;RwLock&lt;T&gt;&gt;,
        cluster_manager: Arc&lt;RwLock&lt;ClusterManager&gt;&gt;,
        topic: &amp;str,
    ) -&gt; Self {
        Self {
            state,
            cluster_manager,
            topic: topic.to_string(),
        }
    }

    /// Starts the state replicator
    pub async fn start(&amp;self, kafka_brokers: &amp;str) -&gt; EventResult&lt;()&gt; {
        // Producer for sending state updates
        let producer: FutureProducer = ClientConfig::new()
            .set("bootstrap.servers", kafka_brokers)
            .set("message.timeout.ms", "5000")
            .create()
            .map_err(|e| EventError::Connection(format!("Kafka producer error: {}", e)))?;

        // Consumer for receiving state updates
        let consumer: StreamConsumer = ClientConfig::new()
            .set("bootstrap.servers", kafka_brokers)
            .set("group.id", "state_replicator")
            .set("enable.auto.commit", "true")
            .set("auto.offset.reset", "latest")
            .create()
            .map_err(|e| EventError::Connection(format!("Kafka consumer error: {}", e)))?;

        consumer
            .subscribe(&amp;[&amp;self.topic])
            .map_err(|e| EventError::Connection(format!("Kafka subscription error: {}", e)))?;

        // Start consumer task
        let state = self.state.clone();
        let cluster_manager = self.cluster_manager.clone();

        tokio::spawn(async move {
            loop {
                match consumer.recv().await {
                    Ok(msg) =&gt; {
                        // Process message
                        if let Some(payload) = msg.payload() {
                            // Deserialize state
                            if let Ok(new_state) = serde_json::from_slice::&lt;T&gt;(payload) {
                                // Only update if this node is not the leader
                                let is_leader = {
                                    let cm = cluster_manager.read().await;
                                    cm.is_leader().await
                                };

                                if !is_leader {
                                    // Update state
                                    let mut state_guard = state.write().await;
                                    *state_guard = new_state;
                                }
                            }
                        }
                    }
                    Err(e) =&gt; {
                        eprintln!("Error receiving state update: {}", e);
                    }
                }
            }
        });

        // Start producer task for leader
        let state = self.state.clone();
        let cluster_manager = self.cluster_manager.clone();
        let topic = self.topic.clone();
        let producer_clone = producer.clone();

        tokio::spawn(async move {
            let mut interval = time::interval(Duration::from_secs(5));

            loop {
                interval.tick().await;

                // Only replicate if this node is the leader
                let is_leader = {
                    let cm = cluster_manager.read().await;
                    cm.is_leader().await
                };

                if is_leader {
                    // Replicate state
                    let current_state = {
                        let state_guard = state.read().await;
                        state_guard.clone()
                    };

                    // Serialize state
                    if let Ok(payload) = serde_json::to_vec(&amp;current_state) {
                        // Send to Kafka
                        let record = FutureRecord::to(&amp;topic)
                            .payload(&amp;payload);

                        if let Err((e, _)) = producer_clone.send(record, Duration::from_secs(5)).await {
                            eprintln!("Error replicating state: {}", e);
                        }
                    }
                }
            }
        });

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="checkpointing-and-recovery"><a class="header" href="#checkpointing-and-recovery">Checkpointing and Recovery</a></h3>
<p>To enable recovery from failures, let’s implement checkpointing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Manages checkpoints for recovery
pub struct CheckpointManager {
    /// Path to checkpoint directory
    checkpoint_dir: String,
    /// Checkpoint interval
    interval: Duration,
    /// Services to checkpoint
    services: Vec&lt;Box&lt;dyn Checkpointable&gt;&gt;,
}

/// Service that can be checkpointed
#[async_trait]
pub trait Checkpointable: Send + Sync {
    /// Returns the service name
    fn name(&amp;self) -&gt; &amp;str;

    /// Creates a checkpoint
    async fn create_checkpoint(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;, &amp;'static str&gt;;

    /// Restores from a checkpoint
    async fn restore_checkpoint(&amp;mut self, data: &amp;[u8]) -&gt; Result&lt;(), &amp;'static str&gt;;
}

impl CheckpointManager {
    /// Creates a new checkpoint manager
    pub fn new(checkpoint_dir: &amp;str, interval: Duration) -&gt; Self {
        Self {
            checkpoint_dir: checkpoint_dir.to_string(),
            interval,
            services: Vec::new(),
        }
    }

    /// Adds a service to checkpoint
    pub fn add_service&lt;S&gt;(&amp;mut self, service: S) -&gt; &amp;mut Self
    where
        S: Checkpointable + 'static,
    {
        self.services.push(Box::new(service));
        self
    }

    /// Starts the checkpoint manager
    pub async fn start(&amp;self) -&gt; std::io::Result&lt;()&gt; {
        // Create checkpoint directory if it doesn't exist
        tokio::fs::create_dir_all(&amp;self.checkpoint_dir).await?;

        // Start checkpoint task
        let services = self.services.clone();
        let checkpoint_dir = self.checkpoint_dir.clone();
        let interval = self.interval;

        tokio::spawn(async move {
            let mut checkpoint_interval = time::interval(interval);

            loop {
                checkpoint_interval.tick().await;

                // Create checkpoint for each service
                for service in &amp;services {
                    let name = service.name();

                    match service.create_checkpoint().await {
                        Ok(data) =&gt; {
                            // Write checkpoint to file
                            let path = format!("{}/{}.checkpoint", checkpoint_dir, name);
                            if let Err(e) = tokio::fs::write(&amp;path, &amp;data).await {
                                eprintln!("Error writing checkpoint for {}: {}", name, e);
                            }
                        }
                        Err(e) =&gt; {
                            eprintln!("Error creating checkpoint for {}: {}", name, e);
                        }
                    }
                }
            }
        });

        Ok(())
    }

    /// Restores services from checkpoints
    pub async fn restore_services(&amp;mut self) -&gt; std::io::Result&lt;()&gt; {
        for service in &amp;mut self.services {
            let name = service.name();
            let path = format!("{}/{}.checkpoint", self.checkpoint_dir, name);

            // Check if checkpoint exists
            if tokio::fs::metadata(&amp;path).await.is_ok() {
                // Read checkpoint
                let data = tokio::fs::read(&amp;path).await?;

                // Restore service
                if let Err(e) = service.restore_checkpoint(&amp;data).await {
                    eprintln!("Error restoring checkpoint for {}: {}", name, e);
                } else {
                    println!("Restored checkpoint for {}", name);
                }
            }
        }

        Ok(())
    }
}

/// Implementation of Checkpointable for MetricsRepository
impl Checkpointable for MetricsRepository {
    fn name(&amp;self) -&gt; &amp;str {
        "metrics_repository"
    }

    async fn create_checkpoint(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;, &amp;'static str&gt; {
        // Serialize metrics
        let metrics: Vec&lt;_&gt; = self.get_all().collect();
        serde_json::to_vec(&amp;metrics)
            .map_err(|_| "Failed to serialize metrics")
    }

    async fn restore_checkpoint(&amp;mut self, data: &amp;[u8]) -&gt; Result&lt;(), &amp;'static str&gt; {
        // Deserialize metrics
        let metrics: Vec&lt;Metric&gt; = serde_json::from_slice(data)
            .map_err(|_| "Failed to deserialize metrics")?;

        // Restore metrics
        for metric in metrics {
            self.update(metric);
        }

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>With these components, our RustStream system is now fault-tolerant and can continue operating even if individual nodes fail. The leader election ensures that critical operations have a single coordinator, while state replication and checkpointing allow the system to recover from failures.</p>
<h2 id="deployment-and-performance-tuning"><a class="header" href="#deployment-and-performance-tuning">Deployment and Performance Tuning</a></h2>
<p>Now that we’ve built a complete real-time data processing system, let’s discuss how to deploy it in production and optimize its performance.</p>
<h3 id="docker-containerization"><a class="header" href="#docker-containerization">Docker Containerization</a></h3>
<p>For easy deployment, let’s containerize our application:</p>
<pre><code class="language-dockerfile"># Dockerfile
FROM rust:1.59 as builder

# Create app directory
WORKDIR /usr/src/app

# Copy manifests
COPY Cargo.toml Cargo.toml
COPY Cargo.lock Cargo.lock

# Copy source code
COPY src/ src/

# Build the application
RUN cargo build --release

# Runtime stage
FROM debian:bullseye-slim

# Install dependencies
RUN apt-get update &amp;&amp; apt-get install -y \
    ca-certificates \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

# Copy the binary
COPY --from=builder /usr/src/app/target/release/ruststream /usr/local/bin/

# Create data directory
RUN mkdir -p /data/checkpoints

# Set environment variables
ENV RUST_LOG=info

# Expose ports
EXPOSE 8080 8081

# Run the application
CMD ["ruststream"]
</code></pre>
<h3 id="kubernetes-deployment"><a class="header" href="#kubernetes-deployment">Kubernetes Deployment</a></h3>
<p>For production environments, Kubernetes provides robust orchestration:</p>
<pre><code class="language-yaml"># kubernetes/deployment.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: ruststream
  labels:
    app: ruststream
spec:
  replicas: 3
  selector:
    matchLabels:
      app: ruststream
  serviceName: ruststream
  template:
    metadata:
      labels:
        app: ruststream
    spec:
      containers:
        - name: ruststream
          image: ruststream:latest
          ports:
            - containerPort: 8080
              name: http
            - containerPort: 8081
              name: metrics
          env:
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: KAFKA_BROKERS
              value: "kafka-0.kafka-headless:9092,kafka-1.kafka-headless:9092"
            - name: CHECKPOINT_DIR
              value: "/data/checkpoints"
          volumeMounts:
            - name: data
              mountPath: /data
          resources:
            limits:
              cpu: "1"
              memory: "1Gi"
            requests:
              cpu: "500m"
              memory: "512Mi"
          livenessProbe:
            httpGet:
              path: /health
              port: http
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /ready
              port: http
            initialDelaySeconds: 5
            periodSeconds: 5
  volumeClaimTemplates:
    - metadata:
        name: data
      spec:
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: 10Gi
</code></pre>
<h3 id="performance-tuning"><a class="header" href="#performance-tuning">Performance Tuning</a></h3>
<p>To optimize our system’s performance, we should focus on these areas:</p>
<ol>
<li>
<p><strong>Memory Management</strong></p>
<ul>
<li>Use appropriate buffer sizes for channels and queues</li>
<li>Implement backpressure mechanisms to handle load spikes</li>
<li>Monitor and tune garbage collection</li>
</ul>
</li>
<li>
<p><strong>Concurrency Optimization</strong></p>
<ul>
<li>Adjust thread pool sizes based on workload and hardware</li>
<li>Use work-stealing schedulers for balanced load distribution</li>
<li>Minimize lock contention with fine-grained locking</li>
</ul>
</li>
<li>
<p><strong>Network Efficiency</strong></p>
<ul>
<li>Batch messages to reduce overhead</li>
<li>Use connection pooling for external services</li>
<li>Implement compression for large payloads</li>
</ul>
</li>
<li>
<p><strong>Serialization Performance</strong></p>
<ul>
<li>Use efficient binary formats (e.g., Protocol Buffers, FlatBuffers)</li>
<li>Implement zero-copy deserialization where possible</li>
<li>Cache parsed objects to avoid repeated parsing</li>
</ul>
</li>
<li>
<p><strong>Database Tuning</strong></p>
<ul>
<li>Optimize queries and indexes</li>
<li>Use connection pooling</li>
<li>Implement caching layers</li>
</ul>
</li>
<li>
<p><strong>Monitoring and Profiling</strong></p>
<ul>
<li>Use continuous profiling to identify bottlenecks</li>
<li>Implement detailed metrics for all components</li>
<li>Set up alerts for performance degradation</li>
</ul>
</li>
</ol>
<p>By applying these optimization techniques, we can ensure that our RustStream system delivers the low-latency, high-throughput performance required for real-time data processing applications.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this chapter, we’ve built a comprehensive real-time data processing system from the ground up using Rust. Our RustStream platform demonstrates how to collect, process, analyze, and visualize streaming data with minimal latency while maintaining reliability and fault tolerance.</p>
<p>We’ve implemented several key components:</p>
<ol>
<li><strong>Event Model and Core Processing Engine</strong>: A flexible, composable stream processing framework</li>
<li><strong>Event Sources and Sinks</strong>: Adapters for connecting to various external systems</li>
<li><strong>Analytics Engine</strong>: Real-time metrics calculation, anomaly detection, and pattern recognition</li>
<li><strong>Alerting System</strong>: Flexible rules-based alerting with multiple notification channels</li>
<li><strong>Dashboard</strong>: Web-based visualization of real-time data and insights</li>
<li><strong>High Availability Features</strong>: Clustering, state replication, and fault recovery</li>
</ol>
<p>The RustStream system we’ve created is not only educational but also practical. The patterns and components we’ve developed can be applied to real-world streaming use cases such as:</p>
<ul>
<li>Real-time analytics for web applications</li>
<li>IoT sensor data processing</li>
<li>Financial market data analysis</li>
<li>Network monitoring and security</li>
<li>User behavior tracking</li>
<li>Operational metrics and alerting</li>
</ul>
<p>Rust’s combination of performance, safety, and expressive type system makes it an excellent choice for building such systems. The language allows us to create efficient, concurrent code without sacrificing reliability—a critical requirement for production data processing applications.</p>
<p>As you continue your journey with Rust and real-time systems, consider exploring these advanced topics:</p>
<ul>
<li>Stream processing with machine learning for predictive analytics</li>
<li>Advanced state management techniques like event sourcing</li>
<li>Geo-distributed stream processing for global applications</li>
<li>Custom DSLs for stream processing operations</li>
<li>Specialized hardware acceleration for stream processing</li>
</ul>
<p>The skills you’ve developed in this chapter provide a solid foundation for tackling these and other challenges in the rapidly evolving field of real-time data processing.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapters/47-blockchain.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapters/49-wasm-frontend.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapters/47-blockchain.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapters/49-wasm-frontend.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
