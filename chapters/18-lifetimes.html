<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Understanding Lifetimes - Rust Universe: Fearless Systems Engineering</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to learning the Rust programming language from fundamentals to mastery.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Universe: Fearless Systems Engineering</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/saeedalam/rust-universe" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/saeedalam/rust-universe/edit/main/src/chapters/18-lifetimes.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-18-understanding-lifetimes"><a class="header" href="#chapter-18-understanding-lifetimes">Chapter 18: Understanding Lifetimes</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>In previous chapters, we’ve explored Rust’s ownership system, borrowing, and references—all crucial components of Rust’s memory safety guarantees. Now we’re ready to tackle one of Rust’s most powerful but often challenging concepts: lifetimes.</p>
<p>Lifetimes represent a unique aspect of Rust’s approach to memory safety. They’re a formal way for the compiler to track how long references are valid, ensuring that no reference ever points to deallocated memory. This chapter will demystify lifetimes, explaining why they exist, how they work, and how to effectively use them in your code.</p>
<p>By the end of this chapter, you’ll have a deep understanding of how Rust tracks the validity of references, allowing you to write more complex, yet safe code that leverages Rust’s borrowing system to its full potential.</p>
<h2 id="why-lifetimes-exist"><a class="header" href="#why-lifetimes-exist">Why Lifetimes Exist</a></h2>
<h3 id="the-fundamental-problem"><a class="header" href="#the-fundamental-problem">The Fundamental Problem</a></h3>
<p>At its core, Rust’s ownership system aims to prevent dangling references—references that point to memory that has been freed. Consider this problematic code:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let r;
    {
        let x = 5;
        r = &amp;x; // r borrows x
    } // x goes out of scope here and is dropped

    // This would be a dangling reference in other languages
    println!("r: {}", r);
}</code></pre></pre>
<p>In languages like C or C++, this pattern could lead to undefined behavior: by the time we try to use <code>r</code>, it points to memory that has been deallocated. But Rust’s compiler prevents this error with a message like:</p>
<pre><code>error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:5:13
  |
5 |         r = &amp;x;
  |             ^^ borrowed value does not live long enough
6 |     } // x goes out of scope here and is dropped
  |     - `x` dropped here while still borrowed
7 |
8 |     println!("r: {}", r);
  |                       - borrow later used here
</code></pre>
<p>This is where lifetimes come in—they’re Rust’s way of formally describing how long references are valid.</p>
<h3 id="references-and-validity"><a class="header" href="#references-and-validity">References and Validity</a></h3>
<p>Every reference in Rust has a lifetime—a scope during which the reference is valid. Most of the time, these lifetimes are implicit and inferred by the compiler through a process called lifetime elision. However, there are situations where we need to explicitly annotate lifetimes to help the compiler understand the relationships between different references.</p>
<h3 id="benefits-of-the-lifetime-system"><a class="header" href="#benefits-of-the-lifetime-system">Benefits of the Lifetime System</a></h3>
<p>Rust’s lifetime system provides several key benefits:</p>
<ol>
<li>
<p><strong>Preventing Dangling References</strong>: The primary purpose—ensuring no reference outlives the data it points to.</p>
</li>
<li>
<p><strong>Enabling Complex Borrowing Patterns</strong>: Allowing data structures to safely store references to data they don’t own.</p>
</li>
<li>
<p><strong>Documenting Code Contracts</strong>: Making the relationships between references explicit in function signatures.</p>
</li>
<li>
<p><strong>Enabling Safe API Design</strong>: Allowing libraries to safely accept and return references without risky assumptions.</p>
</li>
</ol>
<p>Let’s dive deeper into how lifetimes work in practice.</p>
<h2 id="lifetime-annotations"><a class="header" href="#lifetime-annotations">Lifetime Annotations</a></h2>
<h3 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax</a></h3>
<p>Lifetime annotations begin with an apostrophe (<code>'</code>) followed by a name, typically a single lowercase letter. By convention, <code>'a</code> (pronounced “tick a”) is used for the first lifetime parameter, then <code>'b</code>, <code>'c</code>, and so on.</p>
<p>Here’s a simple example of a function with explicit lifetime annotations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A function that takes two string slices and returns the longer one
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Let’s break down what’s happening here:</p>
<ul>
<li><code>&lt;'a&gt;</code> declares a lifetime parameter named <code>'a</code>.</li>
<li>The parameters <code>x</code> and <code>y</code> both have the lifetime <code>'a</code>.</li>
<li>The return value also has the lifetime <code>'a</code>.</li>
</ul>
<p>This signature tells the compiler that:</p>
<ol>
<li>The returned reference will be valid for at least as long as both input references are valid.</li>
<li>If either <code>x</code> or <code>y</code> has a shorter lifetime, that lifetime constrains how long the return value can be used.</li>
</ol>
<h3 id="when-do-you-need-lifetime-annotations"><a class="header" href="#when-do-you-need-lifetime-annotations">When Do You Need Lifetime Annotations?</a></h3>
<p>Rust requires explicit lifetime annotations in three main situations:</p>
<ol>
<li>
<p><strong>Functions that return references</strong>: If a function returns a reference, Rust needs to know which input parameter’s lifetime is connected to the output.</p>
</li>
<li>
<p><strong>Structs that store references</strong>: If a struct holds references to data owned by something else, those references need lifetime annotations.</p>
</li>
<li>
<p><strong>Implementing traits with references</strong>: When implementing traits for types that contain references, lifetimes need to be specified.</p>
</li>
</ol>
<p>Let’s look at a few examples to make these clearer.</p>
<h3 id="example-function-returning-a-reference"><a class="header" href="#example-function-returning-a-reference">Example: Function Returning a Reference</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Without lifetime annotations, this won't compile
fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">}</span></code></pre></pre>
<p>This function works because of lifetime elision rules—the compiler automatically assigns the same lifetime to the input and output. It’s equivalent to:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
    // function body unchanged
}
<span class="boring">}</span></code></pre></pre>
<p>However, for functions with multiple reference parameters, things get more complex:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, the lifetime annotation is necessary because the compiler can’t infer which input parameter’s lifetime should constrain the output.</p>
<h3 id="example-structs-holding-references"><a class="header" href="#example-structs-holding-references">Example: Structs Holding References</a></h3>
<p>When a struct holds references to data owned by something else, we need to add lifetime parameters:</p>
<pre><pre class="playground"><code class="language-rust">struct Excerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let excerpt = Excerpt {
        part: first_sentence,
    };

    println!("Excerpt: {}", excerpt.part);
}</code></pre></pre>
<p>The <code>Excerpt</code> struct needs the lifetime parameter <code>'a</code> to indicate that it cannot outlive the string slice it references.</p>
<h2 id="lifetime-elision-rules"><a class="header" href="#lifetime-elision-rules">Lifetime Elision Rules</a></h2>
<p>Rust’s compiler uses three rules to infer lifetimes when they aren’t explicitly annotated. These “lifetime elision rules” make code cleaner and more readable for common patterns.</p>
<h3 id="rule-1-each-parameter-gets-its-own-lifetime"><a class="header" href="#rule-1-each-parameter-gets-its-own-lifetime">Rule 1: Each Parameter Gets Its Own Lifetime</a></h3>
<p>When a function has reference parameters, each parameter gets its own implicit lifetime parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: &amp;str, y: &amp;str); // implicitly: fn foo&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str);
<span class="boring">}</span></code></pre></pre>
<h3 id="rule-2-if-theres-exactly-one-input-lifetime-its-assigned-to-all-output-lifetimes"><a class="header" href="#rule-2-if-theres-exactly-one-input-lifetime-its-assigned-to-all-output-lifetimes">Rule 2: If There’s Exactly One Input Lifetime, It’s Assigned to All Output Lifetimes</a></h3>
<p>When a function has exactly one input lifetime parameter, that lifetime is assigned to all output lifetimes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word(s: &amp;str) -&gt; &amp;str; // implicitly: fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str;
<span class="boring">}</span></code></pre></pre>
<h3 id="rule-3-if-there-are-multiple-input-lifetimes-but-one-of-them-is-self-or-mut-self-the-lifetime-of-self-is-assigned-to-all-output-lifetimes"><a class="header" href="#rule-3-if-there-are-multiple-input-lifetimes-but-one-of-them-is-self-or-mut-self-the-lifetime-of-self-is-assigned-to-all-output-lifetimes">Rule 3: If There Are Multiple Input Lifetimes, but One of Them is &amp;self or &amp;mut self, the Lifetime of Self is Assigned to All Output Lifetimes</a></h3>
<p>In method signatures, if one of the parameters is <code>&amp;self</code> or <code>&amp;mut self</code>, the lifetime of <code>self</code> is assigned to all output lifetimes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Excerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
// implicitly: fn announce_and_return_part&lt;'a, 'b&gt;(&amp;'a self, announcement: &amp;'b str) -&gt; &amp;'a str;
<span class="boring">}</span></code></pre></pre>
<p>These rules cover the vast majority of cases, which is why you often don’t need to write explicit lifetime annotations.</p>
<h2 id="function-signatures-with-lifetimes"><a class="header" href="#function-signatures-with-lifetimes">Function Signatures with Lifetimes</a></h2>
<p>Function signatures with lifetimes communicate critical information to both the compiler and other developers about how references are related.</p>
<h3 id="basic-function-lifetime-annotations"><a class="header" href="#basic-function-lifetime-annotations">Basic Function Lifetime Annotations</a></h3>
<p>Let’s revisit our <code>longest</code> function to understand function lifetimes better:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The signature tells us that:</p>
<ol>
<li>Both parameters <code>x</code> and <code>y</code> must live at least as long as the lifetime <code>'a</code>.</li>
<li>The returned reference will also live at least as long as the lifetime <code>'a</code>.</li>
<li>The returned reference will be valid as long as both input references are valid.</li>
</ol>
<p>This has concrete implications for how we can use the function:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    } // string2 goes out of scope here

    // This would cause a compilation error:
    // println!("The longest string is {}", result);
}</code></pre></pre>
<h3 id="different-lifetime-parameters"><a class="header" href="#different-lifetime-parameters">Different Lifetime Parameters</a></h3>
<p>Not all references in a function signature need to have the same lifetime. Consider this example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_portion&lt;'a, 'b&gt;(s: &amp;'a str, delimiter: &amp;'b str) -&gt; &amp;'a str {
    match s.find(delimiter) {
        Some(index) =&gt; &amp;s[..index],
        None =&gt; s,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, we have two different lifetime parameters:</p>
<ul>
<li><code>'a</code> for the string being searched</li>
<li><code>'b</code> for the delimiter string</li>
</ul>
<p>The return value has the lifetime <code>'a</code>, indicating it’s derived from <code>s</code> and not from <code>delimiter</code>. This allows the <code>delimiter</code> to have a shorter lifetime than <code>s</code>.</p>
<h3 id="lifetimes-in-method-signatures"><a class="header" href="#lifetimes-in-method-signatures">Lifetimes in Method Signatures</a></h3>
<p>When defining methods on structs with lifetime parameters, the lifetime parameters must be declared after <code>impl</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }

    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The method <code>announce_and_return_part</code> doesn’t need explicit lifetime annotations for the return type due to the third lifetime elision rule.</p>
<h3 id="lifetime-bounds-on-generic-types"><a class="header" href="#lifetime-bounds-on-generic-types">Lifetime Bounds on Generic Types</a></h3>
<p>Just as we can constrain generic types with trait bounds, we can constrain generic lifetimes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This function combines generics and lifetimes, constraining the generic type <code>T</code> to implement the <code>Display</code> trait.</p>
<h2 id="structs-with-lifetime-parameters"><a class="header" href="#structs-with-lifetime-parameters">Structs with Lifetime Parameters</a></h2>
<p>Any struct that stores references must use lifetime parameters to ensure the references remain valid as long as the struct exists.</p>
<h3 id="basic-struct-lifetimes"><a class="header" href="#basic-struct-lifetimes">Basic Struct Lifetimes</a></h3>
<p>Here’s a simple example revisited:</p>
<pre><pre class="playground"><code class="language-rust">struct Excerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let excerpt = Excerpt {
        part: first_sentence,
    };

    println!("Excerpt: {}", excerpt.part);
}</code></pre></pre>
<p>The lifetime parameter <code>'a</code> indicates that an instance of <code>Excerpt</code> cannot outlive the reference it holds in its <code>part</code> field.</p>
<h3 id="multiple-lifetime-parameters-in-structs"><a class="header" href="#multiple-lifetime-parameters-in-structs">Multiple Lifetime Parameters in Structs</a></h3>
<p>Structs can have multiple lifetime parameters when they store references that might have different lifetimes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Dictionary&lt;'a, 'b&gt; {
    content: &amp;'a str,
    index: &amp;'b str,
}
<span class="boring">}</span></code></pre></pre>
<p>This struct can hold references with different lifetimes, giving you more flexibility in how you use it.</p>
<h3 id="implementing-methods-on-structs-with-lifetimes"><a class="header" href="#implementing-methods-on-structs-with-lifetimes">Implementing Methods on Structs with Lifetimes</a></h3>
<p>When implementing methods on structs with lifetime parameters, the lifetime parameters must be declared after <code>impl</code> and used in the struct name:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Excerpt&lt;'a&gt; {
    fn new(text: &amp;'a str) -&gt; Excerpt&lt;'a&gt; {
        let first_period = text.find('.').unwrap_or(text.len());
        Excerpt {
            part: &amp;text[..first_period],
        }
    }

    fn get_part(&amp;self) -&gt; &amp;str {
        self.part
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="lifetimes-and-the-drop-trait"><a class="header" href="#lifetimes-and-the-drop-trait">Lifetimes and the Drop Trait</a></h3>
<p>An important consideration with structs containing references is the <code>Drop</code> trait implementation. Rust ensures that a struct implementing <code>Drop</code> doesn’t outlive the references it contains:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DebugWrapper&lt;'a&gt; {
    reference: &amp;'a i32,
}

impl&lt;'a&gt; Drop for DebugWrapper&lt;'a&gt; {
    fn drop(&amp;mut self) {
        println!("Dropping DebugWrapper with data: {}", self.reference);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="static-lifetimes"><a class="header" href="#static-lifetimes">Static Lifetimes</a></h2>
<p>The special lifetime <code>'static</code> represents references that can live for the entire duration of the program. String literals have the <code>'static</code> lifetime because they’re stored directly in the program’s binary:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = "I have a static lifetime.";
<span class="boring">}</span></code></pre></pre>
<p>String literals are stored in the program’s read-only memory and remain valid for the entire program execution.</p>
<h3 id="when-to-use-static"><a class="header" href="#when-to-use-static">When to Use ’static</a></h3>
<p>The <code>'static</code> lifetime is useful in several scenarios:</p>
<ol>
<li>
<p><strong>For string literals and constants</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_POINTS: u32 = 100_000;
const WELCOME_MESSAGE: &amp;'static str = "Welcome to our application!";
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>For errors that might outlive their creation context</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_error_message() -&gt; &amp;'static str {
    "An error occurred during processing"
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>For configuration that exists throughout program execution</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Config {
    app_name: &amp;'static str,
    version: &amp;'static str,
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="caution-with-static"><a class="header" href="#caution-with-static">Caution with ’static</a></h3>
<p>Despite its utility, <code>'static</code> should be used carefully:</p>
<ul>
<li>It indicates that a reference will never be dropped, which can potentially lead to memory leaks if used inappropriately.</li>
<li>It’s often better to use owned types like <code>String</code> instead of <code>&amp;'static str</code> when the data is dynamic.</li>
<li>The infamous error message “consider using the <code>'static</code> lifetime” should not be followed blindly—it’s rarely the right solution.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Usually better:
struct Config {
    app_name: String,
    version: String,
}

// Instead of:
struct Config {
    app_name: &amp;'static str,
    version: &amp;'static str,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="making-values-live-for-static"><a class="header" href="#making-values-live-for-static">Making Values Live for ’static</a></h3>
<p>It’s possible to create data at runtime that lives for the entire program duration by leaking memory:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

let leaked_string: &amp;'static str = Box::leak(
    format!("Generated at runtime: {}", chrono::Local::now()).into_boxed_str()
);

println!("{}", leaked_string);
<span class="boring">}</span></code></pre></pre>
<p>This pattern should be used sparingly and with careful consideration, as it deliberately creates memory that is never freed.</p>
<h2 id="lifetime-bounds"><a class="header" href="#lifetime-bounds">Lifetime Bounds</a></h2>
<p>Lifetime bounds constrain generic lifetimes, similar to how trait bounds constrain generic types.</p>
<h3 id="basic-lifetime-bounds"><a class="header" href="#basic-lifetime-bounds">Basic Lifetime Bounds</a></h3>
<p>You can specify that one lifetime must outlive another:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest_and_substring&lt;'a, 'b: 'a&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str {
    // 'b: 'a means that 'b must live at least as long as 'a
    if x.len() &gt; y.len() {
        x
    } else {
        let substring = &amp;y[..x.len()]; // We can return a slice of y because 'b: 'a
        substring
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The notation <code>'b: 'a</code> means “<code>'b</code> outlives <code>'a</code>” or “<code>'b</code> lives at least as long as <code>'a</code>.”</p>
<h3 id="lifetime-bounds-on-generic-types-1"><a class="header" href="#lifetime-bounds-on-generic-types-1">Lifetime Bounds on Generic Types</a></h3>
<p>You can also apply lifetime bounds to generic type parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ref&lt;'a, T: 'a&gt; {
    // T: 'a means that all references in T must outlive 'a
    value: &amp;'a T,
}
<span class="boring">}</span></code></pre></pre>
<p>This notation <code>T: 'a</code> means “all references in <code>T</code> must outlive the lifetime <code>'a</code>.”</p>
<h3 id="combining-trait-and-lifetime-bounds"><a class="header" href="#combining-trait-and-lifetime-bounds">Combining Trait and Lifetime Bounds</a></h3>
<p>Lifetime bounds can be combined with trait bounds:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_if_display&lt;'a, T: Display + 'a&gt;(value: &amp;'a T) {
    println!("{}", value);
}
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>T</code> must implement <code>Display</code> and all references in <code>T</code> must outlive <code>'a</code>.</p>
<h2 id="lifetime-variance"><a class="header" href="#lifetime-variance">Lifetime Variance</a></h2>
<p>Variance is a complex but important concept that determines how subtyping relationships between lifetimes affect complex types.</p>
<h3 id="understanding-variance"><a class="header" href="#understanding-variance">Understanding Variance</a></h3>
<p>In type theory, variance describes how subtyping relationships affect complex types. With lifetimes, this relates to how a longer (outliving) lifetime can be used where a shorter lifetime is expected.</p>
<p>There are three kinds of variance:</p>
<ol>
<li><strong>Covariant</strong>: If <code>'a</code> outlives <code>'b</code>, then <code>F&lt;'a&gt;</code> is a subtype of <code>F&lt;'b&gt;</code>.</li>
<li><strong>Contravariant</strong>: If <code>'a</code> outlives <code>'b</code>, then <code>F&lt;'b&gt;</code> is a subtype of <code>F&lt;'a&gt;</code>.</li>
<li><strong>Invariant</strong>: Neither covariant nor contravariant relationships exist.</li>
</ol>
<h3 id="lifetimes-and-covariance"><a class="header" href="#lifetimes-and-covariance">Lifetimes and Covariance</a></h3>
<p>In Rust, most types are covariant with respect to their lifetime parameters. This means if <code>'a</code> outlives <code>'b</code>, you can use a <code>&amp;'a T</code> where a <code>&amp;'b T</code> is expected:</p>
<pre><pre class="playground"><code class="language-rust">fn foo&lt;'a&gt;(x: &amp;'a str) {
    println!("{}", x);
}

fn main() {
    let long_lived_string = String::from("This string lives a long time");

    {
        let short_lived_string = String::from("Short life");

        // This works because 'long_lived_string' outlives 'short_lived_string'
        // and &amp;str is covariant over its lifetime parameter
        foo(&amp;long_lived_string);
        foo(&amp;short_lived_string);
    }

    // still valid
    foo(&amp;long_lived_string);
}</code></pre></pre>
<h3 id="mutable-references-and-invariance"><a class="header" href="#mutable-references-and-invariance">Mutable References and Invariance</a></h3>
<p>Unlike immutable references, mutable references are invariant over their lifetime parameter. This stricter relationship prevents potential memory safety issues:</p>
<pre><pre class="playground"><code class="language-rust">struct MutRef&lt;'a, T&gt; {
    reference: &amp;'a mut T,
}

fn main() {
    let mut long_lived_value = 10;
    let mut short_lived_value = 20;

    let mut long_ref = MutRef { reference: &amp;mut long_lived_value };

    // This wouldn't compile if we tried:
    // long_ref.reference = &amp;mut short_lived_value;

    // Because it would allow us to hold a reference to a short-lived value
    // in a structure that is expected to live longer
}</code></pre></pre>
<p>Understanding variance helps you reason about why some lifetime-related code compiles while other similar code might not.</p>
<h2 id="higher-ranked-lifetimes"><a class="header" href="#higher-ranked-lifetimes">Higher-Ranked Lifetimes</a></h2>
<p>Higher-ranked lifetimes, often seen as <code>for&lt;'a&gt;</code> syntax, allow for more flexible relationships between functions and the lifetimes they work with.</p>
<h3 id="function-pointers-with-lifetimes"><a class="header" href="#function-pointers-with-lifetimes">Function Pointers with Lifetimes</a></h3>
<p>Consider a function that takes a callback which itself takes a reference:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn apply_to_string&lt;F&gt;(f: F) -&gt; String
where
    F: Fn(&amp;str) -&gt; &amp;str,
{
    let s = String::from("Hello, world!");
    let result = f(&amp;s);
    result.to_string()
}
<span class="boring">}</span></code></pre></pre>
<p>This won’t compile because the compiler can’t determine the relationship between the lifetime of the string and the callback’s signature. Higher-ranked lifetimes solve this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn apply_to_string&lt;F&gt;(f: F) -&gt; String
where
    F: for&lt;'a&gt; Fn(&amp;'a str) -&gt; &amp;'a str,
{
    let s = String::from("Hello, world!");
    let result = f(&amp;s);
    result.to_string()
}
<span class="boring">}</span></code></pre></pre>
<p>The notation <code>for&lt;'a&gt;</code> means “for any lifetime <code>'a</code>”, making the function more flexible.</p>
<h3 id="hrtb-higher-ranked-trait-bounds"><a class="header" href="#hrtb-higher-ranked-trait-bounds">HRTB (Higher-Ranked Trait Bounds)</a></h3>
<p>Higher-ranked trait bounds allow you to specify that a type must implement a trait for all possible lifetimes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Parser {
    fn parse&lt;'a&gt;(&amp;self, input: &amp;'a str) -&gt; Result&lt;&amp;'a str, &amp;'a str&gt;;
}

fn parse_and_process&lt;P&gt;(parser: P, input: &amp;str)
where
    P: for&lt;'a&gt; Parser&lt;Output = &amp;'a str&gt;,
{
    // Implementation
}
<span class="boring">}</span></code></pre></pre>
<p>This pattern is particularly useful when working with traits that have methods taking references.</p>
<h2 id="advanced-lifetime-patterns"><a class="header" href="#advanced-lifetime-patterns">Advanced Lifetime Patterns</a></h2>
<p>With the fundamentals understood, let’s explore some advanced patterns involving lifetimes.</p>
<h3 id="self-referential-structs"><a class="header" href="#self-referential-structs">Self-Referential Structs</a></h3>
<p>Creating structs that contain references to their own fields is challenging but sometimes necessary:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;

struct SelfReferential&lt;'a&gt; {
    value: String,
    // We use a zero-sized PhantomData to tie the lifetime to our struct
    // without actually storing a reference
    _phantom: PhantomData&lt;&amp;'a ()&gt;,
}

impl&lt;'a&gt; SelfReferential&lt;'a&gt; {
    // Implementation that ensures safety
}
<span class="boring">}</span></code></pre></pre>
<p>Modern solutions for self-referential structs often use crates like <code>ouroboros</code> or <code>rental</code>.</p>
<h3 id="lifetime-splitting-and-reborrowing"><a class="header" href="#lifetime-splitting-and-reborrowing">Lifetime Splitting and Reborrowing</a></h3>
<p>Sometimes you need to split a mutable borrow into multiple non-overlapping borrows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn split_borrow(slice: &amp;mut [i32]) {
    let len = slice.len();
    let (first, rest) = slice.split_at_mut(1);
    let first = &amp;mut first[0];
    // Now we have a mutable reference to the first element
    // and can still use 'rest' separately
}
<span class="boring">}</span></code></pre></pre>
<p>This pattern is fundamental to many data structures in Rust, such as trees where you need to modify a node and its children separately.</p>
<h3 id="nll-non-lexical-lifetimes"><a class="header" href="#nll-non-lexical-lifetimes">NLL (Non-Lexical Lifetimes)</a></h3>
<p>Modern Rust has “non-lexical lifetimes,” meaning the compiler can determine when a reference is last used and end its lifetime there, even if the lexical scope continues:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v = vec![1, 2, 3];

    // In older Rust, this would error:
    let first = &amp;v[0];
    println!("First element: {}", first);

    // Even though 'first' is no longer used after the println!,
    // we can now modify 'v'
    v.push(4);
}</code></pre></pre>
<p>This feature greatly improved the ergonomics of borrowing in Rust.</p>
<h2 id="common-lifetime-errors-and-solutions"><a class="header" href="#common-lifetime-errors-and-solutions">Common Lifetime Errors and Solutions</a></h2>
<p>Let’s examine some common lifetime-related errors and how to solve them.</p>
<h3 id="borrowed-value-does-not-live-long-enough"><a class="header" href="#borrowed-value-does-not-live-long-enough">“Borrowed Value Does Not Live Long Enough”</a></h3>
<p>This is the most common lifetime error:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let r;
    {
        let x = 5;
        r = &amp;x; // Error: borrowed value does not live long enough
    }
    println!("r: {}", r);
}</code></pre></pre>
<p><strong>Solution</strong>: Ensure the referenced value lives at least as long as the reference.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let r = &amp;x; // Now x lives as long as r
    println!("r: {}", r);
}</code></pre></pre>
<h3 id="lifetime-may-not-live-long-enough"><a class="header" href="#lifetime-may-not-live-long-enough">“Lifetime May Not Live Long Enough”</a></h3>
<p>This occurs when returning references from functions with multiple lifetime parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_one&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str {
    if x.len() &lt; y.len() {
        x
    } else {
        y // Error: y's lifetime 'b may not live as long as 'a
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Solution</strong>: Either constrain the lifetimes (<code>'b: 'a</code>) or use a single lifetime for both parameters.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_one&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &lt; y.len() {
        x
    } else {
        y // Now both x and y have the same lifetime
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="missing-lifetime-specifier"><a class="header" href="#missing-lifetime-specifier">“Missing Lifetime Specifier”</a></h3>
<p>This error occurs when the compiler can’t infer which lifetime to use:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Excerpt {
    part: &amp;str, // Error: missing lifetime specifier
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Solution</strong>: Add an explicit lifetime parameter.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Excerpt&lt;'a&gt; {
    part: &amp;'a str,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cannot-return-reference-to-local-variable"><a class="header" href="#cannot-return-reference-to-local-variable">“Cannot Return Reference to Local Variable”</a></h3>
<p>Attempting to return a reference to a value created within a function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_and_return_reference() -&gt; &amp;str {
    let s = String::from("Hello");
    &amp;s // Error: cannot return reference to local variable `s`
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Solution</strong>: Return an owned value instead of a reference.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_and_return_owned() -&gt; String {
    String::from("Hello")
}
<span class="boring">}</span></code></pre></pre>
<h2 id="troubleshooting-lifetime-issues"><a class="header" href="#troubleshooting-lifetime-issues">Troubleshooting Lifetime Issues</a></h2>
<p>When faced with lifetime issues, follow these steps:</p>
<ol>
<li>
<p><strong>Understand the Error</strong>: Read the compiler error carefully; it often provides hints about what’s wrong.</p>
</li>
<li>
<p><strong>Trace Lifetimes</strong>: Mentally trace how long each value lives and when references to it are used.</p>
</li>
<li>
<p><strong>Start with Simple Annotations</strong>: Begin with the simplest lifetime annotations and refine as needed.</p>
</li>
<li>
<p><strong>Consider Ownership</strong>: Sometimes converting to owned types (<code>String</code> instead of <code>&amp;str</code>) is cleaner than complex lifetime annotations.</p>
</li>
<li>
<p><strong>Use NLL Hints</strong>: The compiler often suggests how to fix non-lexical lifetime issues.</p>
</li>
<li>
<p><strong>Look for Patterns</strong>: Many lifetime issues follow common patterns with known solutions.</p>
</li>
<li>
<p><strong>Refactor</strong>: Sometimes restructuring your code is easier than forcing complex lifetime relationships.</p>
</li>
</ol>
<h2 id="-project-data-validator"><a class="header" href="#-project-data-validator">🔨 Project: Data Validator</a></h2>
<p>Let’s build a data validation library that handles complex lifetime relationships. This project will demonstrate practical lifetime usage in a real-world scenario.</p>
<h3 id="project-goals"><a class="header" href="#project-goals">Project Goals</a></h3>
<ol>
<li>Create a validation system for structured data</li>
<li>Support multiple validation rules</li>
<li>Allow references to be passed between validators</li>
<li>Handle complex lifetime relationships</li>
<li>Provide clear error messages</li>
</ol>
<h3 id="step-1-setup-the-project"><a class="header" href="#step-1-setup-the-project">Step 1: Setup the Project</a></h3>
<pre><code class="language-bash">cargo new data_validator
cd data_validator
</code></pre>
<h3 id="step-2-define-the-core-validator-traits"><a class="header" href="#step-2-define-the-core-validator-traits">Step 2: Define the Core Validator Traits</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs

/// A trait for types that can validate data
pub trait Validator&lt;'a, T&gt; {
    type Error;

    /// Validates the given data, returning Ok(()) if valid
    /// or Err with details if invalid
    fn validate(&amp;self, data: &amp;'a T) -&gt; Result&lt;(), Self::Error&gt;;
}

/// A trait for validation rules that can be combined
pub trait ValidationRule&lt;'a, T&gt;: Validator&lt;'a, T&gt; {
    /// Combine this rule with another rule
    fn and&lt;V&gt;(self, other: V) -&gt; AndValidator&lt;Self, V&gt;
    where
        Self: Sized,
        V: Validator&lt;'a, T, Error = Self::Error&gt;,
    {
        AndValidator {
            first: self,
            second: other,
        }
    }

    /// Apply this rule conditionally
    fn when&lt;F&gt;(self, condition: F) -&gt; ConditionalValidator&lt;Self, F&gt;
    where
        Self: Sized,
        F: Fn(&amp;'a T) -&gt; bool,
    {
        ConditionalValidator {
            validator: self,
            condition,
        }
    }
}

// Implement ValidationRule for any type that implements Validator
impl&lt;'a, T, V&gt; ValidationRule&lt;'a, T&gt; for V
where
    V: Validator&lt;'a, T&gt;,
{
}
<span class="boring">}</span></code></pre></pre>
<h3 id="step-3-implement-composite-validators"><a class="header" href="#step-3-implement-composite-validators">Step 3: Implement Composite Validators</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs (continued)

/// A validator that combines two validators
pub struct AndValidator&lt;A, B&gt; {
    first: A,
    second: B,
}

impl&lt;'a, T, A, B&gt; Validator&lt;'a, T&gt; for AndValidator&lt;A, B&gt;
where
    A: Validator&lt;'a, T&gt;,
    B: Validator&lt;'a, T, Error = A::Error&gt;,
{
    type Error = A::Error;

    fn validate(&amp;self, data: &amp;'a T) -&gt; Result&lt;(), Self::Error&gt; {
        self.first.validate(data)?;
        self.second.validate(data)
    }
}

/// A validator that applies conditionally
pub struct ConditionalValidator&lt;V, F&gt; {
    validator: V,
    condition: F,
}

impl&lt;'a, T, V, F&gt; Validator&lt;'a, T&gt; for ConditionalValidator&lt;V, F&gt;
where
    V: Validator&lt;'a, T&gt;,
    F: Fn(&amp;'a T) -&gt; bool,
{
    type Error = V::Error;

    fn validate(&amp;self, data: &amp;'a T) -&gt; Result&lt;(), Self::Error&gt; {
        if (self.condition)(data) {
            self.validator.validate(data)
        } else {
            Ok(())
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="step-4-create-string-validators"><a class="header" href="#step-4-create-string-validators">Step 4: Create String Validators</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/string_validators.rs

use crate::Validator;
use std::marker::PhantomData;

#[derive(Debug)]
pub enum StringError {
    TooShort { min: usize, actual: usize },
    TooLong { max: usize, actual: usize },
    DoesNotContain(&amp;'static str),
    DoesNotMatch(&amp;'static str),
    Empty,
}

/// Validates minimum string length
pub struct MinLength&lt;'r&gt; {
    min: usize,
    _phantom: PhantomData&lt;&amp;'r ()&gt;,
}

impl&lt;'r&gt; MinLength&lt;'r&gt; {
    pub fn new(min: usize) -&gt; Self {
        Self {
            min,
            _phantom: PhantomData,
        }
    }
}

impl&lt;'a, 'r&gt; Validator&lt;'a, str&gt; for MinLength&lt;'r&gt; {
    type Error = StringError;

    fn validate(&amp;self, data: &amp;'a str) -&gt; Result&lt;(), Self::Error&gt; {
        let len = data.len();
        if len &lt; self.min {
            Err(StringError::TooShort {
                min: self.min,
                actual: len,
            })
        } else {
            Ok(())
        }
    }
}

/// Validates maximum string length
pub struct MaxLength&lt;'r&gt; {
    max: usize,
    _phantom: PhantomData&lt;&amp;'r ()&gt;,
}

impl&lt;'r&gt; MaxLength&lt;'r&gt; {
    pub fn new(max: usize) -&gt; Self {
        Self {
            max,
            _phantom: PhantomData,
        }
    }
}

impl&lt;'a, 'r&gt; Validator&lt;'a, str&gt; for MaxLength&lt;'r&gt; {
    type Error = StringError;

    fn validate(&amp;self, data: &amp;'a str) -&gt; Result&lt;(), Self::Error&gt; {
        let len = data.len();
        if len &gt; self.max {
            Err(StringError::TooLong {
                max: self.max,
                actual: len,
            })
        } else {
            Ok(())
        }
    }
}

/// Checks if a string is not empty
pub struct NotEmpty;

impl&lt;'a&gt; Validator&lt;'a, str&gt; for NotEmpty {
    type Error = StringError;

    fn validate(&amp;self, data: &amp;'a str) -&gt; Result&lt;(), Self::Error&gt; {
        if data.is_empty() {
            Err(StringError::Empty)
        } else {
            Ok(())
        }
    }
}

/// Checks if a string contains a substring
pub struct Contains&lt;'s&gt; {
    substring: &amp;'s str,
}

impl&lt;'s&gt; Contains&lt;'s&gt; {
    pub fn new(substring: &amp;'s str) -&gt; Self {
        Self { substring }
    }
}

impl&lt;'a, 's&gt; Validator&lt;'a, str&gt; for Contains&lt;'s&gt; {
    type Error = StringError;

    fn validate(&amp;self, data: &amp;'a str) -&gt; Result&lt;(), Self::Error&gt; {
        if data.contains(self.substring) {
            Ok(())
        } else {
            Err(StringError::DoesNotContain(self.substring))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="step-5-create-struct-validators"><a class="header" href="#step-5-create-struct-validators">Step 5: Create Struct Validators</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/struct_validators.rs

use crate::Validator;
use std::marker::PhantomData;

#[derive(Debug)]
pub enum FieldError&lt;E&gt; {
    FieldValidationFailed { field: &amp;'static str, error: E },
    MissingField(&amp;'static str),
}

/// Validates a specific field of a struct
pub struct FieldValidator&lt;'r, F, V&gt; {
    field_name: &amp;'static str,
    field_accessor: F,
    validator: V,
    _phantom: PhantomData&lt;&amp;'r ()&gt;,
}

impl&lt;'r, F, V&gt; FieldValidator&lt;'r, F, V&gt; {
    pub fn new(field_name: &amp;'static str, field_accessor: F, validator: V) -&gt; Self {
        Self {
            field_name,
            field_accessor,
            validator,
            _phantom: PhantomData,
        }
    }
}

impl&lt;'a, 'r, T, F, V, E&gt; Validator&lt;'a, T&gt; for FieldValidator&lt;'r, F, V&gt;
where
    F: Fn(&amp;'a T) -&gt; Option&lt;&amp;'a V::Target&gt;,
    V: Validator&lt;'a, V::Target, Error = E&gt;,
{
    type Error = FieldError&lt;E&gt;;

    fn validate(&amp;self, data: &amp;'a T) -&gt; Result&lt;(), Self::Error&gt; {
        match (self.field_accessor)(data) {
            Some(field_value) =&gt; {
                self.validator.validate(field_value).map_err(|error| {
                    FieldError::FieldValidationFailed {
                        field: self.field_name,
                        error,
                    }
                })
            }
            None =&gt; Err(FieldError::MissingField(self.field_name)),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="step-6-create-a-validation-context"><a class="header" href="#step-6-create-a-validation-context">Step 6: Create a Validation Context</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/context.rs

use crate::Validator;
use std::collections::HashMap;
use std::hash::Hash;

/// A validation context that can store and retrieve values by key
pub struct ValidationContext&lt;'a, K&gt; {
    values: HashMap&lt;K, Box&lt;dyn std::any::Any + 'a&gt;&gt;,
}

impl&lt;'a, K: Eq + Hash&gt; ValidationContext&lt;'a, K&gt; {
    pub fn new() -&gt; Self {
        Self {
            values: HashMap::new(),
        }
    }

    pub fn insert&lt;T: 'a&gt;(&amp;mut self, key: K, value: T) {
        self.values.insert(key, Box::new(value));
    }

    pub fn get&lt;T: 'a&gt;(&amp;self, key: &amp;K) -&gt; Option&lt;&amp;T&gt; {
        self.values.get(key).and_then(|boxed| boxed.downcast_ref())
    }
}

/// A validator that uses context values
pub struct ContextValidator&lt;'ctx, K, F, V&gt; {
    key: K,
    validator_factory: F,
    _phantom: std::marker::PhantomData&lt;&amp;'ctx V&gt;,
}

impl&lt;'ctx, K: Clone, F, V&gt; ContextValidator&lt;'ctx, K, F, V&gt; {
    pub fn new(key: K, validator_factory: F) -&gt; Self {
        Self {
            key,
            validator_factory,
            _phantom: std::marker::PhantomData,
        }
    }
}

impl&lt;'a, 'ctx, K, F, V, T, E&gt; Validator&lt;'a, (T, &amp;'a ValidationContext&lt;'ctx, K&gt;)&gt;
    for ContextValidator&lt;'ctx, K, F, V&gt;
where
    K: Eq + Hash + Clone,
    F: Fn(&amp;'a ValidationContext&lt;'ctx, K&gt;) -&gt; Option&lt;V&gt;,
    V: Validator&lt;'a, T, Error = E&gt;,
{
    type Error = Option&lt;E&gt;;

    fn validate(&amp;self, data: &amp;'a (T, &amp;'a ValidationContext&lt;'ctx, K&gt;)) -&gt; Result&lt;(), Self::Error&gt; {
        let (value, context) = data;
        match (self.validator_factory)(context) {
            Some(validator) =&gt; validator.validate(value).map_err(Some),
            None =&gt; Ok(()),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="step-7-create-examples-and-tests"><a class="header" href="#step-7-create-examples-and-tests">Step 7: Create Examples and Tests</a></h3>
<pre><pre class="playground"><code class="language-rust">// src/main.rs

use data_validator::{
    context::ValidationContext,
    string_validators::{Contains, MaxLength, MinLength, NotEmpty},
    struct_validators::FieldValidator,
    ValidationRule, Validator,
};

// Define a sample user struct
struct User&lt;'a&gt; {
    username: &amp;'a str,
    email: &amp;'a str,
    bio: Option&lt;&amp;'a str&gt;,
}

fn main() {
    // Create some validators
    let username_validator = NotEmpty
        .and(MinLength::new(3))
        .and(MaxLength::new(20));

    let email_validator = NotEmpty.and(Contains::new("@"));

    let bio_validator = MaxLength::new(200).when(|bio: &amp;&amp;str| !bio.is_empty());

    // Create field validators
    let validate_username = FieldValidator::new(
        "username",
        |user: &amp;User| Some(user.username),
        username_validator,
    );

    let validate_email = FieldValidator::new(
        "email",
        |user: &amp;User| Some(user.email),
        email_validator,
    );

    let validate_bio = FieldValidator::new(
        "bio",
        |user: &amp;User| user.bio,
        bio_validator,
    );

    // Create a valid user
    let valid_user = User {
        username: "rust_lover",
        email: "rust@example.com",
        bio: Some("I love Rust programming!"),
    };

    // Validate the user
    match validate_username.validate(&amp;valid_user) {
        Ok(()) =&gt; println!("Username is valid!"),
        Err(e) =&gt; println!("Username validation failed: {:?}", e),
    }

    match validate_email.validate(&amp;valid_user) {
        Ok(()) =&gt; println!("Email is valid!"),
        Err(e) =&gt; println!("Email validation failed: {:?}", e),
    }

    match validate_bio.validate(&amp;valid_user) {
        Ok(()) =&gt; println!("Bio is valid!"),
        Err(e) =&gt; println!("Bio validation failed: {:?}", e),
    }

    // Create an invalid user
    let invalid_user = User {
        username: "a",
        email: "not-an-email",
        bio: Some("This bio is way too long and exceeds the maximum length that we have set for our validation rules. It goes on and on with unnecessary information just to trigger our validation error for demonstration purposes. Let's see if our validator catches this properly and provides a good error message to help users correct their input."),
    };

    // Validate the invalid user and print detailed errors
    println!("\nValidating invalid user:");

    match validate_username.validate(&amp;invalid_user) {
        Ok(()) =&gt; println!("Username is valid!"),
        Err(e) =&gt; println!("Username validation failed: {:?}", e),
    }

    match validate_email.validate(&amp;invalid_user) {
        Ok(()) =&gt; println!("Email is valid!"),
        Err(e) =&gt; println!("Email validation failed: {:?}", e),
    }

    match validate_bio.validate(&amp;invalid_user) {
        Ok(()) =&gt; println!("Bio is valid!"),
        Err(e) =&gt; println!("Bio validation failed: {:?}", e),
    }

    // Using validation context
    println!("\nUsing validation context:");
    let mut context = ValidationContext::new();
    context.insert("min_username_length", 5); // Stricter requirement in context

    // We could create validators that use this context
    // but we'll leave that as an exercise
}</code></pre></pre>
<h3 id="step-8-running-the-project"><a class="header" href="#step-8-running-the-project">Step 8: Running the Project</a></h3>
<pre><code class="language-bash">cargo run
</code></pre>
<p>This project demonstrates:</p>
<ol>
<li>Complex lifetime relationships in traits and structs</li>
<li>Generics combined with lifetimes</li>
<li>Handling references with different lifetimes</li>
<li>Building composable abstractions</li>
<li>Proper error handling with lifetimes</li>
</ol>
<p>The validator library we’ve built is highly extensible. You could expand it with:</p>
<ol>
<li>Numeric validators</li>
<li>Collection validators</li>
<li>Custom error formatting</li>
<li>Asynchronous validation</li>
<li>Context-dependent validation rules</li>
</ol>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this chapter, we’ve explored the rich and complex world of lifetimes in Rust. We’ve seen:</p>
<ul>
<li>Why lifetimes exist and the problems they solve</li>
<li>How to annotate lifetimes in functions, structs, and implementations</li>
<li>How lifetime elision rules simplify common code patterns</li>
<li>Advanced lifetime concepts like bounds, variance, and higher-ranked lifetimes</li>
<li>Common lifetime errors and their solutions</li>
<li>How to build complex systems that safely manage references</li>
</ul>
<p>Lifetimes are one of Rust’s most distinctive features. While they can be challenging to master, they enable Rust’s unique combination of safety and performance without garbage collection. With practice, working with lifetimes becomes more intuitive, and you’ll find yourself able to express complex relationships between references with confidence.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li>
<p><strong>Modify the Data Validator Project</strong>: Add a new validator type that validates collections (vectors or slices).</p>
</li>
<li>
<p><strong>Reference Holding Collection</strong>: Implement a collection type that can safely hold references with different lifetimes.</p>
</li>
<li>
<p><strong>Lifetime Debugging</strong>: Take a piece of code that doesn’t compile due to lifetime issues and fix it. Then explain why your solution works.</p>
</li>
<li>
<p><strong>Implement a Custom Iterator</strong>: Create an iterator that yields references to elements and requires lifetime annotations.</p>
</li>
<li>
<p><strong>Build a Document Processor</strong>: Create a system that processes text documents, using lifetimes to safely manage references to document sections.</p>
</li>
</ol>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/reference/lifetime-elision.html">The Rust Reference on Lifetimes</a></li>
<li><a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a> - The dark arts of unsafe Rust</li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/">Learning Rust With Entirely Too Many Linked Lists</a> - Advanced ownership and lifetime patterns</li>
<li><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md">Common Rust Lifetime Misconceptions</a></li>
<li><a href="https://medium.com/nearprotocol/understanding-rust-lifetimes-e813bcd405fa">Understanding Rust Lifetimes</a></li>
<li><a href="https://doc.rust-lang.org/book/ch19-02-advanced-lifetimes.html">Advanced Rust Programming</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapters/17-advanced-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapters/19-panic.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapters/17-advanced-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapters/19-panic.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
